<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      <meta name="author" content="Bruce T. Draine<br />
Princeton University Observatory<br />
Princeton NJ 08544-1001<br />
(<span><code>draine@astro.princeton.edu</code></span>)<br />
and<br />
<br />
Piotr J. Flatau<br />
University of California San Diego<br />
Scripps Institution of Oceanography<br />
La Jolla CA 92093-0221<br />
(<span><code>pflatau@ucsd.edu</code></span>)">
      
      <title>DDSCAT 7.3 User Guide</title>
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="https://ashki23.github.io/styles.css">
      <link rel="stylesheet" href="custom.css">
            <!-- Add favicon here -->
            <!-- Add site-verifications here -->
         </head>
   <body>
            <!-- From https://getbootstrap.com/docs/4.5/components/navbar/ -->
            <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
               <a class="navbar-brand" href="#">DDSCAT 7.3</a>
               <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
               <span class="navbar-toggler-icon"></span>
               </button>
               <div class="collapse navbar-collapse" id="navbarSupportedContent">
                  <ul class="navbar-nav mr-auto">
                     <li class="nav-item active">
                        <a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
                     </li>
                     <li class="nav-item">
                        <a class="nav-link" href="http://ddscat.wikidot.com/">Website</a>
                     </li>
                     <li class="nav-item">
                        <a class="nav-link" href="http://ddscat.wikidot.com/downloads">Download</a>
                     </li>
                     <li class="nav-item">
                        <a class="nav-link" href="https://pythonhosted.org/pyddscat/userguide/userguide.html">Python interface</a>
                     </li>
                     <!-- <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Dropdown
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                           <a class="dropdown-item" href="#">Action</a>
                           <a class="dropdown-item" href="#">Another action</a>
                           <div class="dropdown-divider"></div>
                           <a class="dropdown-item" href="#">Something else here</a>
                        </div>
                     </li> -->

                  </ul>
                  <form class="form-inline my-2 my-lg-0">
                     <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
                     <button class="btn btn-outline-info my-2 my-sm-0" type="submit">Search</button>
                  </form>
               </div>
            </nav>
            <div class="container">
         <h1 class="title"> <span><strong>User Guide for the Discrete
Dipole</strong></span><br />
<span><strong>Approximation Code <span><strong>DDSCAT
7.3</strong></span></strong></span></h1>
                  <div class="row">
            <div class="col-xl-10"><h1
id="introduction">Introduction<span id="intro"
label="intro"></span></h1>
<p>DDSCAT is a software package to calculate scattering and absorption
of electromagnetic waves by targets with arbitrary geometries using the
“discrete dipole approximation” (DDA). In this approximation the target
is replaced by an array of point dipoles (or, more precisely,
polarizable points); the electromagnetic scattering problem for an
incident periodic wave interacting with this array of point dipoles is
then solved essentially exactly. The DDA (sometimes referred to as the
“coupled dipole approximation”) was apparently first proposed by <span
class="citation" data-cites="Purcell+Pennypacker_1973"></span>. DDA
theory was reviewed and developed further by <span class="citation"
data-cites="Draine_1988"></span>, <span class="citation"
data-cites="Draine+Goodman_1993"></span>, reviewed by <span
class="citation" data-cites="Draine+Flatau_1994"></span>, and recently
extended to periodic structures by <span class="citation"
data-cites="Draine+Flatau_2008a"></span>.</p>
<p><span><strong>DDSCAT 7.3</strong></span>, the current release of
DDSCAT, is an open-source Fortran 90 implementation of the DDA developed
by the authors.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> <span><strong>DDSCAT
7.3</strong></span> calculates absorption and scattering by isolated
targets, or targets that are periodic in one or two dimensions, using
methods described by <span class="citation"
data-cites="Draine+Flatau_2008a"></span>.</p>
<p>DDSCAT is intended to be a versatile tool, suitable for a wide
variety of applications including studies of interstellar dust,
atmospheric aerosols, blood cells, marine microorganisms, and
nanostructure arrays. As provided, <span><strong>DDSCAT
7.3</strong></span> should be usable for many applications without
modification, but the program is written in a modular form, so that
modifications, if required, should be fairly straightforward.</p>
<p>The authors make this code openly available to others, in the hope
that it will prove a useful tool. We ask only that:</p>
<ul>
<li><p>If you publish results obtained using
<span><strong>DDSCAT</strong></span>, please acknowledge the source of
the code, and cite relevant papers, such as <span class="citation"
data-cites="Draine_1988"></span>, <span class="citation"
data-cites="Goodman+Draine+Flatau_1990"></span>, <span class="citation"
data-cites="Draine+Flatau_1994"></span>, <span class="citation"
data-cites="Draine+Flatau_2008a"></span>, and <span class="citation"
data-cites="Flatau+Draine_2012"></span>.</p></li>
<li><p>If you discover any errors in the code or documentation, please
promptly communicate them to the authors.</p></li>
<li><p>You comply with the “copyleft" agreement (more formally, the GNU
General Public License) of the Free Software Foundation: you may copy,
distribute, and/or modify the software identified as coming under this
agreement. If you distribute copies of this software, you must give the
recipients all the rights which you have. See the file
<span><code>doc/copyleft.txt</code></span> distributed with the DDSCAT
software.</p></li>
</ul>
<p>We also strongly encourage you to send email to
<span><code>draine@astro.princeton.edu</code></span> identifying
yourself as a user of DDSCAT; this will enable the authors to notify you
of any bugs, corrections, or improvements in DDSCAT. Up-to-date
information on DDSCAT and the latest version of <span><strong>DDSCAT
7.3</strong></span> can be found at<br />
<span><code>http://code.google.com/p/ddscat/</code></span><br />
The current version, <span><strong>DDSCAT 7.3</strong></span>, offers
the option of using the DDA formulae from <span class="citation"
data-cites="Draine_1988"></span>, with dipole polarizabilities
determined from the Lattice Dispersion Relation <span class="citation"
data-cites="Draine+Goodman_1993 Gutkowicz-Krusin+Draine_2004"></span>.
Alternatively, <span><strong>DDSCAT 7.3</strong></span> also allows the
user to specify the “filtered coupled dipole” method of <span
class="citation" data-cites="Piller+Martin_1998"></span> and <span
class="citation" data-cites="Gay-Balmaz+Martin_2002"></span>, which may
give better results for targets with “large” refractive indices <span
class="math inline">\(|m-1|\lower.5ex\hbox{$\; \buildrel &gt; \over \sim
\;$}2\)</span>.</p>
<p>The code incorporates Fast Fourier Transform (FFT) methods <span
class="citation" data-cites="Goodman+Draine+Flatau_1990"></span>.
<span><strong>DDSCAT 7.3</strong></span> includes capability to
calculate scattering and absorption by targets that are periodic in one
or two dimensions – arrays of nanostructures, for example. The
theoretical basis for application of the DDA to periodic structures is
developed in <span class="citation"
data-cites="Draine+Flatau_2008a"></span>. <span><strong>DDSCAT
7.3</strong></span> includes capability to efficiently perform
“nearfield” calculations of <span class="math inline">\({\bf E}\)</span>
and <span class="math inline">\({\bf B}\)</span> in and around the
target using FFT methods, as described by <span class="citation"
data-cites="Flatau+Draine_2012"></span>. A new postprocessing code,
<span><strong>DDPOSTPROCESS.f90</strong></span>, is included in the
<span><strong>DDSCAT 7.3</strong></span> distribution.</p>
<p>We refer you to the list of references at the end of this document
for discussions of the theory and accuracy of the DDA [in particular,
reviews by <span class="citation"
data-cites="Draine+Flatau_1994"></span> and <span class="citation"
data-cites="Draine_2000a"></span>, recent extension to 1-d and 2-d
arrays by <span class="citation"
data-cites="Draine+Flatau_2008a"></span>, and comparison of the coupled
dipole method with other DDA methods (including the filtered coupled
dipole method) by <span class="citation"
data-cites="Yurkin+Min+Hoekstra_2010"></span>].</p>
<p>In §<a href="#sec:applicability" data-reference-type="ref"
data-reference="sec:applicability">[sec:applicability]</a> we summarize
the applicability of the DDA, and in §<a href="#sec:DDSCATvers"
data-reference-type="ref"
data-reference="sec:DDSCATvers">[sec:DDSCATvers]</a> we describe what
the current release can calculate.</p>
<p>In §<a href="#sec:whats_new" data-reference-type="ref"
data-reference="sec:whats_new">[sec:whats_new]</a> we describe the
principal changes between <span><strong>DDSCAT 7.3</strong></span> and
the previous releases. The succeeding sections contain instructions
for:</p>
<ul>
<li><p>obtaining the source code (§<a href="#sec:downloading"
data-reference-type="ref"
data-reference="sec:downloading">[sec:downloading]</a>);</p></li>
<li><p>compiling and linking the code (§<a href="#sec:compiling"
data-reference-type="ref"
data-reference="sec:compiling">[sec:compiling]</a>);</p></li>
<li><p>information for Microsoft<sup></sup> Windows users (§<a
href="#sec:windows" data-reference-type="ref"
data-reference="sec:windows">[sec:windows]</a>);</p></li>
<li><p>running a sample calculation (§<a href="#sec:sample calculation"
data-reference-type="ref"
data-reference="sec:sample calculation">[sec:sample
calculation]</a>);</p></li>
<li><p>modifying the parameter file to do your desired calculations (§<a
href="#sec:parameter_file" data-reference-type="ref"
data-reference="sec:parameter_file">[sec:parameter_file]</a>);</p></li>
<li><p>specifying target orientation(s) (§<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>);</p></li>
<li><p>understanding the output from the sample calculation;</p></li>
<li><p>using <span><strong>DDPOSTPROCESS.f90</strong></span> for
postprocessing of solutions found by <span><strong>DDSCAT
7.3</strong></span> (§<a href="#sec:ddpostprocess"
data-reference-type="ref"
data-reference="sec:ddpostprocess">[sec:ddpostprocess]</a>).</p></li>
</ul>
<p>The instructions for compiling, linking, and running will be
appropriate for a Linux system; slight changes will be necessary for
non-Linux sites, but they are quite minor and should present no
difficulty.</p>
<p>Finally, the current version of this User Guide can be obtained from
<span><code>http://arxiv.org/abs/xxxx.xxxx</code></span>.</p>
<p><span><strong>Important Note:</strong></span> <span><strong>DDSCAT
7.3</strong></span> differs in a number of respects from previous
versions of <span><strong>DDSCAT</strong></span>. <span><strong>DDSCAT
7.3</strong></span> includes support for both MPI and OpenMP, but – as
of this writing – <span><strong>DDSCAT 7.3</strong></span> has not yet
been tested with MPI, and there has been only limited testing with
OpenMP. <span><strong>DDSCAT 7.3</strong></span> has been tested
extensively on single-processor systems, but if you are intending to use
<span><strong>DDSCAT 7.3</strong></span> with OpenMP or MPI, please
proceed with caution – do at least a few comparison calculations in
single-cpu mode to verify that the results obtained with OpenMP or MPI
appear to be correct. If you do encounter problems with OpenMP or MPI,
please document them and communicate them to the authors. And if you
find that everything appears to work properly, we’d like to know that
too!</p>
<h1 id="applicability-of-the-dda">Applicability of the DDA<span
id="sec:applicability" label="sec:applicability"></span></h1>
<p>The principal advantage of the DDA is that it is completely flexible
regarding the geometry of the target, being limited only by the need to
use an interdipole separation <span class="math inline">\(d\)</span>
small compared to (1) any structural lengths in the target, and (2) the
wavelength <span class="math inline">\(\lambda\)</span>. Numerical
studies <span class="citation"
data-cites="Draine+Goodman_1993 Draine+Flatau_1994 Draine_2000a"></span>
indicate that the second criterion is adequately satisfied if <span
class="math display">\[|m|kd&lt; 1~~~,
\label{eq:mkd_max}\]</span> where <span class="math inline">\(m\)</span>
is the complex refractive index of the target material, and <span
class="math inline">\(k\equiv2\pi/\lambda\)</span>, where <span
class="math inline">\(\lambda\)</span> is the wavelength <span><em>in
vacuo</em></span>. This criterion is valid provided that <span
class="math inline">\(|m-1| \lower.5ex\hbox{$\; \buildrel &lt; \over
\sim \;$}3\)</span> or so. When Im<span
class="math inline">\((m)\)</span> becomes large, the DDA solution tends
to overestimate the absorption cross section <span
class="math inline">\(C_{\rm abs}\)</span>, and it may be necessary to
use interdipole separations <span class="math inline">\(d\)</span>
smaller than indicated by eq. (<a href="#eq:mkd_max"
data-reference-type="ref" data-reference="eq:mkd_max">[eq:mkd_max]</a>)
to reduce the errors in <span class="math inline">\(C_{\rm abs}\)</span>
to acceptable values.</p>
<p>If accurate calculations of the scattering phase function (e.g.,
radar or lidar cross sections) are desired, a more conservative
criterion <span class="math display">\[|m|kd &lt; 0.5\]</span> will
usually ensure that differential scattering cross sections <span
class="math inline">\(dC_{\rm sca}/d\Omega\)</span> are accurate to
within a few percent of the average differential scattering cross
section <span class="math inline">\(C_{\rm sca}/4\pi\)</span> <span
class="citation" data-cites="Draine_2000a"></span>.</p>
<p>Let <span class="math inline">\(V\)</span> be the actual volume of
solid material in the target.<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> If the target is
represented by an array of <span class="math inline">\(N\)</span>
dipoles, located on a cubic lattice with lattice spacing <span
class="math inline">\(d\)</span>, then <span
class="math display">\[V=Nd^3 ~~~.\]</span> We characterize the size of
the target by the “effective radius” <span class="math display">\[a_{\rm
eff}\equiv(3V/4\pi)^{1/3} ~~~,\]</span> the radius of an equal volume
sphere. A given scattering problem is then characterized by the
dimensionless “size parameter” <span class="math display">\[x\equiv
ka_{\rm eff} = \frac{2\pi a_{\rm eff}}{\lambda} ~~~.\]</span> The size
parameter can be related to <span class="math inline">\(N\)</span> and
<span class="math inline">\(|m|kd\)</span>: <span
class="math display">\[x\equiv{2\pi a_{\rm eff}\over\lambda} =
{62.04\over|m|}\left({N\over10^6}\right)^{1/3} \cdot |m|kd ~~~.\]</span>
Equivalently, the target size can be written <span
class="math display">\[a_{\rm eff} = 9.873
{\lambda\over|m|}\left({N\over10^6}\right)^{1/3}
\cdot |m|kd~~~.\]</span> Practical considerations of CPU speed and
computer memory currently available on scientific workstations typically
limit the number of dipoles employed to <span class="math inline">\(N
&lt; 10^6\)</span> (see §<a href="#sec:memory_requirements"
data-reference-type="ref"
data-reference="sec:memory_requirements">[sec:memory_requirements]</a>
for limitations on <span class="math inline">\(N\)</span> due to
available RAM); for a given <span class="math inline">\(N\)</span>, the
limitations on <span class="math inline">\(|m|kd\)</span> translate into
limitations on the ratio of target size to wavelength.</p>
<p>For calculations of total cross sections <span
class="math inline">\(C_{\rm abs}\)</span> and <span
class="math inline">\(C_{\rm sca}\)</span>, we require <span
class="math inline">\(|m|kd &lt; 1\)</span>: <span
class="math display">\[a_{\rm eff} &lt; 9.88 {\lambda\over
|m|}\left({N\over10^6}\right)^{1/3}
{\rm ~~or~~} x &lt; {62.04\over|m|}\left({N\over10^6}\right)^{1/3}
~~~.\]</span> For scattering phase function calculations, we require
<span class="math inline">\(|m|kd &lt; 0.5\)</span>: <span
class="math display">\[a_{\rm eff} &lt; 4.94 {\lambda\over
|m|}\left({N\over10^6}\right)^{1/3}
{\rm ~~~~or~~~~} x &lt; {31.02\over|m|}\left({N\over10^6}\right)^{1/3}
~~~.\]</span></p>
<p>It is therefore clear that the DDA is not suitable for very large
values of the size parameter <span class="math inline">\(x\)</span>, or
very large values of the refractive index <span
class="math inline">\(m\)</span>. The primary utility of the DDA is for
scattering by dielectric targets with sizes comparable to the
wavelength. As discussed by <span class="citation"
data-cites="Draine+Goodman_1993"></span>, <span class="citation"
data-cites="Draine+Flatau_1994"></span>, and <span class="citation"
data-cites="Draine_2000a"></span>, total cross sections calculated with
the DDA are accurate to a few percent provided <span
class="math inline">\(N&gt;10^4\)</span> dipoles are used, criterion (<a
href="#eq:mkd_max" data-reference-type="ref"
data-reference="eq:mkd_max">[eq:mkd_max]</a>) is satisfied, and the
refractive index is not too large.</p>
<p>For fixed <span class="math inline">\(|m|kd\)</span>, the accuracy of
the approximation degrades with increasing <span
class="math inline">\(|m-1|\)</span>, for reasons having to do with the
surface polarization of the target, as discussed by <span
class="citation" data-cites="Collinge+Draine_2004"></span>. With the
present code, good accuracy can be achieved for <span
class="math inline">\(|m-1| &lt; 2\)</span>.</p>
<div class="center">
<figure>
<img src="f1.png" id="fig:Qm=1.33+0.01i" style="width:8.3cm"
alt=" Scattering and absorption for a sphere with m=1.33+0.01i. The upper panel shows the exact values of Q_{\rm sca} and Q_{\rm abs}, obtained with Mie theory, as functions of x=ka. The middle and lower panels show fractional errors in Q_{\rm sca} and Q_{\rm abs}, obtained using DDSCAT with polarizabilities obtained from the Lattice Dispersion Relation, and labelled by the number N of dipoles in each pseudosphere. After Fig. 1 of ." />
<figcaption aria-hidden="true"> Scattering and absorption for a sphere
with <span class="math inline">\(m=1.33+0.01i\)</span>. The upper panel
shows the exact values of <span class="math inline">\(Q_{\rm
sca}\)</span> and <span class="math inline">\(Q_{\rm abs}\)</span>,
obtained with Mie theory, as functions of <span
class="math inline">\(x=ka\)</span>. The middle and lower panels show
fractional errors in <span class="math inline">\(Q_{\rm sca}\)</span>
and <span class="math inline">\(Q_{\rm abs}\)</span>, obtained using
<span><strong>DDSCAT</strong></span> with polarizabilities obtained from
the Lattice Dispersion Relation, and labelled by the number <span
class="math inline">\(N\)</span> of dipoles in each pseudosphere. After
Fig. 1 of <span class="citation"
data-cites="Draine+Flatau_1994"></span>.</figcaption>
</figure>
</div>
<div class="center">
<figure>
<img src="f2.png" id="fig:Qm=2+i" style="width:8.3cm"
alt=" Same as Fig. , but for m=2+i. After Fig. 2 of . Note: in the upper panel, the labels for Q_{\rm sca,Mie} and Q_{\rm abs,Mie} should be interchanged." />
<figcaption aria-hidden="true"> Same as Fig. , but for <span
class="math inline">\(m=2+i\)</span>. After Fig. 2 of <span
class="citation" data-cites="Draine+Flatau_1994"></span>. Note: in the
upper panel, the labels for <span class="math inline">\(Q_{\rm
sca,Mie}\)</span> and <span class="math inline">\(Q_{\rm
abs,Mie}\)</span> should be interchanged.</figcaption>
</figure>
</div>
<div class="center">
<figure>
<img src="f3.png" id="fig:dQdom=1.33+0.01i" style="width:8.3cm"
alt=" Differential scattering cross section for m=1.33+0.01i pseudosphere and ka=7. Lower panel shows fractional error compared to exact Mie theory result. The N=17904 pseudosphere has |m|kd=0.57, and an rms fractional error in d\sigma/d\Omega of 2.4%. After Fig. 5 of ." />
<figcaption aria-hidden="true"> Differential scattering cross section
for <span class="math inline">\(m=1.33+0.01i\)</span> pseudosphere and
<span class="math inline">\(ka=7\)</span>. Lower panel shows fractional
error compared to exact Mie theory result. The <span
class="math inline">\(N=17904\)</span> pseudosphere has <span
class="math inline">\(|m|kd=0.57\)</span>, and an rms fractional error
in <span class="math inline">\(d\sigma/d\Omega\)</span> of 2.4%. After
Fig. 5 of <span class="citation"
data-cites="Draine+Flatau_1994"></span>.</figcaption>
</figure>
</div>
<div class="center">
<figure>
<img src="f4.png" id="fig:dQdom=2+i" style="width:8.3cm"
alt=" Same as Fig.  but for m=2+i. The N=59728 pseudosphere has |m|kd=0.65, and an rms fractional error in d\sigma/d\Omega of 6.7%. After Fig. 8 of ." />
<figcaption aria-hidden="true"> Same as Fig.  but for <span
class="math inline">\(m=2+i\)</span>. The <span
class="math inline">\(N=59728\)</span> pseudosphere has <span
class="math inline">\(|m|kd=0.65\)</span>, and an rms fractional error
in <span class="math inline">\(d\sigma/d\Omega\)</span> of 6.7%. After
Fig. 8 of <span class="citation"
data-cites="Draine+Flatau_1994"></span>.</figcaption>
</figure>
</div>
<p>Examples illustrating the accuracy of the DDA are shown in Figs. <a
href="#fig:Qm=1.33+0.01i" data-reference-type="ref"
data-reference="fig:Qm=1.33+0.01i">1</a>–<a href="#fig:Qm=2+i"
data-reference-type="ref" data-reference="fig:Qm=2+i">2</a>, which show
overall scattering and absorption efficiencies as a function of
wavelength for different discrete dipole approximations to a sphere,
with <span class="math inline">\(N\)</span> ranging from 304 to 59728.
The DDA calculations assumed radiation incident along the (1,1,1)
direction in the “target frame”. Figs. </p>
<p><a href="#fig:dQdom=1.33+0.01i" data-reference-type="ref"
data-reference="fig:dQdom=1.33+0.01i">3</a>–<a href="#fig:dQdom=2+i"
data-reference-type="ref" data-reference="fig:dQdom=2+i">4</a> show the
scattering properties calculated with the DDA for <span
class="math inline">\(x=ka=7\)</span>. Additional examples can be found
in <span class="citation" data-cites="Draine+Flatau_1994"></span> and
<span class="citation" data-cites="Draine_2000a"></span>.</p>
<p>As discussed below, <span><strong>DDSCAT 7.3</strong></span> can also
calculate scattering and absorption by targets that are periodic in one
or two directions – for examples, see <span class="citation"
data-cites="Draine+Flatau_2008a"></span>.</p>
<h1 id="ddscat-7.3">DDSCAT 7.3<span id="sec:DDSCATvers"
label="sec:DDSCATvers"></span></h1>
<h2 id="what-does-it-calculate"> What Does It Calculate?</h2>
<h3 id="absorption-and-scattering-by-finite-targets">Absorption and
Scattering by Finite Targets</h3>
<p><span><strong>DDSCAT 7.3</strong></span>, like previous versions of
<span><strong>DDSCAT</strong></span>, solves the problem of scattering
and absorption by a finite target, represented by an array of
polarizable point dipoles, interacting with a monochromatic plane wave
incident from infinity. <span><strong>DDSCAT 7.3</strong></span> has the
capability of automatically generating dipole array representations for
a variety of target geometries (see §<a href="#sec:target_generation"
data-reference-type="ref"
data-reference="sec:target_generation">[sec:target_generation]</a>) and
can also accept dipole array representations of targets supplied by the
user (although the dipoles must be located on a cubic lattice). The
incident plane wave can have arbitrary elliptical polarization (see §<a
href="#sec:incident_polarization" data-reference-type="ref"
data-reference="sec:incident_polarization">[sec:incident_polarization]</a>),
and the target can be arbitrarily oriented relative to the incident
radiation (see §<a href="#sec:target_orientation"
data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>).
The following quantities are calculated by <span><strong>DDSCAT
7.3</strong></span> :</p>
<ul>
<li><p>Absorption efficiency factor <span class="math inline">\(Q_{\rm
abs}\equiv C_{\rm abs}/\pi a_{\rm eff}^2\)</span>, where <span
class="math inline">\(C_{\rm abs}\)</span> is the absorption cross
section;</p></li>
<li><p>Scattering efficiency factor <span class="math inline">\(Q_{\rm
sca}\equiv C_{\rm sca}/\pi a_{\rm eff}^2\)</span>, where <span
class="math inline">\(C_{\rm sca}\)</span> is the scattering cross
section;</p></li>
<li><p>Extinction efficiency factor <span class="math inline">\(Q_{\rm
ext}\equiv Q_{\rm sca}+Q_{\rm abs}\)</span>;</p></li>
<li><p>Phase lag efficiency factor <span class="math inline">\(Q_{\rm
pha}\)</span>, defined so that the phase-lag (in radians) of a plane
wave after propagating a distance <span class="math inline">\(L\)</span>
is just <span class="math inline">\(n_{t}Q_{\rm pha}\pi a_{\rm eff}^2
L\)</span>, where <span class="math inline">\(n_t\)</span> is the number
density of targets.</p></li>
<li><p>The 4<span class="math inline">\(\times\)</span>4 Mueller
scattering intensity matrix <span class="math inline">\(S_{ij}\)</span>
describing the complete scattering properties of the target for
scattering directions specified by the user (see §<a
href="#sec:mueller_matrix" data-reference-type="ref"
data-reference="sec:mueller_matrix">[sec:mueller_matrix]</a>).</p></li>
<li><p>Radiation force efficiency vector <span
class="math inline">\({\bf Q}_{\rm rad}\)</span> (see §<a
href="#sec:force and torque calculation" data-reference-type="ref"
data-reference="sec:force and torque calculation">[sec:force and torque
calculation]</a>).</p></li>
<li><p>Radiation torque efficiency vector <span
class="math inline">\({\bf Q}_\Gamma\)</span> (see §<a
href="#sec:force and torque calculation" data-reference-type="ref"
data-reference="sec:force and torque calculation">[sec:force and torque
calculation]</a>).</p></li>
</ul>
<p>In addition, the user can choose to have <span><strong>DDSCAT
7.3</strong></span> store the solution for post-processing.</p>
<h3
id="absorption-and-scattering-by-periodic-arrays-of-finite-structures">
Absorption and Scattering by Periodic Arrays of Finite Structures</h3>
<p><span><strong>DDSCAT 7.3</strong></span> includes the capability to
solve the problem of scattering and absorption by an infinite target
consisting of a 1-d or 2-d periodic array of finite structures,
illuminated by an incident plane wave. The finite structures are
themselves represented by arrays of point dipoles.</p>
<p>The electromagnetic scattering problem for periodic arrays is
formulated by <span class="citation"
data-cites="Draine+Flatau_2008a"></span>, who show how the problem can
be reduced to a finite system of linear equations, and solved by the
same methods used for scattering by finite targets.</p>
<p>The far-field scattering properties of the 1-d and 2-d periodic
arrays can be conveniently represented by a generalization of the
Mueller scattering matrix to the 1-d or 2-d periodic geometry – see
<span class="citation" data-cites="Draine+Flatau_2008a"></span> for
definition of <span
class="math inline">\(S_{ij}^{(1d)}(M,\zeta)\)</span> and <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span>. For targets with 1-d
periodicity, <span><strong>DDSCAT 7.3</strong></span> calculates <span
class="math inline">\(S_{ij}^{(1d)}(M,\zeta)\)</span> for user-specified
<span class="math inline">\(M\)</span> and <span
class="math inline">\(\zeta\)</span>. For targets with 2-d periodicity,
<span><strong>DDSCAT 7.3</strong></span> calculates <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> for both transmission
and reflection, for user-specified <span
class="math inline">\((M,N)\)</span>.</p>
<p>As for finite targets, the user can choose to have
<span><strong>DDSCAT 7.3</strong></span> store the calculated
polarization field for post-processing.</p>
<h2 id="sec:target_in_medium"> Application to Targets in Dielectric
Media</h2>
<p>Let <span class="math inline">\(\omega\)</span> be the angular
frequency of the incident radiation. Beginning with <span><strong>DDSCAT
7.2</strong></span>, <span><strong>DDSCAT</strong></span> facilitates
calculation of absorption and scattering by targets immersed in
dielectric media (e.g., liquid water). In the parameter file
<span><code>ddscat.par</code></span>, the user simply specifies the
refractive index <span class="math inline">\(m_{\rm medium}\)</span> of
the ambient medium. If the target is <span><em>in vacuo</em></span>, set
<span class="math inline">\(m_{\rm medium}=1\)</span>. Otherwise, set
<span class="math inline">\(m_{\rm medium}\)</span> to be the refractive
index in the ambient medium at frequency <span
class="math inline">\(\omega\)</span>. For example, H<span
class="math inline">\(_2\)</span>O has <span
class="math inline">\(m_{\rm medium}=1.335\)</span> near <span
class="math inline">\(\omega/2\pi=6\times10^{14}\,{\rm Hz}\)</span>, the
frequency corresponding to <span class="math inline">\(\lambda_{\rm
vac}=500\,{\rm nm}\)</span> (green light). At this frequency, air at STP
has <span class="math inline">\(m_{\rm medium}=1.00028\)</span>, which
can be taken to be 1 for most applications.</p>
<p>The wavelength provided in the file
<span><code>ddscat.par</code></span> should be the
<span><em>vacuum</em></span> wavelength <span
class="math inline">\(\lambda_{\rm vac}=2\pi c/\omega\)</span>
corresponding to the frequency <span
class="math inline">\(\omega\)</span>.</p>
<p>The dielectric function or refractive index for the target material
is provided via a file, with the filename provided via
<span><code>ddscat.par</code></span>. The file should give either the
actual complex dielectric function <span
class="math inline">\(\epsilon_{\rm target}\)</span> or actual complex
refractive index <span class="math inline">\(m_{\rm
target}=\sqrt{\epsilon_{\rm target}}\)</span> of the target material, as
a function of wavelength <span><em>in vacuo</em></span>.</p>
<p><u>Internal</u> to <span><strong>DDSCAT 7.3</strong></span>, the
scattering calculation is carried out using the
<span><em>relative</em></span> dielectric function <span
class="math display">\[\epsilon_{\rm rel}(\omega) =
\frac{\epsilon_{\rm target}(\omega)}{\epsilon_{\rm medium}(\omega)}
~~~,\]</span> <span><em>relative</em></span> refractive index: <span
class="math display">\[m_{\rm rel}(\omega) =
\frac{m_{\rm target}(\omega)}{m_{\rm medium}(\omega)}~~~,\]</span> and
wavelength in the ambient medium <span
class="math display">\[\lambda_{\rm medium}=\frac{\lambda_{\rm
vac}}{m_{\rm medium}}~~~.
\label{eq:lambda_medium}\]</span></p>
<p>The absorption, scattering, extinction, and phase lag efficiency
factors <span class="math inline">\(Q_{\rm abs}\)</span>, <span
class="math inline">\(Q_{\rm sca}\)</span>, <span
class="math inline">\(Q_{\rm ext}\)</span>, and <span
class="math inline">\(Q_{\rm pha}\)</span> calculated by
<span><strong>DDSCAT</strong></span> will then be equal to the physical
cross sections for absorption, scattering, and extinction divided by
<span class="math inline">\(\pi a_{\rm eff}^2\)</span>. For example, the
attenuation coefficient <span class="math inline">\(\alpha\)</span> for
radiation propagating through a diffuse medium with a number density
<span class="math inline">\(n_{t}\)</span> of scatterers will be just
<span class="math display">\[\alpha = n_{t}Q_{\rm ext}\pi a_{\rm eff}^2
~~~.\]</span> Similarly, the phase lag (in radians) after propagating a
distance <span class="math inline">\(L\)</span> will be <span
class="math inline">\(n_{t}Q_{\rm pha}\pi a_{\rm eff}^2 L\)</span>.</p>
<p>The elements <span class="math inline">\(S_{ij}\)</span> of the
4<span class="math inline">\(\times\)</span>4 Mueller scattering matrix
<span class="math inline">\({\bf S}\)</span> calculated by
<span><strong>DDSCAT</strong></span> for finite targets will be correct
for scattering in the medium: <span class="math display">\[{\bf I}_{\rm
sca}=
\left(\frac{\lambda_{\rm medium}}{2\pi r}\right)^2
{\bf S}\cdot {\bf I}_{\rm in} ,\]</span> where <span
class="math inline">\({\bf I}_{\rm in}\)</span> and <span
class="math inline">\({\bf I}_{\rm sca}\)</span> are the Stokes vectors
for the incident and scattered light (in the medium), <span
class="math inline">\(r\)</span> is the distance from the target, and
<span class="math inline">\(\lambda_{\rm medium}\)</span> is the
wavelength in the medium (eq. <a href="#eq:lambda_medium"
data-reference-type="ref"
data-reference="eq:lambda_medium">[eq:lambda_medium]</a>). See §<a
href="#sec:mueller_matrix" data-reference-type="ref"
data-reference="sec:mueller_matrix">[sec:mueller_matrix]</a> for a
detailed discussion of the Mueller scattering matrix.</p>
<p>The time-averaged radiative force and torque (see §<a
href="#sec:force and torque calculation" data-reference-type="ref"
data-reference="sec:force and torque calculation">[sec:force and torque
calculation]</a>) on a finite target in a dielectric medium are <span
class="math display">\[{\bf F}_{\rm rad} = {\bf Q}_{\rm pr}\pi a_{\rm
eff}^2 u_{\rm rad} ~~~,\]</span> <span class="math display">\[{\bf
\Gamma}_{\rm rad} =
{\bf Q}_\Gamma \pi a_{\rm eff}^2 u_{\rm rad} \frac{\lambda_{\rm
medium}}{2\pi} ~~~,\]</span> where the time-averaged energy density is
<span class="math display">\[u_{\rm rad}=\epsilon_{\rm medium}
\frac{|E_0|^2}{8\pi} ~~~ ,\]</span> where <span
class="math inline">\(E_0\cos(\omega t+\phi)\)</span> is the electric
field of the incident plane wave in the medium.</p>
<p>The relationship between the microscopic and macroscopic fields <span
class="math inline">\({\bf E}_{\rm micro}\)</span> and <span
class="math inline">\({\bf E}_{\rm macro}\)</span> is discussed in §<a
href="#sec:micro_vs_macro" data-reference-type="ref"
data-reference="sec:micro_vs_macro">[sec:micro_vs_macro]</a> (see eq. <a
href="#eq:macro_vs_micro" data-reference-type="ref"
data-reference="eq:macro_vs_micro">[eq:macro_vs_micro]</a>).</p>
<h1 id="whats-new">What’s New?<span id="sec:whats_new"
label="sec:whats_new"></span></h1>
<p><span><strong>DDSCAT 7.3</strong></span> differs from
<span><strong>DDSCAT 7.1</strong></span> in several ways, including:</p>
<ol>
<li><p>N.B.: The structure of the parameter file
<span><code>ddscat.par</code></span> has again been changed:
<span><code>ddscat.par</code></span> files that were used with
<span><strong>DDSCAT 7.1</strong></span> or <span><strong>DDSCAT
7.2</strong></span> will need to be modified. See §<a
href="#sec:parameter_file" data-reference-type="ref"
data-reference="sec:parameter_file">[sec:parameter_file]</a> and
Appendix <a href="#app:ddscat.par" data-reference-type="ref"
data-reference="app:ddscat.par">[app:ddscat.par]</a>.</p></li>
<li><p>As in <span><strong>DDSCAT 7.2</strong></span>,
<span><strong>DDSCAT 7.3</strong></span> requires the user to specify
the (real) refractive index <span class="math inline">\(m_{\rm
ambient}\)</span> of the ambient medium. See §<a
href="#sec:parameter_file" data-reference-type="ref"
data-reference="sec:parameter_file">[sec:parameter_file]</a>.</p></li>
<li><p>As with <span><strong>DDSCAT 7.2</strong></span>,
<span><strong>DDSCAT 7.3</strong></span> includes support for two
additional conjugate gradient solvers (see §<a
href="#sec:choice_of_algorithm" data-reference-type="ref"
data-reference="sec:choice_of_algorithm">[sec:choice_of_algorithm]</a>):</p>
<ul>
<li><p>GPBICG – Implementation by Chamuet and Rahmani of the Complex
Conjugate Gradient solver presented by <span class="citation"
data-cites="Tang+Shen+Zheng+Qiu_2004"></span>.</p></li>
<li><p>QMRCCG – Quasi-Minimum-Residual Complex Conjugate Gradient
solver, adapted from fortran-90 implementation kindly made available by
P.C. Chaumet and A. Rahmani <span class="citation"
data-cites="Chaumet+Rahmani_2009"></span>.</p></li>
</ul></li>
<li><p>As with <span><strong>DDSCAT 7.2</strong></span>,
<span><strong>DDSCAT 7.3</strong></span> requires the user to specify
the maximum allowed number of iterations (this was previously
hard-wired).</p></li>
<li><p>As with <span><strong>DDSCAT 7.2</strong></span>,
<span><strong>DDSCAT 7.3</strong></span> supports fast calculations of
the electric field within and near the target using FFT methods, as
described by <span class="citation"
data-cites="Flatau+Draine_2012"></span>; see §<a href="#sec:nearfield"
data-reference-type="ref"
data-reference="sec:nearfield">[sec:nearfield]</a>). The program DDFIELD
that came with <span><strong>DDSCAT 7.1</strong></span> is no longer
needed (and no longer supported).</p></li>
<li><p><span><strong>DDSCAT 7.3</strong></span> now includes the option
of fast calculations of <span class="math inline">\({\bf B}\)</span> in
and near the target using FFT methods (see §<a href="#sec:nearfield"
data-reference-type="ref"
data-reference="sec:nearfield">[sec:nearfield]</a>).</p></li>
<li><p>As with <span><strong>DDSCAT 7.2</strong></span>, the
<span><strong>DDSCAT 7.3</strong></span> distribution includes a set of
“example” calculations, but a new example has been added:</p>
<ul>
<li><p><span><strong>FROM_FILE</strong></span>: target whose geometry is
supplied via an ascii file</p></li>
<li><p><span><strong>ELLIPSOID</strong></span>: sphere, with nearfield
calculation of <span class="math inline">\({\bf E}\)</span> in and
around the sphere.</p></li>
<li><p><span><strong>RCTGLPRSM</strong></span>: rectangular
brick</p></li>
<li><p><span><strong>SPH_ANI_N</strong></span>: cluster of spheres, each
characterized by an anisotropic dielectric function</p></li>
<li><p><span><strong>CYLNDRPBC</strong></span>: infinite cylinder,
calculated as a periodic array of disks.</p></li>
<li><p><span><strong>DSKRCTPBC</strong></span>: doubly-periodic array of
Au disks supported by a Si<span class="math inline">\(_3\)</span>N<span
class="math inline">\(_4\)</span> slab.</p></li>
<li><p><span><strong>RCTGL_PBC</strong></span>: doubly-periodic array of
rectangular blocks.</p></li>
<li><p><span><strong>RCTGL_PBC</strong></span>: doubly-periodic array of
rectangular blocks, with nearfield calculation of <span
class="math inline">\({\bf E}\)</span> in and around the
sphere.</p></li>
<li><p><span><strong>SPHRN_PBC</strong></span>: doubly-periodic array of
clusters of spheres.</p></li>
<li><p><span><strong>ELLIPSOID_NEARFIELD</strong></span>: same
calculation as in the <span><strong>ELLIPSOID</strong></span> example,
followed by a nearfield calculation of <span class="math inline">\({\bf
E}\)</span> in and around the sphere, followed by evaluation of <span
class="math inline">\({\bf E}\)</span> along a track passing through the
sphere, plus creation of “VTK” files for visualization.</p></li>
<li><p><span><strong>RCTGLPRSM_NEARFIELD</strong></span>: same
calculation as in the <span><strong>RCTGLPRSM</strong></span> example,
followed by a nearfield calculation of <span class="math inline">\({\bf
E}\)</span> in and around the target, followed by evaluation of <span
class="math inline">\({\bf E}\)</span> along a track passing through the
prism, plus creation of “VTK” files for visualization.</p></li>
<li><p><span><strong>RCTGL_PBC_NEARFIELD</strong></span>: same
calculation as in the <span><strong>RCTGL_PBC</strong></span> example,
followed by a nearfield calculation of <span class="math inline">\({\bf
E}\)</span> in and around the target, followed by evaluation of <span
class="math inline">\({\bf E}\)</span> along a track passing through the
prism, plus creation of “VTK” files for visualization.</p></li>
<li><p><span><strong>RCTGL_PBC_NEARFLD_B</strong></span>: same
calculation as in the <span><strong>RCTGL_PBC_NARFIELD</strong></span>
example, followed by evaluation of both <span class="math inline">\({\bf
E}\)</span> and <span class="math inline">\({\bf B}\)</span> along a
track passing through the prism, plus creation of “VTK” files for
visualization.</p></li>
</ul></li>
<li><p><span><strong>DDSCAT 7.3</strong></span> is distributed with a
program <span><strong>VTRCONVERT.f90</strong></span> that supports
visualization of target geometries using the Visualization Toolkit
(VTK), an open-source, freely-available software system for 3D computer
graphics (http://www.vtk.org) and, specifically, ParaView
(http://paraview.org).</p></li>
<li><p><span><strong>DDSCAT 7.3</strong></span> is distributed with a
program <span><strong>DDPOSTPROCESS.f90</strong></span>.</p>
<ul>
<li><p><span><strong>DDPOSTPROCESS.f90</strong></span> allows the user
to easily extract <span class="math inline">\({\bf E}\)</span> (and
<span class="math inline">\({\bf B}\)</span> if it was also
precalculated) at points along a line.</p></li>
<li><p>If <span class="math inline">\({\bf B}\)</span> was
precalculated, <span><strong>DDPOSTPROCESS.f90</strong></span>
calculates the time-averaged Poynting vector <span
class="math inline">\(c\langle{\bf E}\times{\bf H}\rangle/4\pi\)</span>
at each point in the computational volume.</p></li>
<li><p><span><strong>DDPOSTPROCESS.f90</strong></span> creates “VTK”
files for visualization of <span class="math inline">\(|{\bf
E}|\)</span>, <span class="math inline">\(|{\bf E}|^2\)</span>, or <span
class="math inline">\((c/4\pi)\langle{\bf E}\times{\bf
H}\rangle\)</span> using the VTK tools.</p></li>
</ul></li>
</ol>
<h1
id="downloading-the-source-code-and-example-calculations">Downloading
the Source Code and Example Calculations <span id="sec:downloading"
label="sec:downloading"></span></h1>
<p><span><strong>DDSCAT 7.3</strong></span> is written in standard
Fortran-90 with a single extension: it uses the Fortran-95 standard
library call <span><code>CPU_TIME</code></span> to obtain timing
information. <span><strong>DDSCAT 7.3</strong></span> is therefore
portable to any system having a f90 or f95 compiler. It has been
successfully compiled with many different compilers, including
<span><code>gfortran</code></span>, <span><code>g95</code></span>,
<span><code>ifort</code></span>, <span><code>pgf77</code></span>, and
NAG<sup></sup><span><code>f95</code></span>.</p>
<p>It is possible to use <span><strong>DDSCAT 7.3</strong></span> on PCs
running Microsoft<sup></sup> Windows operating systems, including Vista
and Windows 7. Section <a href="#sec:windows" data-reference-type="ref"
data-reference="sec:windows">[sec:windows]</a> provides instructions for
creating a unix-like environment in which you can compile and run
<span><strong>DDSCAT 7.3</strong></span>.</p>
<p>Alternatively, you may be able to obtain a precompiled native
executable – see §<a href="#sec:native executable"
data-reference-type="ref"
data-reference="sec:native executable">[sec:native executable]</a>. More
information on how to do this can be found at<br />
<span><code>http://code.google.com/p/ddscat</code></span></p>
<p>The remainder of this section will assume that the installation is
taking place on a Unix, Linux or Mac OSX system with the standard
developer tools (e.g., <span><code>tar</code></span>,
<span><code>make</code></span>, and a f90 or f95 compiler)
installed.</p>
<p>The complete source code for <span><strong>DDSCAT
7.3</strong></span> is provided in a single gzipped tarfile. To obtain
the source code, simply point your browser to
<span><code>http://code.google.com/p/ddscat/</code></span> and download
the latest release.</p>
<p>After downloading <span><code>ddscat7.3.0.tgz</code></span> into the
directory where you would like <span><strong>DDSCAT
7.3</strong></span> to reside (you should have at least 10 Mbytes of
disk space available), the source code can be installed as follows:</p>
<p>If you are on a Linux system, you should be able to type<br />
<br />
which will“extract” the files from the gzipped tarfile. If your version
of “tar” doesn’t support the “z” option, then try<br />
<br />
If neither of the above work on your system, try the two-stage
procedure<br />
<br />
<br />
The only disadvantage of the two-stage procedure is that it uses more
disk space, since after the second step you will have the uncompressed
tarfile <span><code>ddscat7.3.0.tar</code></span> – about 3.8 Mbytes –
in addition to all the files you have extracted from the tarfile –
another 4.6 Mbytes.</p>
<p>Any of the above approaches should create subdirectories
<span><code>src</code></span>, <span><code>doc</code></span>,
<span><code>diel</code></span>, and
<span><code>examples_exp</code></span>.</p>
<ul>
<li><p><span><code>src</code></span> contains the source code.</p></li>
<li><p><span><code>doc</code></span> contains documentation (including
this UserGuide).</p></li>
<li><p><span><code>diel</code></span> contains a few sample files
specifying refractive indices or dielectric functions as functions of
vacuum wavelength.</p></li>
</ul>
<p>It is also recommended that you download
<span><code>ddscat7.3.0_examples.tgz</code></span>, followed by<br />
<br />
Subdirectory <span><code>examples_exp</code></span> contains sample
<span><code>ddscat.par</code></span> files as well as output files for
various example problems, including both isolated targets and infinite
periodic targets. It also includes sample
<span><code>ddpostprocess.par</code></span> files for running
<span><strong>ddpostprocess</strong></span> to support visualization
following nearfield calculations.</p>
<h1 id="compiling-and-linking-on-unixlinux-systems">Compiling and
Linking on Unix/Linux Systems<span id="sec:compiling"
label="sec:compiling"></span></h1>
<p>In the discussion below, it is assumed that the <span><strong>DDSCAT
7.3</strong></span> source code has been installed in a directory
<span><code>DDA/src</code></span>. The instructions below assume that
you are on a Unix, Linux, or Mac OSX system.</p>
<h2 id="the-default-makefile"><span id="sec:Makefile"
label="sec:Makefile"></span> The default Makefile</h2>
<p>It is assumed that the system has the following already
installed:</p>
<ul>
<li><p>a Fortran-90 compiler (e.g., <span><code>gfortran</code></span>,
<span><code>g95</code></span>,
Intel<sup></sup> <span><code>ifort</code></span>, or
NAG<sup></sup><span><code>f95</code></span>) .</p></li>
<li><p><span><code>cpp</code></span> – the “C preprocessor”.</p></li>
</ul>
<p>There are a number of different ways to create an executable,
depending on what options the user wants:</p>
<ul>
<li><p>what compiler and compiler flags?</p></li>
<li><p>single- or double-precision?</p></li>
<li><p>enable OpenMP?</p></li>
<li><p>enable MKL?</p></li>
<li><p>enable MPI?</p></li>
</ul>
<p>Each of the above choices needs requires setting of appropriate
“flags” in the Makefile.</p>
<p>The default Makefile has the following “vanilla” settings:</p>
<ul>
<li><p><span><code>gfortran -O2</code></span></p></li>
<li><p>single-precision arithmetic</p></li>
<li><p>OpenMP not used</p></li>
<li><p>MKL not used</p></li>
<li><p>MPI not used.</p></li>
</ul>
<p>To compile the code with the default settings, simply position
yourself in the directory <span><code>DDA/src</code></span>, and
type<br />
<span><code>make ddscat</code></span><br />
If you have <span><code>gfortran</code></span> and
<span><code>cpp</code></span> installed on your system, the above should
work. You will get some warnings from the compiler, but the code will
compile and create an executable <span><code>ddscat</code></span>.</p>
<p>If you wish to use a different compiler (or compiler options) you
will need to edit the file <span><code>Makefile</code></span> to change
the choice of compiler (variable <span><code>FC</code></span>),
compilation options (variable <span><code>FFLAGS</code></span>), and
possibly and loader options (variable
<span><code>LDFLAGS</code></span>). The file
<span><code>Makefile</code></span> as provided includes examples for
compilers other than <span><code>gfortran</code></span>; you may be able
to simply “comment out” the section of
<span><code>Makefile</code></span> that was designed for
<span><code>gfortran</code></span>, and “uncomment” a section designed
for another compiler (e.g.,
Intel<sup></sup> <span><code>ifort</code></span>).</p>
<h2 id="optimization"> Optimization</h2>
<p>The performance of <span><strong>DDSCAT 7.3</strong></span> will
benefit from optimization during compilation and the user should enable
the appropriate compiler flags.</p>
<h2 id="single-vs.-double-precision"> Single vs. Double Precision</h2>
<p><span><strong>DDSCAT 7.3</strong></span> is written to allow the user
to easily generate either single- or double-precision versions of the
executable. For most purposes, the single-precision precision version of
<span><strong>DDSCAT 7.3</strong></span> should work fine, but if you
encounter a scattering problem where the single-precision version of
<span><strong>DDSCAT 7.3</strong></span> seems to be having trouble
converging to a solution, you may wish to try using the double-precision
version – this can be beneficial in the event that round-off error is
compromising the performance of the conjugate-gradient solver. Of
course, the double precision version will demand about twice as much
memory as the single-precision version, and will take somewhat longer
per iteration.</p>
<p>The only change required is in the Makefile: for single-precision,
set<br />
<span><code>PRECISION = sp</code></span><br />
or for double-precision, set<br />
<span><code>PRECISION = dp</code></span><br />
After changing the <span><code>PRECISION</code></span> variable in the
Makefile (either sp <span class="math inline">\(\rightarrow\)</span> dp,
or dp <span class="math inline">\(\rightarrow\)</span> sp), it is
necessary to recompile the entire code. Simply type<br />
<span><code>make clean</code></span><br />
<span><code>make ddscat</code></span><br />
to create <span><code>ddscat</code></span> with the appropriate
precision.</p>
<h2 id="openmp"> OpenMP</h2>
<p>OpenMP is a standard for support of shared-memory parallel
programming, and can provide a performance advantage when using
<span><strong>DDSCAT 7.3</strong></span> on platforms with multiple cpus
or multiple cores. OpenMP is supported by many common compilers, such as
<span><code>gfortran</code></span> and
Intel<sup></sup> <span><code>ifort</code></span>.</p>
<p>If you are using a multi-cpu (or multi-core) system with OpenMP
(<span><code>www.openmp.org</code></span>) installed, you can compile
<span><strong>DDSCAT 7.3</strong></span> with OpenMP directives to
parallelize some of the calculations. To do so, simply change<br />
<span><code>DOMP =</code></span><br />
<span><code>OPENMP =</code></span><br />
to<br />
<span><code>DOMP = -Dopenmp</code></span><br />
<span><code>OPENMP = -openmp</code></span><br />
Note: <span><code>OPENMP</code></span> is compiler-dependent:
<span><code>gfortran</code></span>, for instance, requires<br />
<span><code>OPENMP = -fopenmp</code></span><br />
After compiling <span><strong>DDSCAT 7.3</strong></span> to use OpenMP,
it is necessary to specify the number of threads to be used. To specify
the number of threads, you need to set the environmental variable
<span><code>OMP_NUM_THREADS</code></span>. This is done by a command in
the shell (e.g., bash or ksh). For example, the number of threads would
be set to two by the command<br />
<span><code>export OMP_NUM_THREADS=2</code></span><br />
The number of threads should not exceed the number of available “cores”.
If you are executing <span><strong>DDSCAT 7.3</strong></span> on a
multi-core system, you may wish to experiment to see how the execution
“wall-clock time” varies depending on the number of threads.</p>
<h2 id="mkl-the-intel-math-kernel-library"> MKL: the
Intel<sup></sup> Math Kernel Library <span id="sec:MKL"
label="sec:MKL"></span> </h2>
<p>Intel<sup></sup> offers the Math Kernel Library (MKL) with the ifort
compiler. This library includes <span><code>DFTI</code></span> for
computing FFTs. At least on some systems, <span><code>DFTI</code></span>
offers better performance than the GPFA package.</p>
<p>To use the MKL library routine <span><code>DFTI</code></span>:</p>
<ul>
<li><p>You must have MKL installed on your system.</p></li>
<li><p>You must obtain the routine
<span><code>mkl_dfti.f90</code></span> and place a copy in the directory
where you are compiling <span><strong>DDSCAT 7.3</strong></span>.
<span><code>mkl_dfti.f90</code></span> is Intel<sup></sup> proprietary
software, so we cannot distribute it with the <span><strong>DDSCAT
7.3</strong></span> source code, but it should be available on any
system with a license for the Intel<sup></sup> MKL library. If you
cannot find it, ask your system administrator.</p></li>
<li><p>Edit the Makefile: define variables
<span><code>CXFFTMKL.f</code></span> and
<span><code>CXFFTMKL.o</code></span> to:<br />
<span><code>CXFFTMKL.f = $(MKL_f)</code></span><br />
<span><code>CXFFTMKL.f = $(MKL_o)</code></span></p></li>
<li><p>Successful linking will require that the appropriate MKL
libraries be available, and that the string
<span><code>LFLAGS</code></span> in the Makefile be defined so as to
include these libraries. Unfortunately, there is a lot of variation in
how the MKL libraries are installed on different systems.<br />
<span><code>-lmkl_intel_thread -lmkl_core -lguide -lpthread -lmkl_intel_lp64</code></span><br />
appears to work on at least one installation. On some
installations,<br />
<span><code>-lmkl_em64t -lmkl_intel_thread -lmkl_core -lguide -lpthread -lmkl_intel_lp64</code></span><br />
seems to work. The Makefile contains examples. You may want to consult a
guru who is familiar with the libraries on your local system.
Intel<sup></sup> provides a website<br />
http://software.intel.com/sites/products/mkl/<br />
that can assist you in figuring out the appropriate compiler and linker
options for your system.</p></li>
<li><p>type<br />
<span><code>make clean</code></span><br />
<span><code>make ddscat</code></span></p></li>
<li><p>The parameter file <span><code>ddscat.par</code></span> should
have <span><code>FFTMKL</code></span> as the value of
<span><code>CMETHD</code></span>.</p></li>
</ul>
<h2 id="mpi-message-passing-interface"> MPI: Message Passing Interface
<span id="sec:MPI" label="sec:MPI"></span> </h2>
<p><span><strong>DDSCAT 7.3</strong></span> includes support for
parallelization under MPI. MPI (Message Passing Interface) is a standard
for communication between processes. More than one implementation of
<span><code>MPI</code></span> exists (e.g.,
<span><code>mpich</code></span> and <span><code>openmpi</code></span>).
<span><code>MPI</code></span> support within <span><strong>DDSCAT
7.3</strong></span> is compliant with the MPI-1.2 and MPI-2 standards<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>, and should be usable under any
implementation of <span><code>MPI</code></span> that is compatible with
those standards.</p>
<p>Many scattering calculations will require multiple orientations of
the target relative to the incident radiation. For <span><strong>DDSCAT
7.3</strong></span>, such calculations are “embarassingly parallel”,
because they are carried out essentially independently.
<span><strong>DDSCAT 7.3</strong></span> uses MPI so that scattering
calculations at a single wavelength but for multiple orientations can be
carried out in parallel, with the information for different orientations
gathered together for averaging etc. by the master process.</p>
<p>If you intend to use <span><strong>DDSCAT 7.3</strong></span> for
only a single orientation, MPI offers no advantage for
<span><strong>DDSCAT 7.3</strong></span>  so you should compile with MPI
disabled. However, if you intend to carry out calculations for multiple
orientations, <span><em>and</em></span> would like to do so in parallel
over more than one cpu, <span><em>and</em></span> you have MPI installed
on your platform, then you will want to compile <span><strong>DDSCAT
7.3</strong></span> with MPI enabled.</p>
<p>To compile with MPI disabled: in the Makefile, set<br />
<span><code>DMPI =</code></span><br />
<span><code>MIP.f = mpi_fake.f90</code></span><br />
<span><code>MPI.o = mpi_fake.o</code></span><br />
To compile with MPI enabled: in the Makefile, set<br />
<span><code>DMPI = -Dmpi</code></span><br />
<span><code>MIP.f = $(MPI_f)</code></span><br />
<span><code>MPI.o = $(MPI_o)</code></span><br />
and edit <span><code>LFLAGS</code></span> as needed to make sure that
you link to the appropriate MPI library (if in doubt, consult your
systems administrator). The <span><code>Makefile</code></span> in the
distribution includes some examples, but library names and locations are
often system-dependent. Please do <span><em>not</em></span> direct
questions regarding <span><code>LFLAGS</code></span> to the authors –
ask your sys-admin or other experts familiar with your installation.</p>
<p>Note that the MPI-capable executable can also be used for ordinary
serial calculations using a single cpu.</p>
<h2 id="device-numbers-idvout-and-idverr"> Device Numbers
<span><code>IDVOUT</code></span> and <span><code>IDVERR</code></span>
<span id="subsec:IDVOUT" label="subsec:IDVOUT"></span></h2>
<p>So far as we know, there are only one operating-system-dependent
aspect of <span><strong>DDSCAT 7.3</strong></span>: the device number to
use for “standard output".</p>
<p>The variables <span><code>IDVOUT</code></span> and
<span><code>IDVERR</code></span> specify device numbers for “running
output" and “error messages", respectively. Normally these would both be
set to the device number for “standard output" (e.g., writing to the
screen if running interactively). Variables
<span><code>IDVERR</code></span> are set by
<span><code>DATA</code></span> statements in the “main" program
<span><code>DDSCAT.f90</code></span> and in the output routine
<span><code>WRIMSG</code></span> (file
<span><code>wrimsg.f90</code></span>). The executable statement
<span><code>IDVOUT=0</code></span> initializes
<span><code>IDVOUT</code></span> to 0. In the as-distributed version of
<span><code>DDSCAT.f90</code></span>, the statement</p>
<p><span><code>OPEN(UNIT=IDVOUT,FILE=CFLLOG)</code></span></p>
<p>causes the output to <span><code>UNIT=IDVOUT</code></span> to be
buffered and written to the file
<span><code>ddscat.log_nnn</code></span>, where
<span><code>nnn=000</code></span> for the first cpu, 001 for the second
cpu, etc. If it is desirable to have this output unbuffered for
debugging purposes, (so that the output will contain up-to-the-moment
information) simply comment out this <span><code>OPEN</code></span>
statement.</p>
<h1 id="information-for-windows-users"><span id="sec:windows"
label="sec:windows"></span> Information for Windows Users</h1>
<p>There are several options to run DDSCAT on
Microsoft<sup></sup> Windows. One can purchase a Fortran compiler such
as the Intel<sup></sup> ifort compiler<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>
(http://software.intel.com/en-us/fortran-compilers/), or the Portland
Group PGF compiler (http://www.pgroup.com/). However, these are not
free. Below we discuss four methods which give access to DDSCAT on
Microsoft<sup></sup> Windows using Open Source applications. We have
tested each of these four methods. We also remark on using the
commercial Intel<sup></sup> ifort compiler under Windows.</p>
<div class="center">
<div id="tab:DDSCAT_on_windows">
<table>
<caption>DDSCAT on Microsoft<sup></sup> Windows Platforms</caption>
<thead>
<tr class="header">
<th style="text-align: center;">Method</th>
<th style="text-align: center;">Compiler</th>
<th style="text-align: center;">Advantage</th>
<th style="text-align: center;">Problems</th>
<th style="text-align: center;">Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Native</td>
<td style="text-align: center;">gfortran</td>
<td style="text-align: center;">pre-compiled</td>
<td style="text-align: center;">limiting options</td>
<td style="text-align: center;">simplest</td>
</tr>
<tr class="even">
<td style="text-align: center;">MINGW</td>
<td style="text-align: center;">gfortran</td>
<td style="text-align: center;">compile with user options</td>
<td style="text-align: center;">compilation step</td>
<td style="text-align: center;">simple</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Cygwin</td>
<td style="text-align: center;">gfortran,G95</td>
<td style="text-align: center;">compile with user options</td>
<td style="text-align: center;">compilation step</td>
<td style="text-align: center;">simple</td>
</tr>
<tr class="even">
<td style="text-align: center;">Virtualbox/UBUNTU</td>
<td style="text-align: center;">gfortran, G95, intel</td>
<td style="text-align: center;">full LINUX access</td>
<td style="text-align: center;">learning curve</td>
<td style="text-align: center;">difficult</td>
</tr>
</tbody>
</table>
</div>
</div>
<h2 id="native-executable"><span id="sec:native executable"
label="sec:native executable"></span> Native executable</h2>
<p>We provide (on
<span><code>http://code.google.com/p/ddscat/</code></span>) a
self-extracting executable which includes a pre-compiled, ready-to-run,
DDSCAT executable for Microsoft<sup></sup> Windows. The advantage is
that the user avoids the possibly difficult compilation step, and has
immediate access to DDSCAT.</p>
<p>Beginning with release 7.2 we package the Windows distribution using
“Inno Setup5” (http://www.jrsoftware.org) which is a free installer for
Windows programs. This will install a Windows native executable
<span><code>ddscat.exe</code></span> as well as source code,
documentation, and relevant test examples. This is by far the the
simplest way to get DDSCAT running on a Windows system. However, we
provide only single precision version without optimization.</p>
<p>Thus, serious DDSCAT users may, at some stage, need to recompile the
code as outlined below. The executable should be executed using the
windows “<span><code>cmd</code></span>” command which opens a separate
shell window. One then has to change directory to where DDSCAT is
placed, and execute DDSCAT invoking</p>
<p>ddscat.exe</p>
<h2 id="compilation-using-mingw">Compilation using MINGW</h2>
<p>The executable file discussed in “native executable” section was
compiled using “gfortran” in the MINGW environment
(http://www.mingw.org/). Microsoft<sup></sup> Windows users may choose
to recompile code using MINGW. MINGW and MSYS provide several tools
crucial for compilation of DDSCAT to a native windows executable. MinGW
(Minimalist GNU for Windows) is a minimalist development environment for
native Microsoft<sup></sup> Windows applications. It provides a complete
Open Source programming tool set which is suitable for the development
of native MS-Windows applications, and which do not depend on any
3rd-party libraries.</p>
<p>MSYS (Minimal SYStem), is a Bourne Shell command line interpreter
system. Offered as an alternative to Window’s cmd.exe, this provides a
general purpose command line environment, which is particularly suited
to use with MinGW, for porting applications to the MS-Windows platform.
We suggest using the installer <span><code>mingw-get-inst</code></span>
(for example <span><code>mingw-get-inst-20111118.exe</code></span>)
which is a simple Graphical User Interface installer that installs MinGW
and MSYS. During the GUI phase of the installation select the default
options, but from the following list you need to select Fortran
Compiler, MSYS Basic System and MinGW Developer ToolKit:</p>
<ol>
<li><p>MinGW Compiler Suite C Compiler optional</p></li>
<li><p>C++ Compiler</p></li>
<li><p><span><strong>optional Fortran Compiler</strong></span></p></li>
<li><p>optional ObjC Compiler</p></li>
<li><p><span><strong>optional MSYS Basic System</strong></span></p></li>
<li><p><span><strong>optional MinGW Developer
Toolkit</strong></span></p></li>
</ol>
<p>You will have to add PATH to bin directories as described in the
MINGW.</p>
<p>Once you have MINGW and MSYS installed, in “all programs” there is
now the MinGW program “MinGW shell”. Once you open this shell one can
now compile Fortran code using “gfortran”. The “make” and “tar”
utilities are available. The command “pwd” shows which directory
corresponds to the initial “MinGW” shell. For example it can be
“/home/Piotr” which corresponds to windows directory
“c:\mingw\msys\1.0\home\piotr”.</p>
<p>You now need to copy ddscat.tar files and untar them. To make a
native executable, edit “Makefile” so that the “LFLAGS” string is
defined to be</p>
<div class="list">
<p><span> </span></p>
<p>-static-libgfortran</p>
</div>
<p>and then execute “make all”. The resulting
<span><code>ddscat.exe</code></span> doesn’t require any non-windows
libraries. This can be checked with the</p>
<p>-x ddscat.exe | grep “DLL”<br />
command.</p>
<h2 id="compilation-using-cygwin">Compilation using CYGWIN</h2>
<p>Another option is provided by “CYGWIN”, an easily installable
UNIX-like emulation package. It is available from http://www.cygwin.com/
. It installs authomatically. However, during installation one has to
specify installation of several packages incuding the f95 compiler
<span><strong>gfortran</strong></span>, the
<span><strong>make</strong></span> utility, the
<span><strong>tar</strong></span> utility, and
<span><strong>nano</strong></span>. Once installed, you will be able to
open the CYGWIN shell and make DDSCAT using the standard Linux commands
as discussed in this manual (see §<a href="#sec:compiling"
data-reference-type="ref"
data-reference="sec:compiling">[sec:compiling]</a>).</p>
<h2 id="ubuntu-and-virtualbox">UBUNTU and Virtualbox</h2>
<p>By far the most comprehensive solution to running DDSCAT on windows
is to install UBUNTU Linux under Oracle Virtualbox. First install Oracle
Virtualbox (from https://www.virtualbox.org/) and then install UBUNTU
Linux (from http://www.ubuntu.com/). You will be able to run a full
LINUX environment on your Windows computer You can add (using “synaptic
file manager”) gfortran and many other packages including graphics. Once
a f90 or f95 compiler has been installed, you can compile
<span><strong>DDSCAT</strong></span> as described in §<a
href="#sec:compiling" data-reference-type="ref"
data-reference="sec:compiling">[sec:compiling]</a>.</p>
<h2 id="compilation-in-windows">Compilation in Windows</h2>
<p>In addition to public domain options (gfortran) for compilation of
<span><strong>DDSCAT 7.3</strong></span> of under Linux environments
running under Windows, we have also tested direct Windows compilation of
DDSCAT with Intel<sup></sup> Fortran Composer XE2013 (in the USA
Educational price was $399). We used the “command prompt” option (IFORT)
to compile the code. We were able to compile the code with the standard
Makefile provided in the DDSCAT distribution. We were able to compile
the code with OpenMP and MKL options as well.</p>
<p>For the MKL option using IFORT one has to specify links to libraries
using interface defined at http://software.intel.com/sites/products/mkl/
For example, the appropriate line in the Makefile may need to look
like<br />
LFLAGS= mkl_intel_c_dll.lib mkl_sequential_dll.lib
mkl_core_dll.lib<br />
Subroutine mkl_dfti.f90 is available with INTEL fortran in the
subdirectory program files (x86)/intel/composer
xe/mkl/include/mkl_dfti.f90</p>
<h1 id="a-sample-calculation-rctglprsm">A Sample Calculation:
<span><code>RCTGLPRSM</code></span> <span id="sec:sample calculation"
label="sec:sample calculation"></span></h1>
<p>When the tarfile is unpacked, it will create four directories:
<span><code>src</code></span>, <span><code>doc</code></span>,
<span><code>diel</code></span>, and
<span><code>examples_exp</code></span>. The
<span><code>examples_exp</code></span> directory has a number of
subdirectories, each with files for a sample calculation. Here we focus
on the files in the subdirectory <span><code>RCTGLPRSM</code></span>. To
follow this, go to the <span><code>DDA</code></span> directory (the
directory in which you unpacked the tarfile) and</p>
<p>to enter the <span><code>examples_exp</code></span> directory,
and</p>
<p>to enter the <span><code>RCTGLPRSM</code></span> directory.</p>
<h1 id="the-parameter-file-ddscat.par">The Parameter File
<span><code>ddscat.par</code></span> <span id="sec:parameter_file"
label="sec:parameter_file"></span></h1>
<p>It is assumed that you are positioned in the
<span><code>examples_exp/RCTGLPRSM</code></span>. directory, as per §<a
href="#sec:sample calculation" data-reference-type="ref"
data-reference="sec:sample calculation">[sec:sample calculation]</a>.
The file <span><code>ddscat.par</code></span> (see also Appendix <a
href="#app:ddscat.par" data-reference-type="ref"
data-reference="app:ddscat.par">[app:ddscat.par]</a>) provides
parameters to the program <span><code>ddscat</code></span>: for example,
<span><code>examples_exp/RCTGLPRSM/ddscat.par</code></span> :</p>
<pre><code>&#39; ========= Parameter file for v7.3 ===================&#39; 
&#39;**** Preliminaries ****&#39;
&#39;NOTORQ&#39; = CMDTRQ*6 (NOTORQ, DOTORQ) -- either do or skip torque calculations
&#39;PBCGS2&#39; = CMDSOL*6 (PBCGS2, PBCGST, GPBICG, PETRKP, QMRCCG) -- CCG method
&#39;GPFAFT&#39; = CMDFFT*6 (GPFAFT, FFTMKL) -- FFT method
&#39;GKDLDR&#39; = CALPHA*6 (GKDLDR, LATTDR, FLTRCD) -- DDA method
&#39;NOTBIN&#39; = CBINFLAG (NOTBIN, ORIBIN, ALLBIN) -- specify binary output
&#39;**** Initial Memory Allocation ****&#39;
100 100 100 = dimensioning allowance for target generation
&#39;**** Target Geometry and Composition ****&#39;
&#39;RCTGLPRSM&#39; = CSHAPE*9 shape directive
16 32 32  = shape parameters 1 - 3
1         = NCOMP = number of dielectric materials
&#39;../diel/Au_evap&#39; = file with refractive index 1
&#39;**** Additional Nearfield calculation? ****&#39;
0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
0.0 0.0 0.0 0.0 0.0 0.0 (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)
&#39;**** Error Tolerance ****&#39;
1.00e-5 = TOL = MAX ALLOWED (NORM OF |G&gt;=AC|E&gt;-ACA|X&gt;)/(NORM OF AC|E&gt;)
&#39;**** maximum number of iterations allowed ****&#39;
300     = MXITER
&#39;**** Interaction cutoff parameter for PBC calculations ****&#39;
1.00e-2 = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)
&#39;**** Angular resolution for calculation of &lt;cos&gt;, etc. ****&#39;
0.5 = ETASCA (number of angles is proportional to [(3+x)/ETASCA]^2 )
&#39;**** Vacuum wavelengths (micron) ****&#39;
0.5000 0.5000 1 &#39;LIN&#39; = wavelengths (first,last,how many,how=LIN,INV,LOG)
&#39;**** Refractive index of ambient medium&#39;
1.000 = NAMBIENT
&#39;**** Effective Radii (micron) **** &#39;
0.246186 0.246186 1 &#39;LIN&#39; = aeff (first,last,how many,how=LIN,INV,LOG)
&#39;**** Define Incident Polarizations ****&#39;
(0,0) (1.,0.) (0.,0.) = Polarization state e01 (k along x axis)
2 = IORTH  (=1 to do only pol. state e01; =2 to also do orth. pol. state)
&#39;**** Specify which output files to write ****&#39;
1 = IWRKSC (=0 to suppress, =1 to write &quot;.sca&quot; file for each target orient.
&#39;**** Prescribe Target Rotations ****&#39;
0.    0.   1  = BETAMI, BETAMX, NBETA  (beta=rotation around a1)
0.    0.   1  = THETMI, THETMX, NTHETA (theta=angle between a1 and k)
0.    0.   1  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
&#39;**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****&#39;
0   0   0    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
&#39;**** Select Elements of S_ij Matrix to Print ****&#39;
6   = NSMELTS = number of elements of S_ij to print (not more than 9)
11 12 21 22 31 41   = indices ij of elements to print
&#39;**** Specify Scattered Directions ****&#39;
&#39;LFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
2 = NPLANES = number of scattering planes
0.   0. 180.  5 = phi, thetan_min, thetan_max, dtheta (in deg) for plane 1
90.  0. 180.  5 = phi, thetan_min, thetan_max, dtheta (in deg) for plane 2</code></pre>
<p>Here we discuss the general structure of
<span><code>ddscat.par</code></span> (see also Appendix <a
href="#app:ddscat.par" data-reference-type="ref"
data-reference="app:ddscat.par">[app:ddscat.par]</a>).</p>
<h2 id="preliminaries"> Preliminaries</h2>
<p><span><code>ddscat.par</code></span> starts by setting the values of
five strings:</p>
<ul>
<li><p>CMDTRQ specifying whether or not radiative torques are to be
calculated (e.g., NOTORQ)</p></li>
<li><p>CMDSOL specifying the CCG method (e.g., PBCGS2) (see section §<a
href="#sec:choice_of_algorithm" data-reference-type="ref"
data-reference="sec:choice_of_algorithm">[sec:choice_of_algorithm]</a>).</p></li>
<li><p>CMDFFT specifying the FFT method (e.g., GPFAFT) (see section §<a
href="#sec:choice_of_fft" data-reference-type="ref"
data-reference="sec:choice_of_fft">[sec:choice_of_fft]</a>).</p></li>
<li><p>CALPHA specifying the DDA method (e.g., GKDLDR or FLTRCD) (see
§<a href="#sec:DDA_method" data-reference-type="ref"
data-reference="sec:DDA_method">[sec:DDA_method]</a>).</p></li>
<li><p>CBINFLAG specifying whether to write out binary files (e.g.,
NOTBIN)</p></li>
</ul>
<h2 id="initial-memory-allocation"> Initial Memory Allocation</h2>
<p>Three integers<br />
<span><code>MXNX MXNY MXNZ</code></span><br />
are given that need to be equal to or larger than the anticipated target
size (in lattice units) in the <span class="math inline">\(\hat{\bf
x}_{\rm TF}\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span>, and <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> directions. This is required only for initial memory
allocation for the target-generation stage of the calculation. For
example,<br />
100 100 100<br />
would require initial memory allocation of only <span
class="math inline">\(\sim100~\)</span>MBytes. Note that after the
target geometry has been determined, <span><strong>DDSCAT
7.3</strong></span> will proceed to reallocate as much memory as is
actually required for the calculation.</p>
<h2 id="target-geometry-and-composition"> Target Geometry and
Composition</h2>
<ul>
<li><p>CSHAPE specifies the target geometry (e.g., RCTGLPRSM)</p></li>
</ul>
<p>As provided, the file <span><code>ddscat.par</code></span> is set up
to calculate scattering by a 32<span
class="math inline">\(\times\)</span>64<span
class="math inline">\(\times\)</span>64 rectangular array of 131072
dipoles.</p>
<p>The user must specify <span><code>NCOMP</code></span>, the number of
different compositions (i.e., dielectric functions) that will be used.
This is then followed by <span><code>NCOMP</code></span> lines, with
each line giving the name (in quotes) of a dielectric function file. In
our example, <span><code>NCOMP</code></span> is set to 1. The dielectric
function of the target material is provided in the file
<span><code>../diel/Au_evap</code></span>, which gives the refractive
index of evaporated Au over a range of wavelengths. The file Au_evap is
located in subdirectory examples_exp/diel .</p>
<h2 id="additional-nearfield-calculation"> <span id="sec:nearfield calc"
label="sec:nearfield calc"></span> Additional Nearfield
Calculation?</h2>
<p>The user set NRFLD = 0 or 1 to indicate whether the first DDSCAT
calculation (solving for the target polarization, and absorption and
scattering cross sections) should automatically be followed by a second
“nearfield” calculation to evaluate the electric field <span
class="math inline">\({\bf E}\)</span> throughout a rectangular volume
containing the original target.</p>
<ul>
<li><p>If <span><code>NRFLD</code></span> = 0 , the nearfield
calculation will not be done.<br />
The next line in <span><code>ddscat.par</code></span> will be read but
not used.</p></li>
<li><p>If <span><code>NRFLD</code></span> = 1 , nearfield <span
class="math inline">\({\bf E}\)</span> will be calculated and
stored.</p></li>
<li><p>If <span><code>NRFLD</code></span> = 2 , nearfield <span
class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> will be calculated and
stored.</p></li>
</ul>
<p>The next line in <span><code>ddscat.par</code></span> then specifies
6 non-negative numbers, <span class="math inline">\(r_{1}\)</span>,
<span class="math inline">\(r_{2}\)</span>, <span
class="math inline">\(r_{3}\)</span>, <span
class="math inline">\(r_{4}\)</span>, <span
class="math inline">\(r_{5}\)</span>, <span
class="math inline">\(r_{6}\)</span> specifying the increase in size of
the nearfield computational volume relative to the circumscribing
rectangular volume used for the original solution. If the original
volume is <span class="math inline">\(X_1\leq x \leq X_2\)</span>, <span
class="math inline">\(Y_1\leq y\leq Y_2\)</span>, <span
class="math inline">\(Z_1\leq z \leq Z_2\)</span>, then the nearfield
calculation will be done in a volume <span
class="math inline">\((X_1-r_{1}L_x) \leq x \leq
(X_2+r_{2}L_x)\)</span>, <span class="math inline">\((Y_1-r_{3}L_y) \leq
y \leq (Y_2+r_{4}L_y)\)</span>, <span
class="math inline">\((Z_1-r_{5}L_z) \leq z \leq
(Z_2+r_{6}L_z)\)</span>, where <span class="math inline">\(L_x\equiv
(X_2-X_1)\)</span>, <span class="math inline">\(L_y\equiv
(Y_2-Y_1)\)</span>, <span class="math inline">\(L_z\equiv
(Z_2-Z_1)\)</span>.</p>
<h2 id="error-tolerance"> Error Tolerance</h2>
<p><span><code>TOL</code></span> = the error tolerance. Conjugate
gradient iteration will proceed until the linear equations are solved to
a fractional error <span><code>TOL</code></span>. The sample calculation
has <span><code>TOL</code></span>=<span
class="math inline">\(10^{-5}\)</span>.</p>
<h2 id="maximum-number-of-iterations"> Maximum Number of Iterations</h2>
<p><span><code>MXITER</code></span> = maximum number of
complex-conjugate-gradient iterations allowed. As there are <span
class="math inline">\(3N\)</span> equations to solve,
<span><code>MXITER</code></span> should never be larger than <span
class="math inline">\(3N\)</span>, but in practice should be much
smaller. As a default we suggest setting
<span><code>MXITER</code></span>=100, but for some problems that
converge very slowly you may need to use a larger value of
<span><code>MXITER</code></span>.</p>
<h2 id="interaction-cutoff-parameter-for-pbc-calculations"> Interaction
Cutoff Parameter for PBC Calculations</h2>
<p><span><code>GAMMA</code></span> = parameter limiting certain
summations that are required for periodic targets <span class="citation"
data-cites="Draine+Flatau_2008a"></span>. <span><strong>The value of
<span><code>GAMMA</code></span> has no effect on computations for finite
targets</strong></span> – it can be set to any value, including <span
class="math inline">\(0\)</span>).</p>
<p>For targets that are periodic in 1 or 2 dimensions,
<span><code>GAMMA</code></span> needs to be small for high accuracy, but
the required cpu time increases as <span><code>GAMMA</code></span>
becomes smaller. <span><code>GAMMA</code></span> = <span
class="math inline">\(10^{-2}\)</span> is reasonable for initial
calculations, but you may want to experiment to see if the results you
are interested in are sensitive to the value of
<span><code>GAMMA</code></span>. <span class="citation"
data-cites="Draine+Flatau_2008a"></span> show examples of how computed
results for scattering can depend on the value of <span
class="math inline">\(\gamma\)</span>.</p>
<h2
id="angular-resolution-for-computation-of-langlecosthetarangle-etc.">
Angular Resolution for Computation of <span
class="math inline">\(\langle\cos\theta\rangle\)</span>, etc.</h2>
<p>The parameter <span><code>ETASCA</code></span> determines the
selection of scattering angles used for computation of certain angular
averages, such as <span
class="math inline">\(\langle\cos\theta\rangle\)</span> and <span
class="math inline">\(\langle\cos^2\theta\rangle\)</span>, and the
radiation pressure force (see §<a
href="#sec:force and torque calculation" data-reference-type="ref"
data-reference="sec:force and torque calculation">[sec:force and torque
calculation]</a>) and radiative torque (if
<span><code>CMDTRQ=DOTORQ</code></span>). Small values of
<span><code>ETASCA</code></span> result in increased accuracy but also
cost additional computation time. <span><code>ETASCA</code></span>=0.5
generally gives accurate results.</p>
<p>If accurate computation of <span
class="math inline">\(\langle\cos\theta\rangle\)</span> or the radiation
pressure force is not required, the user can set
<span><code>ETASCA</code></span> to some large number, e.g. 10, to
minimize unnecessary computation.</p>
<h2 id="vacuum-wavelengths"> Vacuum Wavelengths</h2>
<p>Wavelengths <span class="math inline">\(\lambda\)</span> (in vacuo)
are specified in one line in <span><code>ddscat.par</code></span>
consisting of values for 4 variables:<br />
<span><code>WAVINI</code></span>  <span><code>WAVEND</code></span> 
<span><code>NWAV</code></span>  <span><code>CDIVID</code></span><br />
where <span><code>WAVINI</code></span> and
<span><code>WAVEND</code></span> are real numbers,
<span><code>NWAV</code></span> is an integer, and
<span><code>CDIVID</code></span> is a character variable.</p>
<ul>
<li><p>If <span><code>CDIVID = ’LIN’</code></span>, the <span
class="math inline">\(\lambda\)</span> will be uniformly spaced beween
<span><code>WAVINI</code></span> and
<span><code>WAVEND</code></span>.</p></li>
<li><p>If <span><code>CDIVID = ’INV’</code></span>, the <span
class="math inline">\(\lambda\)</span> will be uniformly spaced in <span
class="math inline">\(1/\lambda\)</span> between
<span><code>WAVINI</code></span> and
<span><code>WAVEND</code></span></p></li>
<li><p>If <span><code>CDIVID = ’LOG’</code></span>, the <span
class="math inline">\(\lambda\)</span> will be uniformly spaced in <span
class="math inline">\(\log(\lambda)\)</span> between
<span><code>WAVINI</code></span> and
<span><code>WAVEND</code></span></p></li>
<li><p>If <span><code>CDIVID = ’TAB’</code></span>, the <span
class="math inline">\(\lambda\)</span> will be read from a user-supplied
file <span><code>wave.tab</code></span>, with one wavelength per line.
For this case, the values of <span><code>WAVINI</code></span>,
<span><code>WAVEND</code></span>, and <span><code>NWAV</code></span>
will be disregarded.</p></li>
</ul>
<p>The sample <span><code>ddscat.par</code></span> file specifies that
the calculations be done for a single wavelength (<span
class="math inline">\(\lambda=0.50\)</span>). <span><strong>The units
must be the same as the wavelength units used in the file specifying the
refractive index.</strong></span> In this case, we are using <span
class="math inline">\({\mu{\rm m}}\)</span>.</p>
<h2 id="refractive-index-of-ambient-medium-m_rm-medium"><span
id="sec:nambient" label="sec:nambient"></span> Refractive Index of
Ambient Medium, <span class="math inline">\(m_{\rm medium}\)</span></h2>
<p>In some cases the target of interest will be immersed in a
transparent medium (e.g., water) with a refractive index different from
vacuum. The refractive index <span class="math inline">\(m_{\rm
medium}\)</span> should be specified here. As the medium is assumed to
be transparent, <span class="math inline">\(m_{\rm medium}\)</span> is a
real number. <span><strong>DDSCAT</strong></span> will calculate the
scattering properties for the target immersed in the ambient medium. If
the target is located in a vaccum, set <span
class="math inline">\(m_{\rm medium}=1\)</span>.</p>
<h2 id="target-size-a_rm-eff"> Target Size <span
class="math inline">\({a}_{\rm eff}\)</span></h2>
<p>Note that in <span><strong>DDSCAT</strong></span> the “effective
radius” <span class="math inline">\(a_{\rm eff}\)</span> is the radius
of a sphere of equal volume – i.e., a sphere of volume <span
class="math inline">\(Nd^3\)</span> , where <span
class="math inline">\(d\)</span> is the lattice spacing and <span
class="math inline">\(N\)</span> is the number of occupied (i.e.,
non-vacuum) lattice sites in the target. Thus the effective radius <span
class="math inline">\({a}_{\rm eff}= (3N/4\pi)^{1/3}d\)</span> . Our
target should have a thickness <span class="math inline">\(a=0.5{\mu{\rm
m}}\)</span> in the <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction. If the rectangular solid is <span
class="math inline">\(a\times b\times c\)</span>, with <span
class="math inline">\(a:b:c::32:64:64\)</span>, then <span
class="math inline">\(V=abc=4a^3\)</span>. Thus <span
class="math inline">\({a}_{\rm eff}=(3V/4\pi)^{1/3}=(3/\pi)^{1/3}a =
0.49237{\mu{\rm m}}\)</span>.</p>
<p>The target sizes <span class="math inline">\({a}_{\rm eff}\)</span>
to be studied are specified on one line of
<span><code>ddscat.par</code></span> consisting of 4 variables:
<span><code>AEFFINI AEFFEND NRAD CDIVID</code></span><br />
where <span><code>AEFFINI</code></span> and
<span><code>AEFFEND</code></span> are real numbers,
<span><code>NRAD</code></span> is an integer, and
<span><code>CDIVID</code></span> is a character variable.</p>
<ul>
<li><p>If <span><code>CDIVID = ’LIN’</code></span>, the <span
class="math inline">\({a}_{\rm eff}\)</span> will be uniformly spaced
beween <span><code>AEFFINI</code></span> and
<span><code>AEFFEND</code></span>.</p></li>
<li><p>If <span><code>CDIVID = ’INV’</code></span>, the <span
class="math inline">\({a}_{\rm eff}\)</span> will be uniformly spaced in
<span class="math inline">\(1/{a}_{\rm eff}\)</span> between
<span><code>AEFFINI</code></span> and
<span><code>AEFFEND</code></span></p></li>
<li><p>If <span><code>CDIVID = ’LOG’</code></span>, the <span
class="math inline">\({a}_{\rm eff}\)</span> will be uniformly spaced in
<span class="math inline">\(\log({a}_{\rm eff})\)</span> between
<span><code>AEFFINI</code></span> and
<span><code>AEFFEND</code></span></p></li>
<li><p>If <span><code>CDIVID = ’TAB’</code></span>, the <span
class="math inline">\({a}_{\rm eff}\)</span> will be read from a
user-supplied file <span><code>aeff.tab</code></span>, with one value of
<span class="math inline">\({a}_{\rm eff}\)</span> per line, beginning
on line 2. For this case, the values of
<span><code>AEFFINI</code></span>, <span><code>AEFFEND</code></span>,
and <span><code>NRAD</code></span> will be disregarded
(<span><strong>DDSCAT</strong></span> will read and use all the values
of <span class="math inline">\({a}_{\rm eff}\)</span> in the table
(beginning on line 2).</p></li>
</ul>
<p>The sample <span><code>ddscat.par</code></span> file specifies that
the calculations be done for a single <span
class="math inline">\({a}_{\rm eff}=0.49237{\mu{\rm m}}\)</span>. The
target is a rectangular solid with aspect ratio 1:2:2. The thickness in
the x direction is <span class="math inline">\((\pi/3)^{1/3}{a}_{\rm
eff}=0.500{\mu{\rm m}}\)</span>.</p>
<h2 id="incident-polarization"> Incident Polarization</h2>
<p>The incident radiation is always assumed to propagate along the <span
class="math inline">\(\hat{\bf x}_{\rm LF}\)</span> axis – the <span
class="math inline">\(x\)</span>-axis in the “Lab Frame”. The sample
<span><code>ddscat.par</code></span> file specifies incident
polarization state <span class="math inline">\({\hat{\bf
e}}_{01}\)</span> to be along the <span class="math inline">\(\hat{\bf
y}_{\rm LF}\)</span> axis (and consequently polarization state <span
class="math inline">\({\hat{\bf e}}_{02}\)</span> will automatically be
taken to be along the <span class="math inline">\(\hat{\bf z}_{\rm
LF}\)</span> axis). <span><code>IORTH=2</code></span> in
<span><code>ddscat.par</code></span> calls for calculations to be
carried out for both incident polarization states (<span
class="math inline">\({\hat{\bf e}}_{01}\)</span> and <span
class="math inline">\({\hat{\bf e}}_{02}\)</span> – see §<a
href="#sec:incident_polarization" data-reference-type="ref"
data-reference="sec:incident_polarization">[sec:incident_polarization]</a>).</p>
<h2 id="target-orientation"><span id="sec:target_orientation"
label="sec:target_orientation"></span> Target Orientation</h2>
<p>The target is assumed to have two vectors <span
class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span> embedded in it; <span
class="math inline">\({\hat{\bf a}}_2\)</span> is perpendicular to <span
class="math inline">\({\hat{\bf a}}_1\)</span>. For the present target
shape <span><code>RCTGLPRSM</code></span>, the vector <span
class="math inline">\({\hat{\bf
a}}_1\)</span> is along the <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> axis of the target, and the vector <span
class="math inline">\({\hat{\bf a}}_2\)</span> is along the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> axis (see §<a
href="#sec:RCTGLPRSM" data-reference-type="ref"
data-reference="sec:RCTGLPRSM">[sec:RCTGLPRSM]</a>). The target
orientation in the Lab Frame is set by three angles: <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span>, defined and discussed below in §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>.
Briefly, the polar angles <span class="math inline">\(\Theta\)</span>
and <span class="math inline">\(\Phi\)</span> specify the direction of
<span class="math inline">\({\hat{\bf a}}_1\)</span> in the Lab Frame.
The target is assumed to be rotated around <span
class="math inline">\({\hat{\bf a}}_1\)</span> by an angle <span
class="math inline">\(\beta\)</span>. The sample
<span><code>ddscat.par</code></span> file specifies <span
class="math inline">\(\beta=0\)</span> and <span
class="math inline">\(\Phi=0\)</span> (see lines in
<span><code>ddscat.par</code></span> specifying variables
<span><code>BETA</code></span> and <span><code>PHI</code></span>), and
calls for three values of the angle <span
class="math inline">\(\Theta\)</span> (see line in
<span><code>ddscat.par</code></span> specifying variable
<span><code> THETA</code></span>).
<span><strong>DDSCAT</strong></span> chooses <span
class="math inline">\(\Theta\)</span> values uniformly spaced in <span
class="math inline">\(\cos\Theta\)</span>. In this case we specify 0 0 1
: we obtain only one value: <span
class="math inline">\(\Theta=0\)</span>. <a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<h2 id="starting-values-of-iwav-irad-iori"> Starting Values of
<span><code>IWAV</code></span>, <span><code>IRAD</code></span>,
<span><code>IORI</code></span></h2>
<p>Normally we begin the calculation with
<span><code>IWAVE</code></span>=0, <span><code>IRAD</code></span>=0, and
<span><code>IORI</code></span>=0. However, under some circumstances, a
prior calculation may have completed some of the cases. If so, the user
can specify starting values of <span><code>IWAV</code></span>,
<span><code>IRAD</code></span>, <span><code>IORI</code></span>; the
computations will begin with this case, and continue.</p>
<h2 id="which-mueller-matrix-elements"> Which Mueller Matrix
Elements?</h2>
<p>The sample parameter file specifies that
<span><strong>DDSCAT</strong></span> should calculate 6 distinct Mueller
scattering matrix elements <span class="math inline">\(S_{ij}\)</span>,
with 11, 12, 21, 22, 31, 41 being the chosen values of <span
class="math inline">\(ij\)</span>.</p>
<h2 id="what-scattering-directions"> What Scattering Directions?</h2>
<h3 id="isolated-finite-targets">Isolated Finite Targets</h3>
<p>For finite targets, the user may specify the scattering directions in
either the Lab Frame (<span><code>’LFRAME’</code></span>) or the Target
Frame (<span><code>’TFRAME’</code></span>).</p>
<p>For finite targets, such as specified in this sample
<span><code>ddscat.par</code></span>, the <span
class="math inline">\(S_{ij}\)</span> are to be calculated for
scattering directions specified by angles <span
class="math inline">\((\theta,\phi)\)</span>.</p>
<p>The sample <span><code>ddscat.par</code></span> specifies that 2
scattering planes are to be specified: the first has <span
class="math inline">\(\phi=0\)</span> and the second has <span
class="math inline">\(\phi=90^\circ\)</span>; for each scattering plane
<span class="math inline">\(\theta\)</span> values run from 0 to <span
class="math inline">\(180^\circ\)</span> in increments of <span
class="math inline">\(10^\circ\)</span>.</p>
<h3 id="d-periodic-targets">1-D Periodic Targets</h3>
<p>For periodic targets, the scattering directions
<span><code>must</code></span> be specified in the Target Frame:
<span><code>’TFRAME’ = CMDFRM</code></span> .</p>
<p>Scattering from 1-d periodic targets is discussed in detail by <span
class="citation" data-cites="Draine+Flatau_2008a"></span>. For periodic
targets, the user does not specify scattering planes. For 1-dimensional
targets, the user specifies scattering cones, corresponding to different
scattering orders <span class="math inline">\(M\)</span>. For each
scattering cone <span class="math inline">\(M\)</span>, the user
specifies <span class="math inline">\(\zeta_{\rm min}\)</span>, <span
class="math inline">\(\zeta_{\rm max}\)</span>, <span
class="math inline">\(\Delta\zeta\)</span> (in degrees); the azimuthal
angle <span class="math inline">\(\zeta\)</span> will run from <span
class="math inline">\(\zeta_{\rm min}\)</span> to <span
class="math inline">\(\zeta_{max}\)</span>, in increments of <span
class="math inline">\(\Delta\zeta\)</span>. For example:</p>
<pre><code>&#39;TFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
1 = number of scattering cones
0.  0. 180. 0.05  = OrderM zetamin zetamax dzeta for scattering cone 1</code></pre>
<h3 id="d-periodic-targets-1">2-D Periodic Targets</h3>
<p>For targets that are periodic in 2 dimensions, the scattering
directions <span><code>must</code></span> be specified in the Target
Frame: <span><code>’TFRAME’ = CMDFRM</code></span> .</p>
<p>Scattering from targets that are periodic in 2 dimensions is
discussed in detail by <span class="citation"
data-cites="Draine+Flatau_2008a"></span>. For 2-D periodic targets, the
user specifies the diffraction orders <span
class="math inline">\((M,N)\)</span> for transmitted radiation: the code
will automatically calculate the scattering matrix elements <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> for both transmitted
and reflected radiation for each <span
class="math inline">\((M,N)\)</span> specified by the user. For
example:</p>
<pre><code>&#39;TFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
1 = number of scattering orders
0.  0. = OrderM OrderN for scattered radiation</code></pre>
<h1 id="running-ddscat-7.3-using-the-sample-ddscat.par-file">Running
<span><strong>DDSCAT 7.3</strong></span> Using the Sample
<span><code>ddscat.par</code></span> File</h1>
<p>It is again assumed that you are in directory
<span><code>../DDA/examples_exp/RCTGLPRSM</code></span>, as per §<a
href="#sec:sample calculation" data-reference-type="ref"
data-reference="sec:sample calculation">[sec:sample calculation]</a>.
The <span><code>ddscat</code></span> executable (created as per the
instructions in §<a href="#sec:compiling" data-reference-type="ref"
data-reference="sec:compiling">[sec:compiling]</a>) is assumed to be
<span><code>../DDA/src/ddscat</code></span></p>
<h2 id="single-process-execution"> Single-Process Execution</h2>
<p>To execute the program on a UNIX system (running either
<span><code>sh</code></span> or <span><code>csh</code></span>), simply
create a symbolic link by typing</p>
<p>or you could simply move the previously-created executable into the
current directory (assumed to be ../DDA/examples_exp/RCTGLPRSM/) by
typing</p>
<p>Then, to perform the calculation, type</p>
<p>which will redirect the “standard output” to the file
<span><code> ddscat.out</code></span>, and run the calculation in the
background.</p>
<p>The sample calculation [32x64x64=131072 dipole target, 3 target
orientations, two incident polarizations for each orientation, with
scattering (Mueller matrix elements <span
class="math inline">\(S_{ij}\)</span>) calculated for 37 distinct
scattering directions], requires 672 cpu sec to complete on a 2.53 GHz
cpu. for the assumed Au composition, between 28 and 32 iterations were
required for the complex conjugate gradient solver to converge to the
specified error tolerance of <span><code>TOL = 1.e-5</code></span> for
each orientation and incident polarization.</p>
<h2 id="code-execution-under-mpi"> Code Execution Under MPI</h2>
<p>Local installations of <span><code>MPI</code></span> will vary – you
should consult with someone familiar with way
<span><code>MPI</code></span> is installed and used on your system.</p>
<p>At Princeton University Dept. of Astrophysical Sciences we use
<span><code>PBS</code></span> (Portable Batch System)<a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> to
schedule jobs.<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> <span><code>MPI</code></span> jobs
are submitted using <span><code>PBS</code></span> by first creating a
shell script such as the following example file
<span><code>pbs.submit</code></span>:<br />
#!/bin/bash<br />
#PBS -l nodes=2:ppn=1<br />
#PBS -l mem=1200MB,pmem=300MB<br />
#PBS -m bea<br />
#PBS -j oe<br />
cd  $PBS_O_WORKDIR<br />
/usr/local/bin/mpiexec  ddscat<br />
The lines beginning with <span><code>#PBS -l</code></span> specify the
required resources:<br />
<span><code>#PBS -l nodes=2:ppn=1</code></span> specifies that 2 nodes
are to be used, with 1 processor per node.<br />
<span><code>#PBS -l mem=1200MB,pmem=300MB</code></span> specifies that
the total memory required (<span><code>mem</code></span>) is 1200MB, and
the maximum physical memory used by any single process
(<span><code>pmem</code></span>) is 300MB. The actual definition of
<span><code>mem</code></span> is not clear, but in practice it seems
that it should be set equal to 2<span
class="math inline">\(\times\)</span>(<span><code>nodes</code></span>)<span
class="math inline">\(\times\)</span>(<span><code>ppn</code></span>)<span
class="math inline">\(\times\)</span>(<span><code>pmem</code></span>)
.<br />
<span><code>#PBS -m bea</code></span> specifies that PBS should send
email when the job begins (<span><code>b</code></span>), and when it
ends (<span><code>e</code></span>) or aborts
(<span><code>a</code></span>).<br />
<span><code>#PBS -j oe</code></span> specifies that the output from
stdout and stderr will be merged, intermixed, as stdout.</p>
<p>This example assumes that the executable
<span><code>dscat</code></span> is located in the same directory where
the code is to execute and write its output. If
<span><code>ddscat</code></span> is located in another directory, simply
give the full pathname. to it. The <span><code>qsub</code></span>
command is used to submit the <span><code>PBS</code></span> job:<br />
<br />
<span><code>qsub pbs.submit</code></span><br />
As the calculation proceeds, the usual output files will be written to
this directory: for each wavelength, target size, and target
orientation, there will be a file
<span><code>w</code></span><span><em>aaa</em></span><span><code>r</code></span><span><em>bbb</em></span><span><code>k</code></span><span><em>ccc</em></span><span><code>.sca</code></span>,
where <span><em>aaa=000, 001, 002, ...</em></span> specifies the
wavelength, <span><em>bbb=000, 001, 002, ...</em></span> specifies the
target size, and <span><em>cc=000, 001, 002, ...</em></span> specifies
the orientation. For each wavelength and target size there will also be
a file
<span><code>w</code></span><span><em>aaa</em></span><span><code>r</code></span><span><em>bbb</em></span><span><code>ori.avg</code></span>
with orientationally-averaged quantities. Finally, there will also be
tables <span><code>qtable</code></span>, and
<span><code>qtable2</code></span> with orientationally-averaged cross
sections for each wavelength and target size.</p>
<p>In addition, each processor employed will write to its own log file
<span><code>ddscat.log_</code></span><span><em>nnn</em></span>, where
<span><em>nnn=000, 001, 002, ...</em></span>. These files contain
information concerning cpu time consumed by different parts of the
calculation, convergence to the specified error tolerance, etc. If you
are uncertain about how the calculation proceeded, examination of these
log files is recommended.</p>
<h1 id="output-files">Output Files</h1>
<h2 id="ascii-files"> ASCII files<span id="subsec:ascii"
label="subsec:ascii"></span></h2>
<p>If you run DDSCAT using the command you will have various types of
ASCII files when the computation is complete:</p>
<ul>
<li><p>a file <span><code>ddscat.log</code></span>;</p></li>
<li><p>a file <span><code>mtable</code></span>;</p></li>
<li><p>a file <span><code>qtable</code></span>;</p></li>
<li><p>a file <span><code>qtable2</code></span>;</p></li>
<li><p>files
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>ori.avg</code></span>
(one, <span><code>w000r000ori.avg</code></span>, for the sample
calculation);</p></li>
<li><p>if <span><code>ddscat.par</code></span> specified
<span><code>IWRKSC</code></span>=1, there will also be files
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.sca</code></span>
(1 for the sample calculation:
<span><code>w000r000k000.sca</code></span>lcl,
<span><code>w000r000k001.sca</code></span>,
<span><code>w000r000k002.sca</code></span>).</p></li>
</ul>
<p>The file <span><code>ddscat.out</code></span> will contain minimal
information (it may in fact be empty).</p>
<p>The file <span><code>ddscat.log_000</code></span> will contain any
error messages generated as well as a running report on the progress of
the calculation, including creation of the target dipole array. During
the iterative calculations, <span class="math inline">\(Q_{\rm
ext}\)</span>, <span class="math inline">\(Q_{\rm abs}\)</span>, and
<span class="math inline">\(Q_{\rm pha}\)</span> are printed after each
iteration; you will be able to judge the degree to which convergence has
been achieved. Unless <span><code>TIMEIT</code></span> has been
disabled, there will also be timing information. If the
<span><code>MPI</code></span> option is used to run the code on multiple
cpus, there will be one file of the form
<span><code>ddscat.log_nnn</code></span> for each of the cpus, with
<span><code>nnn=000,001,002,...</code></span>.</p>
<p>The file <span><code>mtable</code></span> contains a summary of the
dielectric constant used in the calculations.</p>
<p>The file <span><code>qtable</code></span> contains a summary of the
orientationally-averaged values of <span class="math inline">\(Q_{\rm
ext}\)</span>, <span class="math inline">\(Q_{\rm abs}\)</span>, <span
class="math inline">\(Q_{\rm sca}\)</span>, <span
class="math inline">\(g(1)=\langle\cos(\theta_s)\rangle\)</span>, <span
class="math inline">\(\langle\cos^2(\theta_s)\rangle\)</span>, <span
class="math inline">\(Q_{\rm bk}\)</span>, and <span
class="math inline">\(N_{\rm sca}\)</span>. Here <span
class="math inline">\(Q_{\rm ext}\)</span>, <span
class="math inline">\(Q_{\rm abs}\)</span>, and <span
class="math inline">\(Q_{\rm sca}\)</span> are the extinction,
absorption, and scattering cross sections divided by <span
class="math inline">\(\pi a_{\rm eff}^2\)</span>. <span
class="math inline">\(Q_{\rm bk}\)</span> is the differential cross
section for backscattering (area per sr) divided by <span
class="math inline">\(\pi a_{\rm eff}^2\)</span>. <span
class="math inline">\(N_{\rm sca}\)</span> is the number of scattering
directions used for averaging over scattering directions (to obtain
<span class="math inline">\(\langle\cos\theta\rangle\)</span>, etc.)
(see §<a href="#sec:averaging_scattering" data-reference-type="ref"
data-reference="sec:averaging_scattering">[sec:averaging_scattering]</a>).</p>
<p>The file <span><code>qtable2</code></span> contains a summary of the
orientationally-averaged values of <span class="math inline">\(Q_{\rm
pha}\)</span>, <span class="math inline">\(Q_{\rm pol}\)</span>, and
<span class="math inline">\(Q_{\rm cpol}\)</span>. Here <span
class="math inline">\(Q_{\rm pha}\)</span> is the “phase shift” cross
section divided by <span class="math inline">\(\pi a_{\rm
eff}^2\)</span> <span class="citation" data-cites="Draine_1988"></span>.
<span class="math inline">\(Q_{\rm pol}\)</span> is the “polarization
efficiency factor”, equal to the difference between <span
class="math inline">\(Q_{\rm ext}\)</span> for the two orthogonal
polarization states. We define a “circular polarization efficiency
factor” <span class="math inline">\(Q_{\rm cpol}\equiv Q_{\rm pol}Q_{\rm
pha}\)</span>, since an optically-thin medium with a small twist in the
alignment direction will produce circular polarization in initially
unpolarized light in proportion to <span class="math inline">\(Q_{\rm
cpol}\)</span>.</p>
<p>For each wavelength and size, <span><strong>DDSCAT
7.3</strong></span> produces a file with a name of the form, where index
<span><em>xxx</em></span> (=000, 001, 002....) designates the wavelength
and index <span> <em>yyy</em></span> (=000, 001, 002...) designates the
“radius”; this file contains <span class="math inline">\(Q\)</span>
values and scattering information averaged over however many target
orientations have been specified (see §<a href="#sec:target_orientation"
data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>.
The file <span><code>w000r000ori.avg</code></span> produced by the
sample calculation is provided below in Appendix <a
href="#app:w000r000ori.avg" data-reference-type="ref"
data-reference="app:w000r000ori.avg">[app:w000r000ori.avg]</a>.</p>
<p>In addition, if <span><code>ddscat.par</code></span> has specified
<span><code>IWRKSC</code></span>=1 (as for the sample calculation),
<span><strong>DDSCAT 7.3</strong></span> will generate files with names
of the form
<span><code>w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>k</code><span><em><code>zzz</code></em></span><code>.avg</code></span>,
where <span> <em>xxx</em></span> and <span><em>yyy</em></span> are as
before, and index <span><em>zzz</em></span> enumerates the target
orientations.<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> These files contain <span
class="math inline">\(Q\)</span> values and scattering information for
<span><em>each</em></span> of the target orientations. The structure of
each of these files is very similar to that of the
<span><code> w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>ori.avg</code></span>
files. Because these files may not be of particular interest, and take
up disk space, you may choose to set <span><code>IWRKSC</code></span>=0
in future work. However, it is suggested that you run the sample
calculation with <span><code>IWRKSC</code></span>=1.</p>
<p>The sample <span><code>ddscat.par</code></span> file specifies
<span><code>IWRKSC</code></span>=1 and calls for use of 1 wavelength, 1
target size, and averaging over 3 target orientations. Running
<span><strong>DDSCAT 7.3</strong></span> with the sample
<span><code> ddscat.par</code></span> file will therefore generate files
<span><code>w000r000k000.sca</code></span>,
<span><code>w000r000k001.sca</code></span>, and
<span><code>w000r000k002.sca</code></span> . To understand the
information contained in one of these files, please consult Appendix <a
href="#app:w000r000k000.sca" data-reference-type="ref"
data-reference="app:w000r000k000.sca">[app:w000r000k000.sca]</a>, which
contains an example of the file
<span><code> w000r000k000.sca</code></span> produced in the sample
calculation.</p>
<h2 id="binary-option"> Binary Option<span id="subsec:binary"
label="subsec:binary"></span></h2>
<p>It is possible to output an “unformatted” or “binary” file
(<span><code> dd.bin</code></span>) with fairly complete information,
including header and data sections. This is accomplished by specifying
either <span><code>ALLBIN</code></span> or
<span><code>ORIBIN</code></span> in <span><code>ddscat.par</code></span>
.</p>
<p>Subroutine <span><code>writebin.f90</code></span> provides an example
of how this can be done. The “header” section contains dimensioning and
other variables which do not change with wavelength, particle geometry,
and target orientation. The header section contains data defining the
particle shape, wavelengths, particle sizes, and target orientations. If
<span><code>ALLBIN</code></span> has been specified, the “data” section
contains, for each orientation, Mueller matrix results for each
scattering direction. The data output is limited to actual dimensions of
arrays; e.g. <span><code>nscat,4,4</code></span> elements of Muller
matrix are written rather than <span><code>mxscat,4,4</code></span>.
This is an important consideration when writing postprocessing
codes.</p>
<h1 id="choice-of-iterative-algorithm">Choice of Iterative
Algorithm<span id="sec:choice_of_algorithm"
label="sec:choice_of_algorithm"></span></h1>
<p>As discussed elsewhere <span class="citation"
data-cites="Draine_1988 Draine+Flatau_1994"></span>, the problem of
electromagnetic scattering of an incident wave <span
class="math inline">\({\bf E}_{\rm inc}\)</span> by an array of <span
class="math inline">\(N\)</span> point dipoles can be cast in the form
<span class="math display">\[{\bf A} {\bf P} = {\bf E}
\label{eq:AP=E}\]</span> where <span class="math inline">\({\bf
E}\)</span> is a <span class="math inline">\(3N\)</span>-dimensional
(complex) vector of the incident electric field <span
class="math inline">\({\bf E}_{\rm inc}\)</span> at the <span
class="math inline">\(N\)</span> lattice sites, <span
class="math inline">\({\bf P}\)</span> is a <span
class="math inline">\(3N\)</span>-dimensional (complex) vector of the
(unknown) dipole polarizations, and <span class="math inline">\({\bf
A}\)</span> is a <span class="math inline">\(3N\times3N\)</span> complex
matrix.</p>
<p>Because <span class="math inline">\(3N\)</span> is a large number,
direct methods for solving this system of equations for the unknown
vector <span class="math inline">\({\bf P}\)</span> are impractical, but
iterative methods are useful: we begin with a guess (typically, <span
class="math inline">\({\bf
P}=0\)</span>) for the unknown polarization vector, and then iteratively
improve the estimate for <span class="math inline">\({\bf P}\)</span>
until equation (<a href="#eq:AP=E" data-reference-type="ref"
data-reference="eq:AP=E">[eq:AP=E]</a>) is solved to some error
criterion. The error tolerance may be specified as <span
class="math display">\[{|{\bf A}^\dagger {\bf A} {\bf P} - {\bf
A}^\dagger {\bf E}| \over
| {\bf A}^\dagger {\bf E} |}
&lt; h
\label{eq:err_tol}~~~,\]</span> where <span class="math inline">\({\bf
A}^\dagger\)</span> is the Hermitian conjugate of <span
class="math inline">\({\bf A}\)</span> [<span
class="math inline">\((A^\dagger)_{ij} \equiv (A_{ji})^*\)</span>], and
<span class="math inline">\(h\)</span> is the error tolerance. We
typically use <span class="math inline">\(h=10^{-5}\)</span> in order to
satisfy eq.(<a href="#eq:AP=E" data-reference-type="ref"
data-reference="eq:AP=E">[eq:AP=E]</a>) to high accuracy. The error
tolerance <span class="math inline">\(h\)</span> can be specified by the
user through the parameter <span><code>TOL</code></span> in the
parameter file <span><code>ddscat.par</code></span> (see Appendix <a
href="#app:ddscat.par" data-reference-type="ref"
data-reference="app:ddscat.par">[app:ddscat.par]</a>).</p>
<p>A major change in going from
<span><strong>DDSCAT</strong></span><span><strong>.4b</strong></span> to
<span><strong>5a</strong></span> (and subsequent versions) was the
implementation of several different algorithms for iterative solution of
the system of complex linear equations. <span><strong>DDSCAT
7.3</strong></span> is now structured to permit solution algorithms to
be treated in a fairly “modular” fashion, facilitating the testing of
different algorithms. A number of algorithms were compared by <span
class="citation" data-cites="Flatau_1997"></span><a href="#fn9"
class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>;
two of them (<span><code>PBCGST</code></span> and
<span><code>PETRKP</code></span>) performed well and were made available
to the user in the <span><strong>DDSCAT 6.0</strong></span> release.
<span><strong>DDSCAT 7.1</strong></span> introduced a third option,
<span><code>PBCGS2</code></span>. <span><strong>DDSCAT
7.2</strong></span> and <span><strong>DDSCAT 7.3</strong></span> include
two more CCG options: <span><code>GPBICG</code></span> and
<span><code>QMRCCG</code></span>. The choice of algorithm is made by
specifying one of the options (here in alphabetical order):</p>
<ul>
<li><p><span><code>GPBICG</code></span> – Generalized Product-type
methods based on Bi-CG <span class="citation"
data-cites="Zhang_1997"></span>. We use an implementation suggested by
<span class="citation" data-cites="Tang+Shen+Zheng+Qiu_2004"></span>,
and coded by P.C. Chaumet and A. Rahmani <span class="citation"
data-cites="Chaumet+Rahmani_2009"></span>. We are grateful to P.C.
Chaumet and A. Rahmani for making their code available.</p></li>
<li><p><span><code>PBCGS2</code></span> – BiConjugate Gradient with
Stabilization as implemented in the routine ZBCG2 by M.A. Botchev,
University of Twente. This is based on the PhD thesis of D.R. Fokkema,
and on work by <span class="citation"
data-cites="Sleijpen+vanderVorst_1995 Sleijpen+vanderVorst_1996"></span>.</p></li>
<li><p><span><code>PBCGST</code></span> – Preconditioned BiConjugate
Gradient with STabilitization method from the Parallel Iterative Methods
(PIM) package created by R. Dias da Cunha and T. Hopkins.</p></li>
<li><p><span><code>PETRKP</code></span> – the complex conjugate gradient
algorithm of <span class="citation"
data-cites="Petravic+Kuo-Petravic_1979"></span>, as coded in the Complex
Conjugate Gradient package (CCGPACK) created by P.J. Flatau. This is the
algorithm discussed by <span class="citation"
data-cites="Draine_1988"></span> and used in the earliest versions of
<span><strong>DDSCAT</strong></span>.</p></li>
<li><p><span><code>QMRCCG</code></span> – the quasi-minimum-residual
complex conjugate gradient algorithm, based on f77 code written by P.C.
Chaumet and A. Rahmani, converted here to f90 and adapted to
single/double precision.</p></li>
</ul>
<p>All five methods work fairly well. Our experience suggests that
<span><code>PBCGS2</code></span> is generally fastest and best-behaved,
and we recommend that the user try it first. There have been claims that
<span><code>QMRCCG</code></span> and/or <span><code>GPBICG</code></span>
are faster, but this has not been our experience.
<span><code>PETRKP</code></span> is slow but may prove stable on some
problems where more aggressive algorithms become unstable. We have not
carried out systematic studies of the relative performance of the
different algorithms – the user is encouraged to experiment.</p>
<p>If a fast algorithm the case it runs into numerical difficulties,
<span><code>PBCGST</code></span> and <span><code>PETRKP</code></span>
are available as alternatives.<a href="#fn10" class="footnote-ref"
id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<h1 id="choice-of-fft-algorithm">Choice of FFT Algorithm<span
id="sec:choice_of_fft" label="sec:choice_of_fft"></span></h1>
<p><span><strong>DDSCAT 7.3</strong></span> offers two FFT options: (1)
the GPFA FFT algorithm developed by Dr. Clive Temperton <span
class="citation" data-cites="Temperton_1992"></span>, <a href="#fn11"
class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
and (2) the Intel<sup></sup> MKL routine
<span><code>DFTI</code></span>.</p>
<div class="center">
<figure>
<img src="f5.png" id="fig:fft_timings" style="width:9cm"
alt="Comparison of cpu time required by 3 different FFT implementations. It is seen that the GPFA and FFTW implementations have comparable speeds, much faster than Brenner’s FFT implementation. " />
<figcaption aria-hidden="true">Comparison of cpu time required by 3
different FFT implementations. It is seen that the GPFA and FFTW
implementations have comparable speeds, much faster than Brenner’s FFT
implementation. </figcaption>
</figure>
</div>
<p>The GPFA routine is portable and quite fast: Figure 5 compares the
speed of three FFT implementations: Brenner’s, GPFA, and FFTW
(<span><code>http://www.fftw.org</code></span>). We see that while for
some cases <span><code>FFTW 2.1.5</code></span> is faster than the GPFA
algorithm, the difference is only marginal. The FFTW code and GPFA code
are quite comparable in performance – for some cases the GPFA code is
faster, for other cases the FFTW code is faster. For target dimensions
which are factorizable as <span class="math inline">\(2^i3^j5^k\)</span>
(for integer <span class="math inline">\(i\)</span>, <span
class="math inline">\(j\)</span>, <span
class="math inline">\(k\)</span>), the GPFA and FFTW codes have the same
memory requirements. For targets with extents <span
class="math inline">\(N_x\)</span>, <span
class="math inline">\(N_y\)</span>, <span
class="math inline">\(N_z\)</span> which are not factorizable as <span
class="math inline">\(2^i3^j5^k\)</span>, the GPFA code needs to
“extend” the computational volume to have values of <span
class="math inline">\(N_x\)</span>, <span
class="math inline">\(N_y\)</span>, and <span
class="math inline">\(N_z\)</span> which are factorizable by 2, 3, and
5. For these cases, GPFA requires somewhat more memory than FFTW.
However, the fractional difference in required memory is not large,
since integers factorizable as <span
class="math inline">\(2^i3^j5^k\)</span> occur fairly frequently.<a
href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a> [Note: This “extension” of the
target volume occurs automatically and is transparent to the user.]</p>
<p><span><strong>DDSCAT 7.3</strong></span> offers a new FFT option: the
Intel<sup></sup> Math Kernel Library <span><code>DFTI</code></span>.
This is tuned for optimum performance, and appears to offer real
performance advantages on modern multi-core cpus. With this now
available, the FFTW option, which had been included in
<span><strong>DDSCAT</strong></span> <span><strong>6.1</strong></span>,
has been removed from <span><strong>DDSCAT 7.3</strong></span>.</p>
<p>The choice of FFT implementation is obtained by specifying one
of:</p>
<ul>
<li><p><span><code>FFTMKL</code></span> to use the Intel<sup></sup> MKL
routine <span><code>DFTI</code></span> (see §<a href="#sec:MKL"
data-reference-type="ref" data-reference="sec:MKL">[sec:MKL]</a>).
<span><strong>This is recommended, but requires that the
Intel<sup></sup> Math Kernel Library be installed on your
system</strong></span>.</p></li>
<li><p><span><code>GPFAFT</code></span> to use the GPFA algorithm <span
class="citation" data-cites="Temperton_1992"></span>. <span><strong>This
is not quite as fast as FFTMKL, but is written in plain Fortran-90. It
is a perfectly good alternative if the Intel<sup></sup> Math Kernel
Library is not available on your system.</strong></span></p></li>
</ul>
<h1 id="choice-of-dda-method">Choice of DDA Method<span
id="sec:DDA_method" label="sec:DDA_method"></span></h1>
<h2 id="point-dipoles-options-lattdr-and-gkdldr">Point Dipoles: Options
LATTDR and GKDLDR</h2>
<p>Earlier versions of <span><strong>DDSCAT</strong></span> (up to and
including <span><strong>DDSCAT 7.2</strong></span> treated the
well-defined problem of absorption and scattering by an array of
polarizable points <span class="citation"
data-cites="Purcell+Pennypacker_1973 Draine_1988 Draine+Flatau_1994"></span>,
where the target is divided up into finite elements, each represented by
a polarizable point. The problem is then fully characterized by the
geometric distribution of the polarizable points, the polarizability
<span class="math inline">\(\alpha\)</span> of each point, and the
incident electromagnetic wave. The polarizability <span
class="math inline">\(\alpha\)</span> is chosen according to some
prescription. Earlier versions of <span><strong>DDSCAT</strong></span>
offered as options the “Lattice Dispersion Relation” prescription of
<span class="citation" data-cites="Draine+Goodman_1993"></span>, and the
modified Lattice Dispersion Relation prescription of <span
class="citation" data-cites="Gutkowicz-Krusin+Draine_2004"></span>.
Option <span><code>GKDLDR</code></span> specifies that the
polarizability be prescribed by the “Lattice Dispersion Relation”, with
the polarizability found by <span class="citation"
data-cites="Gutkowicz-Krusin+Draine_2004"></span>, who corrected a
subtle error in the analysis of <span class="citation"
data-cites="Draine+Goodman_1993"></span>. For <span
class="math inline">\(|m|kd\lower.5ex\hbox{$\; \buildrel &lt; \over \sim
\;$}1\)</span>, the <span><code>GKDLDR</code></span> polarizability
differs slightly from the <span><code>LATTDR</code></span>
polarizability, but the differences in calculated scattering cross
sections are relatively small, as can be seen from Figure <a
href="#fig:GKDLDR_vs_LATTDR" data-reference-type="ref"
data-reference="fig:GKDLDR_vs_LATTDR">6</a>. We recommend option
<span><code>GKDLDR</code></span>.</p>
<p>Users wishing to compare can invoke option
<span><code>LATTDR</code></span> to specify that the “Lattice Dispersion
Relation” of <span class="citation"
data-cites="Draine+Goodman_1993"></span> be employed to determine the
dipole polarizabilities. This polarizability also works well.</p>
<p>This approach works well provided the refractive index <span
class="math inline">\(m\)</span> of the target material is not too
large. However, when <span class="math inline">\(|m|\)</span> is large,
both of these methods perform poorly.</p>
<h2 id="filtered-coupled-dipole-option-fltrcd">Filtered Coupled Dipole:
option FLTRCD</h2>
<p><span class="citation" data-cites="Piller+Martin_1998"></span>
proposed the “filtered coupled dipole” (FCD) method as an approach that
would work better for targets with large refractive indices. This method
continues to represent a finite target by an array of polarizable
points, but with the electric field generated by each point differing
from the field of a true point dipole by virtue of having component of
high spatial frequency “filtered out”. <span class="citation"
data-cites="Gay-Balmaz+Martin_2002"></span> revisited the FCD method,
correcting some typographical errors in <span class="citation"
data-cites="Piller+Martin_1998"></span>. <span class="citation"
data-cites="Yurkin+Min+Hoekstra_2010"></span> carried out a comparison
of the FCD method with the point dipole method and showed that the FCD
method could be used for targets with large refractive indices where the
the point dipole method failed.</p>
<p><span><strong>DDSCAT 7.3</strong></span> offers the filtered coupled
dipole method as an option (<span><code>FLTRDD</code></span>). When this
option is selected, the dipole polarizabilities are assigned by <span
class="math display">\[\alpha_j = \frac{\alpha^{\rm (CM)}}{1 + D}
~~~,\]</span> where <span class="math inline">\(\alpha^{\rm
(CM)}\)</span> is the Clausius-Mossotti polarizability <span
class="math display">\[\alpha^{\rm (CM)} \equiv
\frac{3d^3}{4\pi}\frac{(m_j^2-1)}{(m_j^2+2)}
~~~,\]</span> where <span class="math inline">\(m_j\)</span> is the
complex refractive index at lattice site <span
class="math inline">\(j\)</span>. The correction term <span
class="math inline">\(D\)</span> is given by <span
class="math display">\[D = \frac{\alpha^{\rm (CM)}}{d^3}
              \left[
              \frac{4}{3}(kd)^2+
              \frac{2}{3\pi}\ln\left[\frac{\pi-kd}{\pi+kd}\right]+
              \frac{2}{3}i(kd)^3
              \right]
~~~,\]</span> <span class="citation"
data-cites="Yurkin+Min+Hoekstra_2010"></span>. Here <span
class="math inline">\(d\)</span> is the lattice spacing, and <span
class="math inline">\(k\equiv\omega/c\)</span>.</p>
<div class="center">
<figure>
<img src="fldr.png" id="fig:GKDLDR_vs_LATTDR" style="width:8.5cm"
alt=" Scattering and absorption for a m=1.7+0.1i sphere, calculated using two prescriptions for the polarizability: LATTDR is the lattice dispersion relation result of . GKDLDR is the lattice dispersion relation result of . Results are shown as a function of scattering parameter x=2\pi a/\lambda; the upper scale gives values of |m|kd. We see that the cross sections calculated with these two prescriptions are quite similar for |m|kd\lower.5ex\hbox{$\; \buildrel &lt; \over \sim \;$}0.5. For other examples see . " />
<figcaption aria-hidden="true"> Scattering and absorption for a <span
class="math inline">\(m=1.7+0.1i\)</span> sphere, calculated using two
prescriptions for the polarizability: LATTDR is the lattice dispersion
relation result of <span class="citation"
data-cites="Draine+Goodman_1993"></span>. GKDLDR is the lattice
dispersion relation result of <span class="citation"
data-cites="Gutkowicz-Krusin+Draine_2004"></span>. Results are shown as
a function of scattering parameter <span class="math inline">\(x=2\pi
a/\lambda\)</span>; the upper scale gives values of <span
class="math inline">\(|m|kd\)</span>. We see that the cross sections
calculated with these two prescriptions are quite similar for <span
class="math inline">\(|m|kd\lower.5ex\hbox{$\; \buildrel &lt; \over \sim
\;$}0.5\)</span>. For other examples see <span class="citation"
data-cites="Gutkowicz-Krusin+Draine_2004"></span>. </figcaption>
</figure>
</div>
<h1 id="dielectric-functions">Dielectric Functions<span
id="sec:dielectric_func" label="sec:dielectric_func"></span></h1>
<p>In order to assign the appropriate dipole polarizabilities,
<span><strong>DDSCAT 7.3</strong></span> must be given the refractive
index <span class="math inline">\(m\)</span> or dielectric constant
<span class="math inline">\(\epsilon\)</span> of the material (or
materials) of which the target of interest is composed. This information
is supplied to <span><strong>DDSCAT 7.3</strong></span> through a table
(or tables), read by subroutine <span><code>DIELEC</code></span> in file
<span><code>dielec.f90</code></span>, and providing either the complex
refractive index <span class="math inline">\(m=n+ik\)</span> or complex
dielectric function <span
class="math inline">\(\epsilon=\epsilon_1+i\epsilon_2\)</span> as a
function of wavelength <span class="math inline">\(\lambda\)</span>.
Since <span class="math inline">\(m=\epsilon^{1/2}\)</span>, or <span
class="math inline">\(\epsilon=m^2\)</span>, the user must supply either
<span class="math inline">\(m\)</span> or <span
class="math inline">\(\epsilon\)</span>.</p>
<p><span><strong>DDSCAT 7.3</strong></span> can calculate scattering and
absorption by targets with anisotropic dielectric functions, with
arbitrary orientation of the optical axes relative to the target shape.
See §<a href="#sec:composite anisotropic targets"
data-reference-type="ref"
data-reference="sec:composite anisotropic targets">[sec:composite
anisotropic targets]</a>.</p>
<p>The table containing the dielectric function information should give
<span class="math inline">\(m\)</span> or <span
class="math inline">\(\epsilon\)</span> as a function of the
<span><em>wavelength in vacuo</em></span>.</p>
<p>The table formatting is intended to be quite flexible. The first line
of the table consists of text, up to 80 characters of which will be read
and included in the output to identify the choice of dielectric
function. (For the sample problem, it consists of simply the statement
<span><code>m = 1.33 + 0.01i</code></span>.) The second line consists of
5 integers; either the second and third <span><em>or</em></span> the
fourth and fifth should be zero.</p>
<ul>
<li><p>The first integer specifies which column the wavelength is stored
in.</p></li>
<li><p>The second integer specifies which column Re<span
class="math inline">\((m)\)</span> is stored in.</p></li>
<li><p>The third integer specifies which column Im<span
class="math inline">\((m)\)</span> is stored in.</p></li>
<li><p>The fourth integer specifies which column Re<span
class="math inline">\((\epsilon)\)</span> is stored in.</p></li>
<li><p>The fifth integer specifies which column Im<span
class="math inline">\((\epsilon)\)</span> is stored in.</p></li>
</ul>
<p>If the second and third integers are zeros, then
<span><code>DIELEC</code></span> will read Re<span
class="math inline">\((\epsilon)\)</span> and Im<span
class="math inline">\((\epsilon)\)</span> from the file; if the fourth
and fifth integers are zeros, then Re<span
class="math inline">\((m)\)</span> and Im<span
class="math inline">\((m)\)</span> will be read from the file.</p>
<p>The third line of the file is used for column headers, and the data
begins in line 4. <span><em>There must be at least 3 lines of
data:</em></span> even if <span class="math inline">\(m\)</span> or
<span class="math inline">\(\epsilon\)</span> is required at only one
wavelength, please supply two additional “dummy” wavelength entries in
the table so that the interpolation apparatus will not be confused.</p>
<p>As discussed in §<a href="#sec:target_in_medium"
data-reference-type="ref" data-reference="sec:target_in_medium">3.2</a>,
<span><strong>DDSCAT</strong></span> can scattering for targets embedded
in dielectric media. The refractive index of the ambient medium is
specified by the value of <span><code>NAMBIENT</code></span> in the
parameter file <span><code>ddscat.par</code></span> (see §<a
href="#sec:nambient" data-reference-type="ref"
data-reference="sec:nambient">[sec:nambient]</a>).</p>
<p>Here is an example of a refractive index file for Au:</p>
<pre><code>Gold, evaporated (Johnson &amp; Christy 1972, PRB 6, 4370)
1 2 3 0 0 = columns for wave, Re(n), Im(n), eps1, eps2
wave(um) Re(n)  Im(n)   eps1   eps2
0.5486   0.43   2.455   -5.84  2.11
0.5209   0.62   2.081   -3.95  2.58
0.4959   1.04   1.833   -2.28  3.81
0.4714   1.31   1.849   -1.70  4.84
0.4509   1.38   1.914   -1.76  5.28
0.4305   1.45   1.948   -1.69  5.65
0.4133   1.46   1.958   -1.70  5.72
0.3974   1.47   1.952   -1.65  5.74
0.3815   1.46   1.933   -1.60  5.64
0.3679   1.48   1.895   -1.40  5.61
0.3542   1.50   1.866   -1.23  5.60
0.3425   1.48   1.871   -1.31  5.54
0.3315   1.48   1.883   -1.36  5.57
0.3204   1.54   1.898   -1.23  5.85
0.3107   1.53   1.893   -1.24  5.79
0.3009   1.53   1.889   -1.23  5.78</code></pre>
<h1
id="calculation-of-langlecosthetarangle-radiative-force-and-radiation-torque">Calculation
of <span class="math inline">\(\langle\cos\theta\rangle\)</span>,
Radiative Force, and Radiation Torque <span
id="sec:force and torque calculation"
label="sec:force and torque calculation"></span></h1>
<p>In addition to solving the scattering problem for a dipole array,
<span><strong>DDSCAT</strong></span> can compute the three-dimensional
force <span class="math inline">\({\bf F}_{\rm rad}\)</span> and torque
<span class="math inline">\({\bf \Gamma}_{\rm rad}\)</span> exerted on
this array by the incident and scattered radiation fields. The radiation
torque calculation is carried out, after solving the scattering problem,
only if <span><code>DOTORQ</code></span> has been specified in
<span><code>ddscat.par</code></span>. For each incident polarization
mode, the results are given in terms of dimensionless efficiency vectors
<span class="math inline">\({\bf Q}_{\rm pr}\)</span> and <span
class="math inline">\({\bf Q}_{\Gamma}\)</span>, defined by <span
class="math display">\[{\bf Q}_{\rm pr} \equiv {{\bf F}_{\rm rad} \over
\pi {a}_{\rm eff}^2 u_{\rm rad}} ~~~,\]</span> <span
class="math display">\[{\bf Q}_\Gamma \equiv {k{\bf \Gamma}_{\rm rad}
\over
\pi {a}_{\rm eff}^2 u_{\rm rad}} ~~~,\]</span> where <span
class="math inline">\({\bf F}_{\rm rad}\)</span> and <span
class="math inline">\({\bf \Gamma}_{\rm rad}\)</span> are the
time-averaged force and torque on the dipole array, <span
class="math inline">\(k=2\pi/\lambda\)</span> is the wavenumber
<span><em>in vacuo</em></span>, and <span class="math inline">\(u_{\rm
rad} = E_0^2/8\pi\)</span> is the time-averaged energy density for an
incident plane wave with amplitude <span class="math inline">\(E_0
\cos(\omega t + \phi)\)</span>. The radiation pressure efficiency vector
can be written <span class="math display">\[{\bf Q}_{\rm pr} = Q_{\rm
ext}{\hat{\bf k}} - Q_{\rm sca}{\bf g} ~~~,\]</span> where <span
class="math inline">\({\hat{\bf k}}\)</span> is the direction of
propagation of the incident radiation, and the vector
<span><strong>g</strong></span> is the mean direction of propagation of
the scattered radiation: <span class="math display">\[\label{eq:gvec}
{\bf g} = {1\over C_{\rm sca}}\int d\Omega
{dC_{\rm sca}({\hat{\bf n}},{\hat{\bf k}})\over d\Omega} {\hat{\bf n}}
~~~,\]</span> where <span class="math inline">\(d\Omega\)</span> is the
element of solid angle in scattering direction <span
class="math inline">\({\hat{\bf n}}\)</span>, and <span
class="math inline">\(dC_{\rm sca}/d\Omega\)</span> is the differential
scattering cross section. The components of <span
class="math inline">\({\bf Q}_{\rm pr}\)</span> are reported in the
Target Frame: <span class="math inline">\(Q_{{\rm pr},1}\equiv {\bf
F}_{\rm rad}\cdot \hat{\bf x}_{\rm TF}\)</span>, <span
class="math inline">\(Q_{{\rm pr},2}\equiv {\bf F}_{\rm rad}\cdot
\hat{\bf y}_{\rm TF}\)</span>, <span class="math inline">\(Q_{{\rm
pr},3}\equiv {\bf F}_{\rm rad}\cdot \hat{\bf z}_{\rm TF}\)</span>.</p>
<p>Equations for the evaluation of the radiative force and torque are
derived by <span class="citation"
data-cites="Draine+Weingartner_1996"></span>. It is important to note
that evaluation of <span class="math inline">\({\bf Q}_{\rm pr}\)</span>
and <span class="math inline">\({\bf Q}_\Gamma\)</span> involves
averaging over scattering directions to evaluate the linear and angular
momentum transport by the scattered wave. This evaluation requires
appropriate choices of the parameter <span><code>ETASCA</code></span> –
see §<a href="#sec:averaging_scattering" data-reference-type="ref"
data-reference="sec:averaging_scattering">[sec:averaging_scattering]</a>.</p>
<p>In addition, <span><strong>DDSCAT</strong></span> calculates <span
class="math inline">\(\langle\cos\theta\rangle\)</span> [the first
component of the vector <span class="math inline">\(g\)</span> in
eq. (<a href="#eq:gvec" data-reference-type="ref"
data-reference="eq:gvec">[eq:gvec]</a>)] and the second moment <span
class="math inline">\(\langle\cos^2\theta\rangle\)</span>. These two
moments are useful measures of the anisotropy of the scattering. For
example, <span class="citation" data-cites="Draine_2003b"></span> gives
an analytic approximation to the scattering phase function of dust
mixtures that is parameterized by the two moments <span
class="math inline">\(\langle\cos\theta\rangle\)</span> and <span
class="math inline">\(\langle\cos^2\theta\rangle\)</span>.</p>
<h1 id="memory-requirements">Memory Requirements <span
id="sec:memory_requirements"
label="sec:memory_requirements"></span></h1>
<p>The memory requirements are determined by the size of the
“computational volume” – this is a rectangular region, of size
<span><code>NX</code></span><span
class="math inline">\(\times\)</span><span><code>NY</code></span><span
class="math inline">\(\times\)</span><span><code>NZ</code></span> that
is large enough to contain the target. If using the
<span><code>GPFAFT</code></span> option, then
<span><code>NX</code></span>, <span><code>NY</code></span>,
<span><code>NZ</code></span> are also required to have only 2,3, and 5
as prime factors (see footnote <a href="#fn:235"
data-reference-type="ref" data-reference="fn:235">12</a>).</p>
<p>In single precision, the memory requirement for <span><strong>DDSCAT
7.3</strong></span> is approximately <span
class="math display">\[(35.+0.0010\times{\tt NX}\times{\tt NY}\times{\tt
NZ}) {\rm ~Mbytes}  
~~~~{\rm for~single~precision}\]</span> <span
class="math display">\[(42+0.0020\times{\tt NX}\times{\tt NY}\times{\tt
NZ}) {\rm ~Mbytes}
~~~~{\rm for~double~precision}\]</span> Thus, in single precision, a
48<span class="math inline">\(\times\)</span>48<span
class="math inline">\(\times\)</span>48 calculation requires <span
class="math inline">\(\sim\)</span>146 MBytes.</p>
<p>The memory is allocated dynamically – once the target has been
created, <span><strong>DDSCAT 7.3</strong></span> will determine just
how much overall memory is needed, and will allocate it. However, the
user must provide information (via <span><code>ddscat.par</code></span>)
to allow <span><strong>DDSCAT 7.3</strong></span> to allocate
sufficiently large arrays to carry out the initial target creation.
Initially, the only arrays that will be allocated are those related to
the target geometry, so it is OK to be quite generous in this initial
allowance, as the memory required for the target generation step is
small compared to the memory required to carry out the full scattering
calculation.</p>
<h1 id="target-geometry-the-target-frame">Target Geometry: The Target
Frame <span id="sec:target geometry"
label="sec:target geometry"></span></h1>
<p>The geometry of the target is specified by the locations of the
lattice sites where polarizable points (“dipoles”) are located. The list
of occupied sites will be generated internally by
<span><strong>DDSCAT</strong></span> if the user selects one of the
“built-in” target geometries, but the user can also use the target
option <span><code>FROM_FILE</code></span> to read in the list of
occupied site locations and composition information.</p>
<p>Every target is defined by a list of “occupied” lattice sites <span
class="math inline">\((i,j,k)_n\)</span>, <span
class="math inline">\(n=1,...,N\)</span>. In the “Target Frame” (TF),
these sites have physical locations <span
class="math inline">\((x,y,z)_n = [(i,j,k)_n + (x_0,y_0,z_0)]\times
d\)</span>, where <span class="math inline">\(d\)</span> is the lattice
constant (in physical units) and <span
class="math inline">\((x_0,y_0,z_0)\)</span> is a vector that gives the
physical location corresponding to <span
class="math inline">\((i,j,k)=(0,0,0)\)</span>. Thus, the vector <span
class="math inline">\({\bf x}_0\)</span> specifies the physical location
of the TF “lattice coordinate” origin <span
class="math inline">\((0,0,0)_{\rm TF}\)</span>. The vector <span
class="math inline">\({\bf x}_0\)</span> is specified for for each of
the “built-in” target geometries. For targets provided externally
through the <span><code>FROM_FILE</code></span> option (see §<a
href="#sec:FROM_FILE" data-reference-type="ref"
data-reference="sec:FROM_FILE">[sec:FROM_FILE]</a>), the “target file”
must include the three components of the vector <span
class="math inline">\({\bf x}_0\)</span>.</p>
<h1 id="target-orientation-1">Target Orientation <span
id="sec:target_orientation" label="sec:target_orientation"></span></h1>
<p>Recall that we define a “Lab Frame” (LF) in which the incident
radiation propagates in the <span class="math inline">\(+x\)</span>
direction. For purposes of discussion we will always let unit vectors
<span class="math inline">\(\hat{\bf x}_{\rm LF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm LF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm LF}=\hat{\bf x}_{\rm
LF}\times\hat{\bf y}_{\rm LF}\)</span> be the three coordinate axes of
the LF.</p>
<p>In <span><code>ddscat.par</code></span> one specifies the first
polarization state <span class="math inline">\({\hat{\bf
e}}_{01}\)</span> (which obviously must lie in the <span
class="math inline">\(y,z\)</span> plane in the LF);
<span><strong>DDSCAT</strong></span> automatically constructs a second
polarization state <span class="math inline">\({\hat{\bf
e}}_{02} = \hat{\bf x}_{\rm LF}\times {\hat{\bf e}}_{01}^*\)</span>
orthogonal to <span class="math inline">\({\hat{\bf e}}_{01}\)</span>.
Users will often find it convenient to let polarization vectors <span
class="math inline">\({\hat{\bf e}}_{01}={\hat{\bf y}}\)</span>, <span
class="math inline">\({\hat{\bf
e}}_{02}={\hat{\bf z}}\)</span> (although this is not mandatory – see
§<a href="#sec:incident_polarization" data-reference-type="ref"
data-reference="sec:incident_polarization">[sec:incident_polarization]</a>).</p>
<div class="center">
<figure>
<img src="f6.png" id="fig:target_orientation"
alt="Target orientation in the Lab Frame. {\hat{\bf x}}=\hat{\bf x}_{\rm LF} is the direction of propagation of the incident radiation, and {\hat{\bf
    y}}=\hat{\bf y}_{\rm LF} is the direction of the real component (at x_{\rm LF}=0, t=0) of the first incident polarization mode. In this coordinate system, the orientation of target axis {\hat{\bf a}}_1 is specified by angles \Theta and \Phi. With target axis {\hat{\bf a}}_1 fixed, the orientation of target axis {\hat{\bf a}}_2 is then determined by angle \beta specifying rotation of the target around {\hat{\bf a}}_1. When \beta=0, {\hat{\bf a}}_2 lies in the {\hat{\bf a}}_1,\hat{\bf x}_{\rm LF} plane. " />
<figcaption aria-hidden="true">Target orientation in the Lab Frame.
<span class="math inline">\({\hat{\bf x}}=\hat{\bf x}_{\rm LF}\)</span>
is the direction of propagation of the incident radiation, and <span
class="math inline">\({\hat{\bf
    y}}=\hat{\bf y}_{\rm LF}\)</span> is the direction of the real
component (at <span class="math inline">\(x_{\rm LF}=0\)</span>, <span
class="math inline">\(t=0\)</span>) of the first incident polarization
mode. In this coordinate system, the orientation of target axis <span
class="math inline">\({\hat{\bf a}}_1\)</span> is specified by angles
<span class="math inline">\(\Theta\)</span> and <span
class="math inline">\(\Phi\)</span>. With target axis <span
class="math inline">\({\hat{\bf a}}_1\)</span> fixed, the orientation of
target axis <span class="math inline">\({\hat{\bf a}}_2\)</span> is then
determined by angle <span class="math inline">\(\beta\)</span>
specifying rotation of the target around <span
class="math inline">\({\hat{\bf a}}_1\)</span>. When <span
class="math inline">\(\beta=0\)</span>, <span
class="math inline">\({\hat{\bf a}}_2\)</span> lies in the <span
class="math inline">\({\hat{\bf a}}_1\)</span>,<span
class="math inline">\(\hat{\bf x}_{\rm LF}\)</span> plane. </figcaption>
</figure>
</div>
<p>Recall that definition of a target involves specifying two unit
vectors, <span class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span>, which are imagined to be
“frozen” into the target. We require <span
class="math inline">\({\hat{\bf a}}_2\)</span> to be orthogonal to <span
class="math inline">\({\hat{\bf a}}_1\)</span>. Therefore we may define
a “Target Frame" (TF) defined by the three unit vectors <span
class="math inline">\({\hat{\bf a}}_1\)</span>, <span
class="math inline">\({\hat{\bf a}}_2\)</span>, and <span
class="math inline">\({\hat{\bf a}}_3 = {\hat{\bf a}}_1 \times
{\hat{\bf a}}_2\)</span> .</p>
<p>For example, when <span><strong>DDSCAT</strong></span> creates a
32<span class="math inline">\(\times\)</span>24<span
class="math inline">\(\times\)</span>16 rectangular solid, it fixes
<span class="math inline">\({\hat{\bf a}}_1\)</span> to be along the
longest dimension of the solid, and <span
class="math inline">\({\hat{\bf a}}_2\)</span> to be along the
next-longest dimension.</p>
<p><span><strong>Important Note:</strong></span> for periodic targets,
<span><strong>DDSCAT 7.3</strong></span> requires that the periodic
target have <span class="math inline">\({\hat{\bf a}}_1=\hat{\bf x}_{\rm
TF}\)</span> and <span class="math inline">\({\hat{\bf a}}_2=\hat{\bf
y}_{\rm TF}\)</span>.</p>
<p>Orientation of the target relative to the incident radiation can in
principle be determined two ways:</p>
<ol>
<li><p>specifying the direction of <span class="math inline">\({\hat{\bf
a}}_1\)</span> and <span class="math inline">\({\hat{\bf a}}_2\)</span>
in the LF, or</p></li>
<li><p>specifying the directions of <span class="math inline">\(\hat{\bf
x}_{\rm LF}\)</span> (incidence direction) and <span
class="math inline">\(\hat{\bf y}_{\rm LF}\)</span> in the TF.</p></li>
</ol>
<p><span><strong>DDSCAT</strong></span> uses method 1.: the angles <span
class="math inline">\(\Theta\)</span>, <span
class="math inline">\(\Phi\)</span>, and <span
class="math inline">\(\beta\)</span> are specified in the file
<span><code>ddscat.par</code></span>. The target is oriented such that
the polar angles <span class="math inline">\(\Theta\)</span> and <span
class="math inline">\(\Phi\)</span> specify the direction of <span
class="math inline">\({\hat{\bf a}}_1\)</span> relative to the incident
direction <span class="math inline">\(\hat{\bf x}_{\rm LF}\)</span>,
where the <span class="math inline">\(\hat{\bf x}_{\rm
LF}\)</span>,<span class="math inline">\(\hat{\bf y}_{\rm LF}\)</span>
plane has <span class="math inline">\(\Phi=0\)</span>. Once the
direction of <span class="math inline">\({\hat{\bf a}}_1\)</span> is
specified, the angle <span class="math inline">\(\beta\)</span> then
specifies how the target is to rotated around the axis <span
class="math inline">\({\hat{\bf a}}_1\)</span> to fully specify its
orientation. A more extended and precise explanation follows:</p>
<h2 id="orientation-of-the-target-in-the-lab-frame"> Orientation of the
Target in the Lab Frame</h2>
<p>DDSCAT uses three angles, <span
class="math inline">\(\Theta\)</span>, <span
class="math inline">\(\Phi\)</span>, and <span
class="math inline">\(\beta\)</span>, to specify the directions of unit
vectors <span class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span> in the LF (see Fig. <a
href="#fig:target_orientation" data-reference-type="ref"
data-reference="fig:target_orientation">7</a>).</p>
<p><span class="math inline">\(\Theta\)</span> is the angle between
<span class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\(\hat{\bf x}_{\rm LF}\)</span>.</p>
<p>When <span class="math inline">\(\Phi=0\)</span>, <span
class="math inline">\({\hat{\bf a}}_1\)</span> will lie in the <span
class="math inline">\(\hat{\bf x}_{\rm LF},\hat{\bf y}_{\rm LF}\)</span>
plane. When <span class="math inline">\(\Phi\)</span> is nonzero, it
will refer to the rotation of <span class="math inline">\({\hat{\bf
a}}_1\)</span> around <span class="math inline">\(\hat{\bf x}_{\rm
LF}\)</span>: e.g., <span class="math inline">\(\Phi=90^\circ\)</span>
puts <span class="math inline">\({\hat{\bf a}}_1\)</span> in the <span
class="math inline">\(\hat{\bf x}_{\rm LF},\hat{\bf z}_{\rm LF}\)</span>
plane.</p>
<p>When <span class="math inline">\(\beta=0\)</span>, <span
class="math inline">\({\hat{\bf a}}_2\)</span> will lie in the <span
class="math inline">\(\hat{\bf x}_{\rm LF},{\hat{\bf a}}_1\)</span>
plane, in such a way that when <span
class="math inline">\(\Theta=0\)</span> and <span
class="math inline">\(\Phi=0\)</span>, <span
class="math inline">\({\hat{\bf a}}_2\)</span> is in the <span
class="math inline">\(\hat{\bf y}_{\rm LF}\)</span> direction: e.g,
<span class="math inline">\(\Theta=90^\circ\)</span>, <span
class="math inline">\(\Phi=0\)</span>, <span
class="math inline">\(\beta=0\)</span> has <span
class="math inline">\({\hat{\bf a}}_1=\hat{\bf y}_{\rm LF}\)</span> and
<span class="math inline">\({\hat{\bf a}}_2=-\hat{\bf x}_{\rm
LF}\)</span>. Nonzero <span class="math inline">\(\beta\)</span>
introduces an additional rotation of <span
class="math inline">\({\hat{\bf a}}_2\)</span> around <span
class="math inline">\({\hat{\bf a}}_1\)</span>: e.g., <span
class="math inline">\(\Theta=90^\circ\)</span>, <span
class="math inline">\(\Phi=0\)</span>, <span
class="math inline">\(\beta=90^\circ\)</span> has <span
class="math inline">\({\hat{\bf a}}_1=\hat{\bf y}_{\rm LF}\)</span> and
<span class="math inline">\({\hat{\bf a}}_2=\hat{\bf z}_{\rm
LF}\)</span>.</p>
<p>Mathematically: <span class="math display">\[\begin{aligned}
{\hat{\bf a}}_1 &amp;=&amp;   \hat{\bf x}_{\rm LF}\cos\Theta
+ \hat{\bf y}_{\rm LF}\sin\Theta \cos\Phi
+ \hat{\bf z}_{\rm LF}\sin\Theta \sin\Phi
    \\
{\hat{\bf a}}_2 &amp;=&amp; - \hat{\bf x}_{\rm LF}\sin\Theta \cos\beta
+ \hat{\bf y}_{\rm LF}[\cos\Theta \cos\beta \cos\Phi-\sin\beta \sin\Phi]
\nonumber\\
&amp;&amp;+ \hat{\bf z}_{\rm LF}[\cos\Theta \cos\beta \sin\Phi+\sin\beta
\cos\Phi]
    \\
{\hat{\bf a}}_3 &amp;=&amp;   \hat{\bf x}_{\rm LF}\sin\Theta \sin\beta
- \hat{\bf y}_{\rm LF}[\cos\Theta \sin\beta \cos\Phi+\cos\beta \sin\Phi]
\nonumber\\
  &amp;&amp;         - \hat{\bf z}_{\rm LF}[\cos\Theta \sin\beta
\sin\Phi-\cos\beta \cos\Phi]
\end{aligned}\]</span> or, equivalently: <span
class="math display">\[\begin{aligned}
\hat{\bf x}_{\rm LF}&amp;=&amp;   {\hat{\bf a}}_1 \cos\Theta
           - {\hat{\bf a}}_2 \sin\Theta \cos\beta
           + {\hat{\bf a}}_3 \sin\Theta \sin\beta \\
\hat{\bf y}_{\rm LF}&amp;=&amp;   {\hat{\bf a}}_1 \sin\Theta \cos\Phi
           + {\hat{\bf a}}_2 [\cos\Theta \cos\beta \cos\Phi-\sin\beta
\sin\Phi]
\nonumber\\
&amp;&amp;         - {\hat{\bf a}}_3 [\cos\Theta \sin\beta
\cos\Phi+\cos\beta \sin\Phi]
\\
\hat{\bf z}_{\rm LF}&amp;=&amp;   {\hat{\bf a}}_1 \sin\Theta \sin\Phi
           + {\hat{\bf a}}_2 [\cos\Theta \cos\beta \sin\Phi+\sin\beta
\cos\Phi]
\nonumber\\
&amp;&amp;         - {\hat{\bf a}}_3 [\cos\Theta \sin\beta
\sin\Phi-\cos\beta \cos\Phi]
\end{aligned}\]</span></p>
<h2 id="orientation-of-the-incident-beam-in-the-target-frame">
Orientation of the Incident Beam in the Target Frame</h2>
<p>Under some circumstances, one may wish to specify the target
orientation such that <span class="math inline">\(\hat{\bf x}_{\rm
LF}\)</span> (the direction of propagation of the radiation) and <span
class="math inline">\(\hat{\bf y}_{\rm LF}\)</span> (usually the first
polarization direction) and <span class="math inline">\(\hat{\bf z}_{\rm
LF}\)</span> (= <span class="math inline">\(\hat{\bf x}_{\rm LF}\times
\hat{\bf y}_{\rm LF}\)</span>) refer to certain directions in the TF.
Given the definitions of the LF and TF above, this is simply an exercise
in coordinate transformation. For example, one might wish to have the
incident radiation propagating along the (1,1,1) direction in the TF
(example 14 below). Here we provide some selected examples:</p>
<ol>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}= {\hat{\bf
a}}_1\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_2\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}= {\hat{\bf a}}_3\)</span> : <span
class="math inline">\(\Theta=  0\)</span>, <span
class="math inline">\(\Phi+\beta= 0\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}= {\hat{\bf
a}}_1\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_3\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=-{\hat{\bf a}}_2\)</span> : <span
class="math inline">\(\Theta=  0\)</span>, <span
class="math inline">\(\Phi+\beta= -90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}= {\hat{\bf
a}}_2\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_1\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=-{\hat{\bf a}}_3\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=180^\circ\)</span>,
<span class="math inline">\(\Phi=  0\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}= {\hat{\bf
a}}_2\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_3\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}= {\hat{\bf a}}_1\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=180^\circ\)</span>,
<span class="math inline">\(\Phi= 90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}= {\hat{\bf
a}}_3\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_1\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}= {\hat{\bf a}}_2\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=90^\circ\)</span>,
<span class="math inline">\(\Phi=  0\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}= {\hat{\bf
a}}_3\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_2\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=-{\hat{\bf a}}_1\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=90^\circ\)</span>,
<span class="math inline">\(\Phi=-90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=-{\hat{\bf
a}}_1\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_2\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=-{\hat{\bf a}}_3\)</span> : <span
class="math inline">\(\Theta=180^\circ\)</span>, <span
class="math inline">\(\beta-\Phi=180^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=-{\hat{\bf
a}}_1\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_3\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}= {\hat{\bf a}}_2\)</span> : <span
class="math inline">\(\Theta=180^\circ\)</span>, <span
class="math inline">\(\beta-\Phi= 90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=-{\hat{\bf
a}}_2\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_1\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}= {\hat{\bf a}}_3\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=  0\)</span>, <span
class="math inline">\(\Phi=  0\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=-{\hat{\bf
a}}_2\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_3\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=-{\hat{\bf a}}_1\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=  0\)</span>, <span
class="math inline">\(\Phi=-90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=-{\hat{\bf
a}}_3\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_1\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=-{\hat{\bf a}}_2\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=-90^\circ\)</span>,
<span class="math inline">\(\Phi=  0\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=-{\hat{\bf
a}}_3\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm LF}=
{\hat{\bf a}}_2\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}= {\hat{\bf a}}_1\)</span> : <span class="math inline">\(\Theta=
90^\circ\)</span>, <span class="math inline">\(\beta=-90^\circ\)</span>,
<span class="math inline">\(\Phi= 90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=({\hat{\bf
a}}_1+{\hat{\bf a}}_2)/\surd2\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm LF}={\hat{\bf a}}_3\)</span>,
<span class="math inline">\(\hat{\bf z}_{\rm LF}=({\hat{\bf
a}}_1-{\hat{\bf a}}_2)/\surd2\)</span> : <span
class="math inline">\(\Theta=45^\circ\)</span>, <span
class="math inline">\(\beta=180^\circ\)</span>, <span
class="math inline">\(\Phi=90^\circ\)</span></p></li>
<li><p><span class="math inline">\(\hat{\bf x}_{\rm LF}=({\hat{\bf
a}}_1+{\hat{\bf a}}_2+{\hat{\bf a}}_3)/\surd3\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm LF}=({\hat{\bf a}}_1-{\hat{\bf
a}}_2)/\surd2\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm
LF}=({\hat{\bf a}}_1+{\hat{\bf a}}_2-2{\hat{\bf a}}_3)/\surd6\)</span>
:<br />
<span class="math inline">\(\Theta=54.7356^\circ\)</span>, <span
class="math inline">\(\beta=135^\circ\)</span>, <span
class="math inline">\(\Phi=30^\circ\)</span>.</p></li>
</ol>
<h2 id="sampling-in-theta-phi-and-beta"> Sampling in <span
class="math inline">\(\Theta\)</span>, <span
class="math inline">\(\Phi\)</span>, and <span
class="math inline">\(\beta\)</span><span id="subsec:sampling"
label="subsec:sampling"></span></h2>
<p>The present version, <span><strong>DDSCAT 7.3</strong></span>,
chooses the angles <span class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> to sample the intervals
(<span><code>BETAMI,BETAMX</code></span>),
(<span><code>THETMI,THETMX)</code></span>,
(<span><code>PHIMIN,PHIMAX</code></span>), where
<span><code>BETAMI</code></span>, <span><code> BETAMX</code></span>,
<span><code>THETMI</code></span>, <span><code>THETMX</code></span>,
<span><code>PHIMIN</code></span>, <span><code>PHIMAX</code></span> are
specified in <span><code>ddscat.par</code></span> . The prescription for
choosing the angles is to:</p>
<ul>
<li><p>uniformly sample in <span
class="math inline">\(\beta\)</span>;</p></li>
<li><p>uniformly sample in <span
class="math inline">\(\Phi\)</span>;</p></li>
<li><p>uniformly sample in <span
class="math inline">\(\cos\Theta\)</span>.</p></li>
</ul>
<p>This prescription is appropriate for random orientation of the
target, within the specified limits of <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Phi\)</span>, and <span
class="math inline">\(\Theta\)</span>.</p>
<p>Note that when <span><strong>DDSCAT 7.3</strong></span> chooses
angles it handles <span class="math inline">\(\beta\)</span> and <span
class="math inline">\(\Phi\)</span> differently from <span
class="math inline">\(\Theta\)</span>. The range for <span
class="math inline">\(\beta\)</span> is divided into
<span><code>NBETA</code></span> intervals, and the midpoint of each
interval is taken. Thus, if you take
<span><code> BETAMI</code></span>=0,
<span><code>BETAMX</code></span>=90, <span><code>NBETA</code></span>=2
you will get <span class="math inline">\(\beta=22.5^\circ\)</span> and
<span class="math inline">\(67.5^\circ\)</span>. Similarly, if you take
<span><code>PHIMIN</code></span>=0,
<span><code>PHIMAX</code></span>=180, <span><code>NPHI</code></span>=2
you will get <span class="math inline">\(\Phi=45^\circ\)</span> and
<span class="math inline">\(135^\circ\)</span>.</p>
<p>Sampling in <span class="math inline">\(\Theta\)</span> is done quite
differently from sampling in <span class="math inline">\(\beta\)</span>
and <span class="math inline">\(\Phi\)</span>. First, as already
mentioned above, <span><strong>DDSCAT 7.3</strong></span> samples
uniformly in <span class="math inline">\(\cos\Theta\)</span>, not <span
class="math inline">\(\Theta\)</span>. Secondly, the sampling depends on
whether <span><code>NTHETA</code></span> is even or odd.</p>
<ul>
<li><p>If <span><code>NTHETA</code></span> is odd, then the values of
<span class="math inline">\(\Theta\)</span> selected include the extreme
values <span><code>THETMI</code></span> and
<span><code>THETMX</code></span>; thus,
<span><code>THETMI</code></span>=0, <span><code>THETMX</code></span>=90,
<span><code>NTHETA</code></span>=3 will give you <span
class="math inline">\(\Theta=0,60^\circ,90^\circ\)</span>.</p></li>
<li><p>If <span><code>NTHETA</code></span> is even, then the range of
<span class="math inline">\(\cos\Theta\)</span> will be divided into
<span><code>NTHETA</code></span> intervals, and the midpoint of each
interval will be taken; thus, <span><code>THETMI</code></span>=0,
<span><code>THETMX</code></span>=90, <span><code>NTHETA</code></span>=2
will give you <span class="math inline">\(\Theta=41.41^\circ\)</span>
and <span class="math inline">\(75.52^\circ\)</span> [<span
class="math inline">\(\cos\Theta=0.25\)</span> and <span
class="math inline">\(0.75\)</span>].</p></li>
</ul>
<p>The reason for this is that if odd <span><code>NTHETA</code></span>
is specified, then the “integration” over <span
class="math inline">\(\cos\Theta\)</span> is performed using Simpson’s
rule for greater accuracy. If even <span><code>NTHETA</code></span> is
specified, then the integration over <span
class="math inline">\(\cos\Theta\)</span> is performed by simply taking
the average of the results for the different <span
class="math inline">\(\Theta\)</span> values.</p>
<p>If averaging over orientations is desired, it is recommended that the
user specify an <span><em>odd</em></span> value of
<span><code>NTHETA</code></span> so that Simpson’s rule will be
employed.</p>
<h1 id="orientational-averaging">Orientational Averaging<span
id="sec:orientational_averaging"
label="sec:orientational_averaging"></span></h1>
<p><span><strong>DDSCAT</strong></span> has been constructed to
facilitate the computation of orientational averages. How to go about
this depends on the distribution of orientations which is
applicable.</p>
<h2 id="randomly-oriented-targets"> Randomly-Oriented Targets</h2>
<p>For randomly-oriented targets, we wish to compute the orientational
average of a quantity <span
class="math inline">\(Q(\beta,\Theta,\Phi)\)</span>: <span
class="math display">\[\langle Q \rangle = {1\over
8\pi^2}\int_0^{2\pi}d\beta
\int_{-1}^1 d\cos\Theta
\int_0^{2\pi}d\Phi ~ Q(\beta,\Theta,\Phi) ~~~.\]</span> To compute such
averages, all you need to do is edit the file
<span><code> ddscat.par</code></span> so that DDSCAT knows what ranges
of the angles <span class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> are of interest. For a
randomly-oriented target with no symmetry, you would need to let <span
class="math inline">\(\beta\)</span> run from 0 to <span
class="math inline">\(360^\circ\)</span>, <span
class="math inline">\(\Theta\)</span> from 0 to <span
class="math inline">\(180^\circ\)</span>, and <span
class="math inline">\(\Phi\)</span> from 0 to <span
class="math inline">\(360^\circ\)</span>.</p>
<p>For targets with symmetry, on the other hand, the ranges of <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> may be reduced. First of all,
remember that averaging over <span class="math inline">\(\Phi\)</span>
is relatively “inexpensive", so when in doubt average over 0 to <span
class="math inline">\(360^\circ\)</span>; most of the computational
“cost" is associated with the number of different values of (<span
class="math inline">\(\beta\)</span>,<span
class="math inline">\(\Theta\)</span>) which are used. Consider a cube,
for example, with axis <span class="math inline">\({\hat{\bf
a}}_1\)</span> normal to one of the cube faces; for this cube <span
class="math inline">\(\beta\)</span> need run only from 0 to <span
class="math inline">\(90^\circ\)</span>, since the cube has fourfold
symmetry for rotations around the axis <span
class="math inline">\({\hat{\bf a}}_1\)</span>. Furthermore, the angle
<span class="math inline">\(\Theta\)</span> need run only from 0 to
<span class="math inline">\(90^\circ\)</span>, since the orientation
(<span class="math inline">\(\beta\)</span>,<span
class="math inline">\(\Theta\)</span>,<span
class="math inline">\(\Phi\)</span>) is indistinguishable from (<span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(180^\circ-\Theta\)</span>, <span
class="math inline">\(360^\circ-\Phi\)</span>).</p>
<p>For targets with symmetry, the user is encouraged to test the
significance of <span class="math inline">\(\beta\)</span>,<span
class="math inline">\(\Theta\)</span>,<span
class="math inline">\(\Phi\)</span> on targets with small numbers of
dipoles (say, of the order of 100 or so) but having the desired
symmetry.</p>
<h2 id="nonrandomly-oriented-targets"> Nonrandomly-Oriented Targets</h2>
<p>Some special cases (where the target orientation distribution is
uniform for rotations around the <span class="math inline">\(x\)</span>
axis = direction of propagation of the incident radiation), one may be
able to use <span><strong>DDSCAT 7.3</strong></span> with appropriate
choices of input parameters. More generally, however, you will need to
modify subroutine <span><code>ORIENT</code></span> to generate a list of
<span><code>NBETA</code></span> values of <span
class="math inline">\(\beta\)</span>, <span><code>NTHETA</code></span>
values of <span class="math inline">\(\Theta\)</span>, and
<span><code>NPHI</code></span> values of <span
class="math inline">\(\Phi\)</span>, plus two weighting arrays
<span><code>WGTA(1-NTHETA,1-NPHI)</code></span> and
<span><code>WGTB(1-NBETA)</code></span>. Here
<span><code>WGTA</code></span> gives the weights which should be
attached to each (<span class="math inline">\(\Theta\)</span>,<span
class="math inline">\(\Phi\)</span>) orientation, and
<span><code>WGTB</code></span> gives the weight to be attached to each
<span class="math inline">\(\beta\)</span> orientation. Thus each
orientation of the target is to be weighted by the factor
<span><code>WGTA</code></span><span
class="math inline">\(\times\)</span><span><code>WGTB</code></span>. For
the case of random orientations,
<span><strong>DDSCAT</strong></span> chooses <span
class="math inline">\(\Theta\)</span> values which are uniformly spaced
in <span class="math inline">\(\cos\Theta\)</span>, and <span
class="math inline">\(\beta\)</span> and <span
class="math inline">\(\Phi\)</span> values which are uniformly spaced,
and therefore uses uniform
weights=1./<span><code> NBETA</code></span></p>
<p>When <span><code>NTHETA</code></span> is even,
<span><strong>DDSCAT</strong></span> sets
=1./(<span><code>NTHETA</code></span><span
class="math inline">\(\times\)</span><span><code> NPHI</code></span>)</p>
<p>but when <span><code>NTHETA</code></span> is odd,
<span><strong>DDSCAT</strong></span> uses Simpson’s rule when
integrating over <span class="math inline">\(\Theta\)</span> and
<span><code>WGTA</code></span>= (1/3 or 4/3 or
2/3)/(<span><code>NTHETA</code></span><span
class="math inline">\(\times\)</span><span><code>NPHI</code></span>)</p>
<p>Note that the program structure of
<span><strong>DDSCAT</strong></span> may not be ideally suited for
certain highly oriented cases. If, for example, the orientation is such
that for a given <span class="math inline">\(\Phi\)</span> value only
one <span class="math inline">\(\Theta\)</span> value is possible (this
situation might describe ice needles oriented with the long axis
perpendicular to the vertical in the Earth’s atmosphere, illuminated by
the Sun at other than the zenith) then it is foolish to consider all the
combinations of <span class="math inline">\(\Theta\)</span> and <span
class="math inline">\(\Phi\)</span> which the present version of
<span><strong>DDSCAT</strong></span> is set up to do. We hope to improve
this in a future version of <span><strong>DDSCAT</strong></span>.</p>
<h1 id="target-generation-isolated-finite-targets">Target Generation:
Isolated Finite Targets <span id="sec:target_generation"
label="sec:target_generation"></span></h1>
<p>DDSCAT contains routines to generate dipole arrays representing
finite targets of various geometries, including spheres, ellipsoids,
rectangular solids, cylinders, hexagonal prisms, tetrahedra, two
touching ellipsoids, and three touching ellipsoids. The target type is
specified by variable <span><code>CSHAPE</code></span> on line 9 of
<span><code>ddscat.par</code></span>, up to 12 target shape parameters
(<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span>,
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>,
<span><code> SHPAR</code></span><span class="math inline">\(_3\)</span>,
...) on line 10. The target geometry is most conveniently described in a
coordinate system attached to the target which we refer to as the
“Target Frame” (TF), with orthonormal unit vectors <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm TF}\equiv\hat{\bf x}_{\rm
TF}\times\hat{\bf y}_{\rm TF}\)</span>. Once the target is generated,
the orientation of the target in the Lab Frame is accomplished as
described in §<a href="#sec:target_orientation"
data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>.</p>
<p>Every target generation routine will specify</p>
<ul>
<li><p>The “occupied” lattice sites;</p></li>
<li><p>The composition associated with each occupied lattice
site;</p></li>
<li><p>Two “target axes” <span class="math inline">\(\hat{\bf
a}_1\)</span> and <span class="math inline">\(\hat{\bf a}_2\)</span>
that are used as references when specifying the target orientation;
and</p></li>
<li><p>The location of the Target Frame origin of coordinates.</p></li>
</ul>
<p>Target geometries currently supported include:</p>
<ul>
<li><p><span><strong>FROM_FILE</strong></span> : isotropic target
material(s), geometry read from file (§<a href="#sec:FROM_FILE"
data-reference-type="ref"
data-reference="sec:FROM_FILE">[sec:FROM_FILE]</a>)</p></li>
<li><p><span><strong>ANIFRMFIL</strong></span> : anisotropic target
material(s), geometry read from file (§<a href="#sec:ANIFRMFIL"
data-reference-type="ref"
data-reference="sec:ANIFRMFIL">[sec:ANIFRMFIL]</a>)</p></li>
<li><p><span><strong>ANIELLIPS</strong></span> : anisotropic ellipsoid
(§<a href="#sec:ANIELLIPS" data-reference-type="ref"
data-reference="sec:ANIELLIPS">[sec:ANIELLIPS]</a>)</p></li>
<li><p><span><strong>ANI_ELL_2</strong></span> : two touching
anisotropic ellipsoids (single composition) (§<a href="#sec:ANI_ELL_2"
data-reference-type="ref"
data-reference="sec:ANI_ELL_2">[sec:ANI_ELL_2]</a>)</p></li>
<li><p><span><strong>ANI_ELL_3</strong></span> : three touching
anisotropic ellipsoids (single composition) (§<a href="#sec:ANI_ELL_3"
data-reference-type="ref"
data-reference="sec:ANI_ELL_3">[sec:ANI_ELL_3]</a>)</p></li>
<li><p><span><strong>ANIRCTNGL</strong></span> : anisotropic brick (§<a
href="#sec:ANIRCTNGL" data-reference-type="ref"
data-reference="sec:ANIRCTNGL">[sec:ANIRCTNGL]</a>)</p></li>
<li><p><span><strong>CONELLIPS</strong></span> : two concentric
ellipsoids) (§<a href="#sec:CONELLIPS" data-reference-type="ref"
data-reference="sec:CONELLIPS">[sec:CONELLIPS]</a>)</p></li>
<li><p><span><strong>CYLINDER1</strong></span> : finite cylinder (§<a
href="#sec:CYLINDER1" data-reference-type="ref"
data-reference="sec:CYLINDER1">[sec:CYLINDER1]</a>)</p></li>
<li><p><span><strong>CYLNDRCAP</strong></span> : cylinder with
hemispherical end-caps (§<a href="#sec:CYLNDRCAP"
data-reference-type="ref"
data-reference="sec:CYLNDRCAP">[sec:CYLNDRCAP]</a>)</p></li>
<li><p><span><strong>DSKRCTNGL</strong></span> : disk resting on a brick
(§<a href="#sec:DSKRCTNGL" data-reference-type="ref"
data-reference="sec:DSKRCTNGL">[sec:DSKRCTNGL]</a>)</p></li>
<li><p><span><strong>DW1996TAR</strong></span> : 13-block target used by
<span class="citation" data-cites="Draine+Weingartner_1996"></span> (§<a
href="#sec:DW1996TAR" data-reference-type="ref"
data-reference="sec:DW1996TAR">[sec:DW1996TAR]</a>)</p></li>
<li><p><span><strong>ELLIPSOID</strong></span> : ellipsoid (including
spheroid and sphere) (§<a href="#sec:ELLIPSOID"
data-reference-type="ref"
data-reference="sec:ELLIPSOID">[sec:ELLIPSOID]</a>)</p></li>
<li><p><span><strong>ELLIPSO_2</strong></span> : two touching
ellipsoids, different compositions allowed (§<a href="#sec:ELLIPSO_2"
data-reference-type="ref"
data-reference="sec:ELLIPSO_2">[sec:ELLIPSO_2]</a>)</p></li>
<li><p><span><strong>ELLIPSO_3</strong></span> : three touching
ellipsoids, different compositions allowed (§<a href="#sec:ELLIPSO_3"
data-reference-type="ref"
data-reference="sec:ELLIPSO_3">[sec:ELLIPSO_3]</a>)</p></li>
<li><p><span><strong>HEX_PRISM</strong></span> : finite hexagonal prism
(§<a href="#sec:HEX_PRISM" data-reference-type="ref"
data-reference="sec:HEX_PRISM">[sec:HEX_PRISM]</a>)</p></li>
<li><p><span><strong>LAYRDSLAB</strong></span> : multilayer rectangular
slab (§<a href="#sec:LAYRDSLAB" data-reference-type="ref"
data-reference="sec:LAYRDSLAB">[sec:LAYRDSLAB]</a>)</p></li>
<li><p><span><strong>MLTBLOCKS</strong></span> : collection of cubic
blocks (§<a href="#sec:MLTBLOCKS" data-reference-type="ref"
data-reference="sec:MLTBLOCKS">[sec:MLTBLOCKS]</a>)</p></li>
<li><p><span><strong>RCTGLPRSM</strong></span> : rectangular prism
(i.e., brick) (§<a href="#sec:RCTGLPRSM" data-reference-type="ref"
data-reference="sec:RCTGLPRSM">[sec:RCTGLPRSM]</a>)</p></li>
<li><p><span><strong>RCTGLBLK3</strong></span> : stack of 3 rectangular
blocks (§<a href="#sec:RCTGLBLK3" data-reference-type="ref"
data-reference="sec:RCTGLBLK3">[sec:RCTGLBLK3]</a>)</p></li>
<li><p><span><strong>SLAB_HOLE</strong></span> : rectangular slab with
cylindrical hole (§<a href="#sec:SLAB_HOLE" data-reference-type="ref"
data-reference="sec:SLAB_HOLE">[sec:SLAB_HOLE]</a>)</p></li>
<li><p><span><strong>SPHERES_N</strong></span> : collection of N spheres
(§<a href="#sec:SPHERES_N" data-reference-type="ref"
data-reference="sec:SPHERES_N">[sec:SPHERES_N]</a>)</p></li>
<li><p><span><strong>SPHROID_2</strong></span> : two touching spheroids,
different compositions allowed (§<a href="#sec:SPHROID_2"
data-reference-type="ref"
data-reference="sec:SPHROID_2">[sec:SPHROID_2]</a>)</p></li>
<li><p><span><strong>SPH_ANI_N</strong></span> : collection of N
anisotropic spheres (§<a href="#sec:SPH_ANI_N" data-reference-type="ref"
data-reference="sec:SPH_ANI_N">[sec:SPH_ANI_N]</a>)</p></li>
<li><p><span><strong>TETRAHDRN</strong></span> : tetrahedron (§<a
href="#sec:TETRAHDRN" data-reference-type="ref"
data-reference="sec:TETRAHDRN">[sec:TETRAHDRN]</a>)</p></li>
<li><p><span><strong>TRNGLPRSM</strong></span> : triangular prism (§<a
href="#sec:TRNGLPRSM" data-reference-type="ref"
data-reference="sec:TRNGLPRSM">[sec:TRNGLPRSM]</a>)</p></li>
<li><p><span><strong>UNIAXICYL</strong></span> : finite cylinder of
uniaxial material (§<a href="#sec:UNIAXICYL" data-reference-type="ref"
data-reference="sec:UNIAXICYL">[sec:UNIAXICYL]</a>)</p></li>
</ul>
<p>Each is described below.</p>
<h2
id="from_file-target-composed-of-possibly-anisotropic-material-defined-by-list-of-dipole-locations-and-compositions-obtained-from-a-file">
FROM_FILE = Target composed of possibly anisotropic material, defined by
list of dipole locations and “compositions” obtained from a file <span
id="sec:FROM_FILE" label="sec:FROM_FILE"></span></h2>
<p>If anisotropic, the “microcrystals” in the target are assumed to be
aligned with the principal axes of the dielectric tensor parallel to
<span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, and <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>. This option causes
<span><strong>DDSCAT</strong></span> to read the target geometry and
composition information from a file <span><code>shape.dat</code></span>
instead of automatically generating one of the geometries for which
DDSCAT has built-in target generation capability. The
<span><code>shape.dat</code></span> file is read by routine
<span><code>REASHP</code></span> (file
<span><code>reashp.f90</code></span>). The file
<span><code>shape.dat</code></span> gives the number <span
class="math inline">\(N\)</span> of dipoles in the target, the
components of the “target axes” <span class="math inline">\(\hat{\bf
a}_1\)</span> and <span class="math inline">\(\hat{\bf a}_2\)</span> in
the Target Frame (TF), the vector <span
class="math inline">\(x_0(1-3)\)</span> determining the correspondence
between the integers <span><code>IXYZ</code></span> and actual
coordinates in the TF, and specifications for the location and
“composition” of each dipole. The user can customize
<span><code>REASHP</code></span> as needed to conform to the manner in
which the target description is stored in file
<span><code>shape.dat</code></span>. However, as supplied,
<span><code>REASHP</code></span> expects the file
<span><code>shape.dat</code></span> to have the following structure:</p>
<ul>
<li><p>one line containing a description; the first 67 characters will
be read and printed in various output statements</p></li>
<li><p><span><code>N</code></span> = number of dipoles in
target</p></li>
<li><p><span class="math inline">\(a_{1x}\)</span> <span
class="math inline">\(a_{1y}\)</span> <span
class="math inline">\(a_{1z}\)</span> = x,y,z components (in TF) of
<span class="math inline">\(\bf{a}_1\)</span></p></li>
<li><p><span class="math inline">\(a_{2x}\)</span> <span
class="math inline">\(a_{2y}\)</span> <span
class="math inline">\(a_{2z}\)</span> = x,y,z components (in TF) of
<span class="math inline">\(\bf{a}_2\)</span></p></li>
<li><p><span class="math inline">\(d_x/d\)</span>  <span
class="math inline">\(d_y/d\)</span>  <span
class="math inline">\(d_z/d\)</span> = 1. 1. 1. = relative spacing of
dipoles in <span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>,
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> directions</p></li>
<li><p><span class="math inline">\(x_{0x}\)</span>  <span
class="math inline">\(x_{0y}\)</span>  <span
class="math inline">\(x_{0z}\)</span> = TF coordinates <span
class="math inline">\(x_{\rm TF}/d\)</span>  <span
class="math inline">\(y_{\rm TF}/d\)</span>  <span
class="math inline">\(z_{\rm TF}/d\)</span> corresponding to lattice
site <span><code>IXYZ</code></span>= 0 0 0</p></li>
<li><p>(line containing comments)</p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(1,1) IXYZ(1,2) IXYZ(1,3) ICOMP(1,1) ICOMP(1,2) ICOMP(1,3)</code></span>
</span></p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(2,1) IXYZ(2,2) IXYZ(2,3) ICOMP(2,1) ICOMP(2,2) ICOMP(2,3)</code></span>
</span></p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(3,1) IXYZ(3,2) IXYZ(3,3) ICOMP(3,1) ICOMP(3,2) ICOMP(3,3)</code></span>
</span></p></li>
<li><p>...</p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(J,1) IXYZ(J,2) IXYZ(J,3) ICOMP(J,1) ICOMP(J,2) ICOMP(J,3)</code></span>
</span></p></li>
<li><p>...</p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(N,1) IXYZ(N,2) IXYZ(N,3) ICOMP(N,1) ICOMP(N,2) ICOMP(N,3)</code></span>
</span></p></li>
</ul>
<p>where <span class="math inline">\(dummy\)</span> is a number (integer
or floating point)that might, for example, identify the dipole. This
number will <span><em>not</em></span> be used in any calculations.<br />
If the target material at location <span><code>J</code></span> is
isotropic, <span><code>ICOMP(J,1)</code></span>,
<span><code>ICOMP(J,2)</code></span>, and
<span><code>ICOMP(J,3)</code></span> have the same value.</p>
<pre><code>--- demo file for target option FROM_FILE (homogeneous,isotropic target) ---
8       = NAT
1.000   0.000   0.000   = target vector a1 (in TF)
0.000   1.000   0.000   = target vector a2 (in TF)
1.      1.      1.      = d_x/d  d_y/d  d_z/d  (normally 1 1 1)
0.5     0.5     0.5      = X0(1-3) = location in lattice of &quot;target origin&quot;
J    JX   JY   JZ  ICOMPX,ICOMPY,ICOMPZ
1     0    0    0   1  1  1
2     0    0    1   1  1  1
3     0    1    0   1  1  1
4     0    1    1   1  1  1
5     1    0    0   1  1  1
6     1    0    1   1  1  1
7     1    1    0   1  1  1
8     1    1    1   1  1  1</code></pre>
<p>The above sample target consists of 8 dipoles arranged to represent a
cube.<br />
This example is homogeneous: All sites have composition 1<br />
The target origin <span><code>X0</code></span> is set to be at the
center of the target<br />
Note that ICOMPX,ICOMPY,ICOMPZ could differ, allowing treatment of
anisotropic targets, provided the dielectric tensor at each location is
diagonal in the TF.</p>
<pre><code>--- demo file for target option FROM_FILE (inhomogeneous, isotropic target) ---
8       = NAT
1.000   0.000   0.000   = target vector a1 (in TF)
0.000   1.000   0.000   = target vector a2 (in TF)
1.      1.      1.      = d_x/d  d_y/d  d_z/d  (normally 1 1 1)
0.5     0.5     0.5      = X0(1-3) = location in lattice of &quot;target origin&quot;
J    JX   JY   JZ  ICOMPX,ICOMPY,ICOMPZ
1     0    0    0   1  1  1
2     0    0    1   1  1  1
3     0    1    0   1  1  1
4     0    1    1   1  1  1
5     1    0    0   2  2  2
6     1    0    1   2  2  2
7     1    1    0   2  2  2
8     1    1    1   2  2  2</code></pre>
<p>This sample target consists of 8 dipoles arranged to represent a
cube.<br />
This example is inhomogeneous: The lower half of the cube (JX=0) has
isotropic composition 1<br />
The upper half of the cube (JX=1) has isotropic composition 2<br />
The target origin <span><code>X0</code></span> is set to be at the
center of the target.<br />
Note that ICOMPX, ICOMPY, ICOMPZ can be different, allowing treatment of
anisotropic targets, provided the dielectric tensor at each location is
diagonal in the TF.</p>
<h3
id="sample-calculation-in-directory-examples_expfrom_file"><strong>Sample
calculation in directory examples_exp/FROM_FILE</strong></h3>
<p>Subdirectory <span><code>examples_exp/FROM_FILE</code></span>
contains <span><code>ddscat.par</code></span> for calculation of
scattering by a <span class="math inline">\(0.5{\mu{\rm
m}}\times1{\mu{\rm m}}\times1{\mu{\rm m}}\)</span> Au block, represented
by a <span class="math inline">\(32\times64\times64 = 131072\)</span>
dipole array, as well as the output files from the calculation. The
target geometry is input via the file
<span><code>shape.dat</code></span>.</p>
<p>This target has <span class="math inline">\(V=0.5{\mu{\rm
m}}^3\)</span>, and <span class="math inline">\({a}_{\rm
eff}=(3V/4\pi)^{1/3}=0.49237{\mu{\rm m}}\)</span>. The calculation is
for an incident wavelength <span
class="math inline">\(\lambda=0.50{\mu{\rm m}}\)</span>; the Au has
refractive index <span class="math inline">\(m=0.9656+1.8628i\)</span>.
The CCG method used is <span><code>PBCGS2</code></span>; the two
orthogonal polarization require 29 and 30 iterations, respectively, to
converge to the specified tolerance
<span><code>TOL = 1e-5</code></span>. The computation used 165 MB of
RAM, and required 208 cpu sec on a 2.53 GHz cpu.</p>
<p>N.B.: This is the same physical problem as the example in
<span><code>examples_exp/RCTGLPRSM</code></span> (see §<a
href="#sec:example RCTGLPRSM" data-reference-type="ref"
data-reference="sec:example RCTGLPRSM">[sec:example RCTGLPRSM]</a>),
differing only in that in the present calculation the target geometry is
input through the file <span><code>shape.dat</code></span> rather than
generated by <span><code>ddscat</code></span>.</p>
<h2
id="anifrmfil-general-anistropic-target-defined-by-list-of-dipole-locationscompositions-and-material-orientations-obtained-from-a-file">
ANIFRMFIL = General anistropic target defined by list of dipole
locations,“compositions”, and material orientations obtained from a file
<span id="sec:ANIFRMFIL" label="sec:ANIFRMFIL"></span></h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to read the
target geometry information from a file
<span><code>shape.dat</code></span> instead of automatically generating
one of the geometries listed below. The file
<span><code>shape.dat</code></span> gives the number <span
class="math inline">\(N\)</span> of dipoles in the target, the
components of the “target axes” <span class="math inline">\(\hat{\bf
a}_1\)</span> and <span class="math inline">\(\hat{\bf a}_2\)</span> in
the Target Frame (TF), the vector <span
class="math inline">\(x_0(1-3)\)</span> determining the correspondence
between the integers <span><code>IXYZ</code></span> and actual
coordinates in the TF, and specifications for the location and
“composition” of each dipole. For each dipole <span
class="math inline">\(J\)</span>, the file
<span><code>shape.dat</code></span> provides the location
<span><code>IXYZ(</code><span
class="math inline">\(J\)</span><code>,1-3)</code></span>, the
composition identifier integer <span><code>ICOMP(</code><span
class="math inline">\(J\)</span><code>,1-3)</code></span> specifying the
dielectric function corresponding to the three principal axes of the
dielectric tensor, and angles <span class="math inline">\(\Theta_{\rm
DF}\)</span>, <span class="math inline">\(\Phi_{\rm DF}\)</span>, and
<span class="math inline">\(\beta_{\rm DF}\)</span> specifying the
orientation of the local “Dielectric Frame” (DF) relative to the “Target
Frame” (TF) (see §<a href="#sec:composite anisotropic targets"
data-reference-type="ref"
data-reference="sec:composite anisotropic targets">[sec:composite
anisotropic targets]</a>). The DF is the reference frame in which the
dielectric tensor is diagonalized. The Target Frame is the reference
frame in which we specify the dipole locations.</p>
<p>The <span><code>shape.dat</code></span> file is read by routine
<span><code>REASHP</code></span> (file
<span><code>reashp.f90</code></span>). The user can customize
<span><code>REASHP</code></span> as needed to conform to the manner in
which the target geometry is stored in file
<span><code>shape.dat</code></span>. However, as supplied,
<span><code>REASHP</code></span> expects the file
<span><code>shape.dat</code></span> to have the following structure:</p>
<ul>
<li><p>one line containing a description; the first 67 characters will
be read and printed in various output statements.</p></li>
<li><p><span><code>N</code></span> = number of dipoles in
target</p></li>
<li><p><span class="math inline">\(a_{1x}\)</span> <span
class="math inline">\(a_{1y}\)</span> <span
class="math inline">\(a_{1z}\)</span> = x,y,z components (in Target
Frame) of <span class="math inline">\(\bf{a}_1\)</span></p></li>
<li><p><span class="math inline">\(a_{2x}\)</span> <span
class="math inline">\(a_{2y}\)</span> <span
class="math inline">\(a_{2z}\)</span> = x,y,z components (in Target
Frame) of <span class="math inline">\(\bf{a}_2\)</span></p></li>
<li><p><span class="math inline">\(d_x/d\)</span>  <span
class="math inline">\(d_y/d\)</span>  <span
class="math inline">\(d_z/d\)</span> = 1. 1. 1. = relative spacing of
dipoles in <span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>,
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> directions</p></li>
<li><p><span class="math inline">\(x_{0x}\)</span>  <span
class="math inline">\(x_{0y}\)</span>  <span
class="math inline">\(x_{0z}\)</span> = TF coordinates <span
class="math inline">\(x_{\rm TF}/d\)</span>  <span
class="math inline">\(y_{\rm TF}/d\)</span>  <span
class="math inline">\(z_{\rm TF}/d\)</span> corresponding to lattice
site <span><code>IXYZ</code></span>= 0 0 0</p></li>
<li><p>(line containing comments)</p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(1,1-3) ICOMP(1,1-3) THETADF(1) PHIDF(1) BETADF(1)</code></span></span></p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(2,1-3) ICOMP(2,1-3) THETADF(2) PHIDF(2) BETADF(2)</code></span></span></p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(3,1-3) ICOMP(3,1-3) THETADF(3) PHIDF(3) BETADF(3)</code></span></span></p></li>
<li><p>...</p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(J,1-3) ICOMP(J,1-3) THETADF(J) PHIDF(J) BETADF(J)</code></span></span></p></li>
<li><p>...</p></li>
<li><p><span> <span class="math inline">\(dummy\)</span>
<span><code>IXYZ(N,1-3) ICOMP(N,1-3) THETADF(N) PHIDF(N) BETADF(N)</code></span></span></p></li>
</ul>
<p>Where <span class="math inline">\(dummy\)</span> is a number (either
integer or floating point) that might, for example, give the number
identifying the dipole. This number will <span><em>not</em></span> be
used in any calculations.<br />
<span><code>THETADF PHIDF BETADF</code></span> should be given in
<span><strong>radians</strong></span>.<br />
Here is an example of the first few lines of a target description file
suitable for target option <span><code>ANIFRMFIL</code></span>:</p>
<pre><code>--- demo file for target option ANIFRMFIL (this line is for comments) ---
8       = NAT
1.000   0.000   0.000   = target vector a1 (in TF)
0.000   1.000   0.000   = target vector a2 (in TF)
1.      1.      1.      = d_x/d  d_y/d  d_z/d  (normally 1 1 1)
0.      0.      0.      = X0(1-3) = location in lattice of &quot;target origin&quot;
J    JX   JY   JZ  ICOMP(J,1-3) THETADF PHIDF BETADF
1     0    0    0   1  1  1    0.     0.      0.
2     0    0    1   1  1  1    0.     0.      0.
3     0    1    0   1  1  1    0.     0.      0.
4     0    1    1   1  1  1    0.     0.      0.
5     1    0    0   2  3  3    0.5236 1.5708  0.
6     1    0    1   2  3  3    0.5236 1.5708  0.
7     1    1    0   2  3  3    0.5236 1.5708  0.
8     1    1    1   2  3  3    0.5236 1.5708  0.</code></pre>
<p>This sample target consists of 8 dipoles arranged to represent a
cube.<br />
Half of the cube (dipoles with JX=0) has isotropic composition 1. For
this case, the angles THETADF, PHIDF, BETADF do not matter, and it
convenient to set them all to zero.<br />
The other half of the cube (dipoles with JX=1) consists of a uniaxial
material, with dielectric function 2 for E fields parallel to one axis
(the “c-axis”), and dielectric function 3 for E fields perpendicular to
the c-axis. The c-axis is <span class="math inline">\(30^o\)</span>
(0.5236 radians) away from <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span>, and lies in the <span class="math inline">\(\hat{\bf
x}_{\rm TF}\)</span>-<span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> plane (having been rotated by 1.5708 radians around <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>).<br />
Note that ICOMP(J,K) can be different for K=1,3, allowing treatment of
anisotropic targets, provided the dielectric tensor at each location is
diagonal in the TF.</p>
<h2 id="aniellips-homogeneous-anisotropic-ellipsoid."> ANIELLIPS =
Homogeneous, anisotropic ellipsoid. <span id="sec:ANIELLIPS"
label="sec:ANIELLIPS"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
define the ellipsoidal boundary: <span
class="math display">\[\left(\frac{x_{\rm TF}/d}{{\tt
SHPAR}_1}\right)^2+
        \left(\frac{y_{\rm TF}/d}{{\tt SHPAR}_2}\right)^2+
        \left(\frac{z_{\rm TF}/d}{{\tt SHPAR}_3}\right)^2 = \frac{1}{4}
        ~~~,\]</span> The TF origin is located at the centroid of the
ellipsoid.</p>
<h2
id="ani_ell_2-two-touching-homogeneous-anisotropic-ellipsoids-with-distinct-compositions">
ANI_ELL_2 = Two touching, homogeneous, anisotropic ellipsoids, with
distinct compositions <span id="sec:ANI_ELL_2"
label="sec:ANI_ELL_2"></span></h2>
<p>Geometry as for <span><code>ELLIPSO_2</code></span>;
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span>,
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
have same meanings as for <span><code>ELLIPSO_2</code></span>. Target
axes <span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm
TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2=(0,1,0)_{\rm TF}\)</span>.<br />
Line connecting ellipsoid centers is <span
class="math inline">\(\parallel \hat{\bf a}_1 = \hat{\bf x}_{\rm
TF}\)</span>.<br />
TF origin is located between ellipsoids, at point of contact.<br />
It is assumed that (for both ellipsoids) the dielectric tensor is
diagonal in the TF. User must set <span><code>NCOMP</code></span>=6 and
provide <span class="math inline">\(xx\)</span>, <span
class="math inline">\(yy\)</span>, <span
class="math inline">\(zz\)</span> components of dielectric tensor for
first ellipsoid, and <span class="math inline">\(xx\)</span>, <span
class="math inline">\(yy\)</span>, <span
class="math inline">\(zz\)</span> components of dielectric tensor for
second ellipsoid (ellipsoids are in order of increasing <span
class="math inline">\(x_{\rm TF}\)</span>).</p>
<h2
id="ani_ell_3-three-touching-homogeneous-anisotropic-ellipsoids-with-same-size-and-orientation-but-distinct-dielectric-tensors">
ANI_ELL_3 = Three touching homogeneous, anisotropic ellipsoids with same
size and orientation but distinct dielectric tensors <span
id="sec:ANI_ELL_3" label="sec:ANI_ELL_3"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
have same meanings as for <span><code>ELLIPSO_3</code></span>.<br />
Target axis <span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm
TF}\)</span> (along line of ellipsoid centers), and <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>.<br />
TF origin is located at center of middle ellipsoid.<br />
It is assumed that dielectric tensors are all diagonal in the TF. User
must set <span><code>NCOMP</code></span>=9 and provide <span
class="math inline">\(xx\)</span>, <span
class="math inline">\(yy\)</span>, <span
class="math inline">\(zz\)</span> elements of dielectric tensor for
first ellipsoid, <span class="math inline">\(xx\)</span>, <span
class="math inline">\(yy\)</span>, <span
class="math inline">\(zz\)</span> elements for second ellipsoid, and
<span class="math inline">\(xx\)</span>, <span
class="math inline">\(yy\)</span>, <span
class="math inline">\(zz\)</span> elements for third ellipsoid
(ellipsoids are in order of increasing <span
class="math inline">\(x_{\rm TF}\)</span>).</p>
<h2 id="anirctngl-homogeneous-anisotropic-rectangular-solid"> ANIRCTNGL
= Homogeneous, anisotropic, rectangular solid <span id="sec:ANIRCTNGL"
label="sec:ANIRCTNGL"></span></h2>
<p>x, y, z lengths/<span class="math inline">\(d\)</span> =
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span>,
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span>.<br />
Target axes <span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm
TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2=(0,1,0)_{\rm TF}\)</span> in the TF.<br />
<span class="math inline">\((x_{\rm TF},y_{\rm TF},z_{\rm
TF})=(0,0,0)\)</span> at middle of upper target surface, (where “up” =
<span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>). (The target
surface is taken to be <span class="math inline">\(d/2\)</span> about
the upper dipole layer.)<br />
Dielectric tensor is assumed to be diagonal in the target frame.<br />
User must set <span><code>NCOMP</code></span>=3 and supply names of
three files for <span class="math inline">\(\epsilon\)</span> as a
function of wavelength or energy: first for <span
class="math inline">\(\epsilon_{xx}\)</span>, second for <span
class="math inline">\(\epsilon_{yy}\)</span>, and third for <span
class="math inline">\(\epsilon_{zz}\)</span>,</p>
<h3
id="sample-calculation-in-directory-examples_expanirctngl"><strong>Sample
calculation in directory examples_exp/ANIRCTNGL</strong></h3>
<p>Subdirectory <span><code>examples_exp/ANIRCTNGL</code></span>
contains <span><code>ddscat.par</code></span> for calculation of
scattering by a <span class="math inline">\(0.1{\mu{\rm
m}}\times0.2{\mu{\rm m}}\times0.2{\mu{\rm m}}\)</span> rectangular brick
(<span class="math inline">\({a}_{\rm eff}=0.098475{\mu{\rm
m}}\)</span>) with an anisotropic dielectric tensor: <span
class="math inline">\(m=1.33+0.01i\)</span> for <span
class="math inline">\({\bf E}\parallel\hat{\bf x}_{\rm TF}\)</span> and
<span class="math inline">\({\bf E}\parallel\hat{\bf y}_{\rm
TF}\)</span>, and <span class="math inline">\(m=1.50+0.01i\)</span> for
<span class="math inline">\({\bf E}\parallel \hat{\bf z}_{\rm
TF}\)</span>. Radiation is incident with <span
class="math inline">\({\bf k}_0\parallel\hat{\bf x}_{\rm TF}\)</span>,
with <span class="math inline">\(\lambda=0.5{\mu{\rm m}}\)</span>. The
<span><code>ddscat.par</code></span> file is as follows:</p>
<pre><code>&#39; ============ Parameter file for v7.3 ===================&#39;
&#39;**** Preliminaries ****&#39;
&#39;NOTORQ&#39; = CMDTRQ*6 (DOTORQ, NOTORQ) -- either do or skip torque calculations
&#39;PBCGS2&#39; = CMDSOL*6 (PBCGS2, PBCGST, PETRKP) -- CCG method
&#39;GPFAFT&#39; = CMETHD*6 (GPFAFT, FFTMKL) -- FFT method
&#39;GKDLDR&#39; = CALPHA*6 (GKDLDR, LATTDR, FLTRCD) -- DDA method
&#39;NOTBIN&#39; = CBINFLAG (ALLBIN, ORIBIN, NOTBIN)
&#39;**** Initial Memory Allocation ****&#39;
10 20 20 = upper bound on target extent
&#39;**** Target Geometry and Composition ****&#39;
&#39;ANIRCTNGL&#39; = CSHAPE*9 shape directive
10 20 20 = shape parameters SHPAR1, SHPAR2, SHPAR3
3         = NCOMP = number of dielectric materials
&#39;../diel/m1.33_0.01&#39; = name of file containing dielectric function
&#39;../diel/m1.33_0.01&#39;
&#39;../diel/m1.50_0.01&#39;
&#39;**** Additional Nearfield calculation? ****&#39;
0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
0.0 0.0 0.0 0.0 0.0 0.0 (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)
&#39;**** Error Tolerance ****&#39;
1.00e-5 = TOL = MAX ALLOWED (NORM OF |G&gt;=AC|E&gt;-ACA|X&gt;)/(NORM OF AC|E&gt;)
&#39;**** maximum number of iterations allowed ****&#39;
300     = MXITER
&#39;**** Interaction cutoff parameter for PBC calculations ****&#39;
5.00e-3 = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)
&#39;**** Angular resolution for calculation of &lt;cos&gt;, etc. ****&#39;
2.0     = ETASCA (number of angles is proportional to [(2+x)/ETASCA]^2 )
&#39;**** Vacuum wavelengths (micron) ****&#39;
0.5 0.5 1 &#39;LIN&#39; = wavelengths (first,last,how many,how=LIN,INV,LOG)
&#39;**** Refractive index of ambient medium&#39;
1.000 = NAMBIENT
&#39;**** Effective Radii (micron) **** &#39;
0.098475 0.098457 1 &#39;LIN&#39; = eff. radii (first, last, how many, how=LIN,INV,LOG)
&#39;**** Define Incident Polarizations ****&#39;
(0,0) (1.,0.) (0.,0.) = Polarization state e01 (k along x axis)
2 = IORTH  (=1 to do only pol. state e01; =2 to also do orth. pol. state)
&#39;**** Specify which output files to write ****&#39;
1 = IWRKSC (=0 to suppress, =1 to write &quot;.sca&quot; file for each target orient.
&#39;**** Prescribe Target Rotations ****&#39;
 0.   0.  1  = BETAMI, BETAMX, NBETA (beta=rotation around a1)
 0.   0.  1  = THETMI, THETMX, NTHETA (theta=angle between a1 and k)
 0.   0.  1  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
&#39;**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****&#39;
0   0   0    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
&#39;**** Select Elements of S_ij Matrix to Print ****&#39;
6       = NSMELTS = number of elements of S_ij to print (not more than 9)
11 12 21 22 31 41       = indices ij of elements to print
&#39;**** Specify Scattered Directions ****&#39;
&#39;LFRAME&#39; = CMDFRM*6 (&#39;LFRAME&#39; or &#39;TFRAME&#39; for Lab Frame or Target Frame)
2 = number of scattering planes
0.  0. 180. 30 = phi, thetan_min, thetan_max, dtheta (in degrees) for plane A
90. 0. 180. 30 = phi, ... for plane B</code></pre>
<p>This calculation required 0.22 cpu sec on a 2.53 GHz cpu.</p>
<h2 id="conellips-two-concentric-ellipsoids"> CONELLIPS = Two concentric
ellipsoids <span id="sec:CONELLIPS" label="sec:CONELLIPS"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
lengths/<span class="math inline">\(d\)</span> of the
<span><em>outer</em></span> ellipsoid along the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> axes;<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span>,
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>,
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
lengths/<span class="math inline">\(d\)</span> of the
<span><em>inner</em></span> ellipsoid along the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> axes.<br />
Target axes <span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm
TF}\)</span>, <span class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm
TF}\)</span>.<br />
TF origin is located at centroids of ellipsoids.<br />
The “core" within the inner ellipsoid is composed of isotropic material
1; the “mantle" between inner and outer ellipsoids is composed of
isotropic material 2.<br />
User must set <span><code>NCOMP</code></span>=2 and provide dielectric
functions for “core” and “mantle” materials.</p>
<h2 id="cylinder1-homogeneous-isotropic-finite-cylinder"> CYLINDER1 =
Homogeneous, isotropic finite cylinder <span id="sec:CYLINDER1"
label="sec:CYLINDER1"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> = length/<span
class="math inline">\(d\)</span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span> = diameter/<span
class="math inline">\(d\)</span>, with<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
1 for cylinder axis <span class="math inline">\(\hat{\bf a}_1\parallel
\hat{\bf x}_{\rm TF}\)</span>: <span class="math inline">\(\hat{\bf
a}_1=(1,0,0)_{\rm TF}\)</span> and <span class="math inline">\(\hat{\bf
a}_2=(0,1,0)_{\rm TF}\)</span>;<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
2 for cylinder axis <span class="math inline">\(\hat{\bf a}_1\parallel
\hat{\bf y}_{\rm TF}\)</span>: <span class="math inline">\(\hat{\bf
a}_1=(0,1,0)_{\rm TF}\)</span> and <span class="math inline">\(\hat{\bf
a}_2=(0,0,1)_{\rm TF}\)</span>;<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
3 for cylinder axis <span class="math inline">\(\hat{\bf a}_1\parallel
\hat{\bf z}_{\rm TF}\)</span>: <span class="math inline">\(\hat{\bf
a}_1=(0,0,1)_{\rm TF}\)</span> and <span class="math inline">\(\hat{\bf
a}_2=(1,0,0)_{\rm TF}\)</span> in the TF.<br />
TF origin is located at centroid of cylinder.<br />
User must set <span><code>NCOMP</code></span>=1.</p>
<h2
id="cylndrcap-homogeneous-isotropic-finite-cylinder-with-hemispherical-endcaps.">
CYLNDRCAP = Homogeneous, isotropic finite cylinder with hemispherical
endcaps. <span id="sec:CYLNDRCAP" label="sec:CYLNDRCAP"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> = cylinder length/<span
class="math inline">\(d\)</span> (<span><em>not</em></span> including
end-caps!) and <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span> = cylinder diameter/<span
class="math inline">\(d\)</span>, with cylinder axis <span
class="math inline">\(={\hat{\bf a}}_1=(1,0,0)_{\rm TF}\)</span> and
<span class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>.
The total length along the target axis (including the endcaps) is
(<span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>+<span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>)<span
class="math inline">\(d\)</span>.<br />
TF origin is located at centroid of cylinder.<br />
User must set <span><code>NCOMP</code></span>=1.</p>
<h2 id="dskrctngl-disk-on-top-of-a-homogeneous-rectangular-slab">
DSKRCTNGL = Disk on top of a homogeneous rectangular slab <span
id="sec:DSKRCTNGL" label="sec:DSKRCTNGL"></span></h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of a disk of composition 1 resting on top of a
rectangular block of composition 2. Materials 1 and 2 are assumed to be
homogeneous and isotropic.<br />
<span><code>ddscat.par</code></span> should set
<span><code>NCOMP</code></span> to 2 .  <br />
The cylindrical disk has thickness <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span><span
class="math inline">\(\times d\)</span> in the x-direction, and diameter
<span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span><span
class="math inline">\(\times d\)</span>. The rectangular block is
assumed to have thickness <span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span><span
class="math inline">\(\times\)</span>d in the x-direction, length
<span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span><span class="math inline">\(\times
d\)</span> in the y-direction, and length
<span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span><span class="math inline">\(\times
d\)</span> in the z-direction. The lower surface of the cylindrical disk
is in the <span class="math inline">\(x=0\)</span> plane. The upper
surface of the slab is also in the <span
class="math inline">\(x=0\)</span> plane.</p>
<p>The Target Frame origin (0,0,0) is located where the symmetry axis of
the disk intersects the <span class="math inline">\(x=0\)</span> plane
(the upper surface of the slab, and the lower surface of the disk). In
the Target Frame, dipoles representing the rectangular block are located
at <span
class="math inline">\((x/d,y/d,z/d)=(j_x+0.5,j_y+\Delta_y,j_z+\Delta_z)\)</span>,
where <span class="math inline">\(j_x\)</span>, <span
class="math inline">\(j_y\)</span>, and <span
class="math inline">\(j_z\)</span> are integers. <span
class="math inline">\(\Delta_y=0\)</span> or 0.5 depending on whether
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span>
is even or odd. <span class="math inline">\(\Delta_z=0\)</span> or 0.5
depending on whether <span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span> is even or odd.</p>
<p>Dipoles representing the disk are located at<br />
<span class="math inline">\(x/d = 0.5 , 1.5 ,...,
        [{\rm int}({\tt SHPAR}_4+0.5)-0.5]\)</span></p>
<p>As always, the physical size of the target is fixed by specifying the
value of the effective radius <span class="math inline">\({a}_{\rm
eff}\equiv(3V_{\rm T}/4\pi)^{1/3}\)</span>, where <span
class="math inline">\(V_{\rm T}\)</span> is the total volume of solid
material in the target. For this geometry, the number of dipoles in the
target will be approximately <span class="math inline">\(N=[{\tt
SHPAR}_1\times{\tt SHPAR}_2\times{\tt SHPAR}_3 +
        (\pi/4)(({\tt SHPAR}_4)^2\times{\tt SHPAR}_5)]\)</span>,
although the exact number may differ because of the dipoles are required
to be located on a rectangular lattice. The dipole spacing <span
class="math inline">\(d\)</span> in physical units is determined from
the specified value of <span class="math inline">\({a}_{\rm
eff}\)</span> and the number <span class="math inline">\(N\)</span> of
dipoles in the target: <span
class="math inline">\(d=(4\pi/3N)^{1/3}{a}_{\rm eff}\)</span>. This
option requires 5 shape parameters: The pertinent line in
<span><code>ddscat.par</code></span> should read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code><span
class="math inline">\(_3\)</span><code> SHPAR</code><span
class="math inline">\(_4\)</span><code> SHPAR</code></span><span
class="math inline">\(_5\)</span><br />
 <br />
where<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
[disk thickness (in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)]/<span class="math inline">\(d\)</span>
[material 1]<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
(disk diameter)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
(brick thickness in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span> [material
2]<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
(brick thickness in <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
(brick thickness in <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
 <br />
The overall size of the target (in terms of numbers of dipoles) is
determined by parameters <span><code>(SHPAR1+SHPAR4), SHPAR</code><span
class="math inline">\(_2\)</span></span>, and
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>.
The periodicity in the TF <span class="math inline">\(y\)</span> and
<span class="math inline">\(z\)</span> directions is determined by
parameters <span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span> and
<span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span>.<br />
The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>.</p>
<p>The “computational volume” is determined by
(<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code>+SHPAR</code></span><span
class="math inline">\(_4\)</span>)<span
class="math inline">\(\times\)</span><span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span><span
class="math inline">\(\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span>.</p>
<p>The target axes (in the TF) are set to <span
class="math inline">\({\hat{\bf a}}_1 = \hat{\bf x}_{\rm TF}=
(1,0,0)_{\rm TF}\)</span> – i.e., normal to the “slab” – and <span
class="math inline">\({\hat{\bf a}}_2 = \hat{\bf y}_{\rm TF}=
(0,1,0)_{\rm TF}\)</span>. The orientation of the incident radiation
relative to the target is, as for all other targets, set by the usual
orientation angles <span class="math inline">\(\Theta\)</span>, <span
class="math inline">\(\Phi\)</span>, and <span
class="math inline">\(\beta\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the slab.</p>
<h2 id="dw1996tar-13-block-target-used-by-."> DW1996TAR = 13 block
target used by <span class="citation"
data-cites="Draine+Weingartner_1996"></span>. <span id="sec:DW1996TAR"
label="sec:DW1996TAR"></span></h2>
<p>Single, isotropic material. Target geometry was used in study by
<span class="citation" data-cites="Draine+Weingartner_1996"></span> of
radiative torques on irregular grains. <span
class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span> are principal axes with
largest and second-largest moments of inertia. User must set
<span><code>NCOMP=1</code></span>. Target size is controlled by shape
parameter <span><code>SHPAR(1)</code></span> = width of one block in
lattice units.<br />
TF origin is located at centroid of target.</p>
<h2 id="ellipsoid-homogeneous-isotropic-ellipsoid."> ELLIPSOID =
Homogeneous, isotropic ellipsoid. <span id="sec:ELLIPSOID"
label="sec:ELLIPSOID"></span></h2>
<p>“Lengths” <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
in the <span class="math inline">\(x\)</span>, <span
class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span>
directions in the TF: <span class="math display">\[\left(\frac{x_{\rm
TF}}{{\tt SHPAR}_1 d}\right)^2+
        \left(\frac{y_{\rm TF}}{{\tt SHPAR}_2 d}\right)^2+
        \left(\frac{z_{\rm TF}}{{\tt SHPAR}_3 d}\right)^2 = \frac{1}{4}
        ~~~,\]</span> where <span class="math inline">\(d\)</span> is
the interdipole spacing.<br />
The target axes are set to <span class="math inline">\({\hat{\bf
a}}_1=(1,0,0)_{\rm TF}\)</span> and <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>.<br />
Target Frame origin = centroid of ellipsoid.<br />
User must set <span><code>NCOMP</code></span>=1 on line 9 of
<span><code>ddscat.par</code></span>.<br />
A <span><strong>homogeneous, isotropic sphere</strong></span> is
obtained by setting <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> = <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span> =
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
diameter/<span class="math inline">\(d\)</span>.</p>
<h3
id="sample-calculation-in-directory-examples_expellipsoid"><strong>Sample
calculation in directory examples_exp/ELLIPSOID</strong></h3>
<p>The directory <span><code>examples_exp/ELLIPSOID</code></span>
contains <span><code>ddscat.par</code></span> for calculation of
scattering by a sphere with refractive index <span
class="math inline">\(m=1.5+0.01i\)</span> and <span
class="math inline">\(2\pi a/\lambda=5\)</span>, represented by a <span
class="math inline">\(N=59728\)</span> dipole pseudosphere just fitting
within a <span class="math inline">\(48\times48\times48\)</span>
computational volume, as well as the output files from the calculation.
The calculation with <span class="math inline">\(2\pi
a/\lambda=5\)</span> has <span
class="math inline">\(|m|kd=0.309\)</span>. The computation used 144 MB
of RAM and required 63 cpu sec on a 2.53 GHz cpu.</p>
<h3
id="sample-calculation-in-directory-examples_expellipsoid_nearfield"><span
id="sec:ELLIPSOID_NEARFIELD" label="sec:ELLIPSOID_NEARFIELD"></span>
<strong>Sample calculation in directory
examples_exp/ELLIPSOID_NEARFIELD</strong></h3>
<p>The directory
<span><code>examples_exp/ELLIPSOID_NEARFIELD</code></span> contains
<span><code>ddscat.par</code></span> for calculation of (1) far-field
scattering and (2) <span class="math inline">\({\bf E}\)</span> in and
near the target for a sphere with refractive index <span
class="math inline">\(m=0.96+1.01i\)</span> (refractive index of Au at
<span class="math inline">\(\lambda=0.5{\mu{\rm m}}\)</span>) and <span
class="math inline">\(2\pi a/\lambda=5\)</span>. The spherical target is
represented by a <span class="math inline">\(N=59728\)</span> dipole
pseudosphere just fitting within a <span
class="math inline">\(48\times48\times48\)</span> computational volume,
as well as the output files from the calculation.</p>
<p>In physical units with <span
class="math inline">\(\lambda=0.5{\mu{\rm m}}\)</span>, <span
class="math inline">\({a}_{\rm eff}=5\times\lambda/2\pi=0.39789{\mu{\rm
m}}\)</span>. The calculation with <span class="math inline">\(2\pi
a/\lambda=5\)</span> has <span
class="math inline">\(|m|kd=0.309\)</span>. The computation used 144 MB
of RAM and required 60 cpu sec on a 2.53 GHz cpu.</p>
<p>The nearfield calculation is specified to extend throughout a
computational volume extending the original <span
class="math inline">\(48d\times48d\times48d\)</span> computational
volume by 50% in all directions, to become a <span
class="math inline">\(96d\times96d\times96d\)</span> volume centered on
the sphere. <span class="math inline">\({\bf E}\)</span> is evaluated at
all points in this volume. The nearfield calculation used 62 MB of RAM
and required just 9.6 cpu sec. The nearfield calculation creates the
binary files <span><code>w000r000k000.E1</code></span> and
<span><code>w000r000k000.E2</code></span>, one for each of the two
incident polarizations.</p>
<p>After the nearfield calculation is complete, the program
<span><code>ddpostprocess</code></span> is used to read the file
<span><code>w000r000k000.E1</code></span> (specified in
<span><code>ddpostprocess.par</code></span>) and extract <span
class="math inline">\({\bf E}\)</span> at 501 points along a line
specified in <span><code>ddpostprocess.par</code></span> – the line runs
along the <span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> axis
through the center of the sphere. The results are shown in Figure <a
href="#fig:ellipsoid_E^2" data-reference-type="ref"
data-reference="fig:ellipsoid_E^2">8</a>.</p>
<div class="center">
<figure>
<img src="f_ellipsoid_nf.png" id="fig:ellipsoid_E^2"
alt="Normalized electric field intensity |{\bf E}|^2/|{\bf E}_0|^2 along a line parallel to the direction of propagation, and passing through the center of an Au sphere of radius a=0.3979{\mu{\rm m}}, for light with wavelength \lambda=0.5{\mu{\rm m}}. The calculation in examples_exp/ELLIPSOID_NEARFIELD was done with dipole spacing d=a/48.49=0.00821{\mu{\rm m}}. " />
<figcaption aria-hidden="true">Normalized electric field intensity <span
class="math inline">\(|{\bf E}|^2/|{\bf E}_0|^2\)</span> along a line
parallel to the direction of propagation, and passing through the center
of an Au sphere of radius <span class="math inline">\(a=0.3979{\mu{\rm
m}}\)</span>, for light with wavelength <span
class="math inline">\(\lambda=0.5{\mu{\rm m}}\)</span>. The calculation
in examples_exp/ELLIPSOID_NEARFIELD was done with dipole spacing <span
class="math inline">\(d=a/48.49=0.00821{\mu{\rm m}}\)</span>.
</figcaption>
</figure>
</div>
<h2
id="ellipso_2-two-touching-homogeneous-isotropic-ellipsoids-with-distinct-compositions">
ELLIPSO_2 = Two touching, homogeneous, isotropic ellipsoids, with
distinct compositions <span id="sec:ELLIPSO_2"
label="sec:ELLIPSO_2"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span>=x-length/<span
class="math inline">\(d\)</span>, y-length/<span
class="math inline">\(d\)</span>, <span
class="math inline">\(z\)</span>-length/<span
class="math inline">\(d\)</span> of one ellipsoid. The two ellipsoids
have identical shape, size, and orientation, but distinct dielectric
functions. The line connecting ellipsoid centers is along the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>-axis. Target axes
<span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm TF}\)</span>
[along line connecting ellipsoids] and <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>.<br />
Target Frame origin = midpoint between ellipsoids (where ellipsoids
touch).<br />
User must set <span><code>NCOMP</code></span>=2 and provide dielectric
function file names for both ellipsoids. Ellipsoids are in order of
increasing <span class="math inline">\(x_{\rm TF}\)</span>: first
dielectric function is for ellipsoid with center at negative <span
class="math inline">\(x_{\rm TF}\)</span>, second dielectric function
for ellipsoid with center at positive <span class="math inline">\(x_{\rm
TF}\)</span>.</p>
<h2
id="ellipso_3-three-touching-homogeneous-isotropic-ellipsoids-of-equal-size-and-orientation-but-distinct-compositions">
ELLIPSO_3 = Three touching homogeneous, isotropic ellipsoids of equal
size and orientation, but distinct compositions <span id="sec:ELLIPSO_3"
label="sec:ELLIPSO_3"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
have same meaning as for <span><code>ELLIPSO_2</code></span>. Line
connecting ellipsoid centers is parallel to <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> axis. Target axis
<span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm TF}\)</span>
(along line of ellipsoid centers), and <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>.<br />
Target Frame origin = centroid of middle ellipsoid.<br />
User must set <span><code>NCOMP</code></span>=3 and provide (isotropic)
dielectric functions for first, second, and third ellipsoid.</p>
<h2 id="hex_prism-homogeneous-isotropic-hexagonal-prism"> HEX_PRISM =
Homogeneous, isotropic hexagonal prism <span id="sec:HEX_PRISM"
label="sec:HEX_PRISM"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> = (Length of prism)/<span
class="math inline">\(d\)</span> = (distance between hexagonal
faces)/<span class="math inline">\(d\)</span>,<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
(distance between opposite vertices of one hexagonal face)/<span
class="math inline">\(d\)</span> = 2<span
class="math inline">\(\times\)</span>hexagon side/<span
class="math inline">\(d\)</span>.<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
selects one of 6 orientations of the prism in the Target Frame
(TF).<br />
Target axis <span class="math inline">\({\hat{\bf a}}_1\)</span> is
along the prism axis (i.e., normal to the hexagonal faces), and target
axis <span class="math inline">\({\hat{\bf a}}_2\)</span> is normal to
one of the rectangular faces. There are 6 options for
<span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span>:<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
1 for <span class="math inline">\({\hat{\bf a}}_1\parallel\hat{\bf
x}_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2\parallel\hat{\bf y}_{\rm TF}\)</span>;
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
2 for <span class="math inline">\({\hat{\bf a}}_1\parallel\hat{\bf
x}_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2\parallel\hat{\bf z}_{\rm TF}\)</span>;<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
3 for <span class="math inline">\({\hat{\bf a}}_1\parallel\hat{\bf
y}_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2\parallel\hat{\bf x}_{\rm TF}\)</span>;
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
4 for <span class="math inline">\({\hat{\bf a}}_1\parallel\hat{\bf
y}_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2\parallel\hat{\bf z}_{\rm TF}\)</span>;<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
5 for <span class="math inline">\({\hat{\bf a}}_1\parallel\hat{\bf
z}_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2\parallel\hat{\bf x}_{\rm TF}\)</span>;
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
6 for <span class="math inline">\({\hat{\bf a}}_1\parallel\hat{\bf
z}_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2\parallel\hat{\bf y}_{\rm TF}\)</span><br />
TF origin is located at the centroid of the target.<br />
User must set <span><code>NCOMP</code></span>=1.</p>
<h2 id="layrdslab-multilayer-rectangular-slab"> LAYRDSLAB = Multilayer
rectangular slab <span id="sec:LAYRDSLAB"
label="sec:LAYRDSLAB"></span></h2>
<p>Multilayer rectangular slab with overall x, y, z lengths <span
class="math inline">\(a_x = {\tt SHPAR}_1\times d\)</span><br />
<span class="math inline">\(a_y = {\tt SHPAR}_2\times d\)</span>,<br />
<span class="math inline">\(a_z = {\tt SHPAR}_3\times d\)</span>.<br />
Upper surface is at <span class="math inline">\(x_{\rm TF}=0\)</span>,
lower surface at <span class="math inline">\(x_{\rm TF}=-{\tt
SHPAR}_1\times d\)</span><br />
<span class="math inline">\({\tt SHPAR}_4\)</span> = fraction which is
composition 1 (top layer).<br />
<span class="math inline">\({\tt SHPAR}_5\)</span> = fraction which is
composition 2 (layer below top)<br />
<span class="math inline">\({\tt SHPAR}_6\)</span> = fraction which is
composition 3 (layer below comp 2)<br />
<span class="math inline">\(1-({\tt SHPAR}_4+{\tt SHPAR}_5+{\tt
SHPAR}_6)\)</span> = fraction which is composition 4 (bottom
layer).<br />
To create a bilayer slab, just set <span class="math inline">\({\tt
SHPAR}_5={\tt SHPAR}_6=0\)</span><br />
To create a trilayer slab, just set <span class="math inline">\({\tt
SHPAR}_6=0\)</span><br />
User must set <span><code>NCOMP</code></span>=2,3, or 4 and provide
dielectric function files for each of the two layers. Top dipole layer
is at <span class="math inline">\(x_{\rm TF}=-d/2\)</span>. Origin of TF
is at center of top surface.</p>
<h2 id="mltblocks-homogeneous-target-constructed-from-cubic-blocks">
MLTBLOCKS = Homogeneous target constructed from cubic “blocks” <span
id="sec:MLTBLOCKS" label="sec:MLTBLOCKS"></span></h2>
<p>Number and location of blocks are specified in separate file
<span><code>blocks.par</code></span> with following structure:<br />
one line of comments (may be blank)<br />
<span><code>PRIN</code></span> (= 0 or 1 – see below)<br />
<span><code>N</code></span> (= number of blocks)<br />
<span><code>B</code></span> (= width/<span
class="math inline">\(d\)</span> of one block)<br />
<span class="math inline">\(x_{\rm TF}\)</span> <span
class="math inline">\(y_{\rm TF}\)</span> <span
class="math inline">\(z_{\rm TF}\)</span> (= position of 1st block in
units of <span><code>B</code></span><span
class="math inline">\(d\)</span>)<br />
<span class="math inline">\(x_{\rm TF}\)</span> <span
class="math inline">\(y_{\rm TF}\)</span> <span
class="math inline">\(z_{\rm TF}\)</span> (= position of 2nd block in
units of <span><code>B</code></span><span
class="math inline">\(d\)</span>) )<br />
...<br />
<span class="math inline">\(x_{\rm TF}\)</span> <span
class="math inline">\(y_{\rm TF}\)</span> <span
class="math inline">\(z_{\rm TF}\)</span> (= position of
<span><code>N</code></span>th block in units of
<span><code>B</code></span><span class="math inline">\(d\)</span>)<br />
If <span><code>PRIN</code></span>=0, then <span
class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm TF}\)</span>, <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>. If
<span><code>PRIN</code></span>=1, then <span
class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span> are set to principal axes
with largest and second largest moments of inertia, assuming target to
be of uniform density. User must set
<span><code>NCOMP=1</code></span>.</p>
<h2 id="rctglprsm-homogeneous-isotropic-rectangular-solid"> RCTGLPRSM =
Homogeneous, isotropic, rectangular solid <span id="sec:RCTGLPRSM"
label="sec:RCTGLPRSM"></span></h2>
<p>x, y, z lengths/<span class="math inline">\(d\)</span> =
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span>,
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span>.<br />
Target axes <span class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm
TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2=(0,1,0)_{\rm TF}\)</span>.<br />
TF origin at center of upper surface of solid: target extends from <span
class="math inline">\(x_{\rm TF}/d=-{\tt SHPAR}_1\)</span> to 0,<br />
<span class="math inline">\(y_{\rm TF}/d\)</span> from <span
class="math inline">\(-0.5\times{\tt SHPAR_2}\)</span> to <span
class="math inline">\(+0.5\times{\tt SHPAR_2}\)</span><br />
<span class="math inline">\(z_{\rm TF}/d\)</span> from <span
class="math inline">\(-0.5\times{\tt SHPAR_3}\)</span> to <span
class="math inline">\(+0.5\times{\tt SHPAR_3}\)</span><br />
User must set <span><code>NCOMP</code></span>=1.</p>
<h3 id="sample-calculation-in-directory-examples_exprctglprsm"><span
id="sec:example RCTGLPRSM" label="sec:example RCTGLPRSM"></span>
<strong>Sample calculation in directory
examples_exp/RCTGLPRSM</strong></h3>
<p>The directory <span><code>examples_exp/RCTGLPRSM</code></span>
contains <span><code>ddscat.par</code></span> for calculation of
scattering by a <span class="math inline">\(0.25{\mu{\rm
m}}\times0.5{\mu{\rm m}}\times0.5{\mu{\rm m}}\)</span> Au block,
represented by a <span class="math inline">\(16\times32\times32\)</span>
dipole array, together with output files from the calculation. The Au
has refractive index <span
class="math inline">\(m=0.9656+1.8628i\)</span>. The DDA calculation has
<span class="math inline">\(|m|kd=0.4120\)</span>. The calculation used
52 MB of RAM, and required 10.0 cpu sec on a 2.53 GHz cpu.</p>
<h3
id="sample-calculation-in-directory-examples_exprctglprsm_nearfield"><span
id="sec:example RCTGLPRSM_NEARFIELD"
label="sec:example RCTGLPRSM_NEARFIELD"></span> <strong>Sample
calculation in directory examples_exp/RCTGLPRSM_NEARFIELD</strong></h3>
<p>The directory
<span><code>examples_exp/RCTGLPRSM_NEARFIELD</code></span> contains
<span><code>ddscat.par</code></span> for the same scattering problem as
in <span><code>examples_exp/RCTGLPRSM</code></span>, but also calling
for nearfield calculation of <span class="math inline">\({\bf
E}\)</span> throughout a <span class="math inline">\(0.5{\mu{\rm
m}}\times1.0{\mu{\rm m}}\times1.0{\mu{\rm m}}\)</span> volume centered
on the target (i.e., fractional extension of 50% in <span
class="math inline">\(+x_{\rm TF},-x_{\rm TF},+y_{\rm TF},-y_{\rm
TF},+z_{\rm TF},-z_{\rm TF}\)</span> directions). The <span
class="math inline">\({\bf E}\)</span> field is evaluated on a grid with
spacing <span class="math inline">\(d\)</span> (which includes all the
dipole locations); the results for the two orthogonal polarizations are
written into the binary files <span><code>w000r000k000.E1</code></span>
and <span><code> w000r000k000.E2</code></span>. The complete calculation
used 11.4 cpu sec on a 2.53 GHz cpu.</p>
<h2
id="rctglblk3-stack-of-3-rectangular-blocks-with-centers-on-the-hatbf-x_rm-tf-axis.">
RCTGLBLK3 = Stack of 3 rectangular blocks, with centers on the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> axis. <span
id="sec:RCTGLBLK3" label="sec:RCTGLBLK3"></span></h2>
<p>Each block consists of a distinct material. There are 9 shape
parameters:<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
(upper solid thickness in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span> [material
1]<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
(upper solid width in <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
(upper solid width in <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
(middle solid thickness in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span> [material
2]<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
(middle solid width in <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
(middle solid width in <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span> =
(lower solid thickness in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span> [material
3]<br />
<span><code>SHPAR</code></span><span class="math inline">\(_8\)</span> =
(lower solid width in <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_9\)</span> =
(lower solid width in <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
TF origin is at center of top surface of material 1.</p>
<h2 id="slab_hole-rectangular-slab-with-a-cylindrical-hole."> SLAB_HOLE
= Rectangular slab with a cylindrical hole. <span id="sec:SLAB_HOLE"
label="sec:SLAB_HOLE"></span></h2>
<p>The target consists of a rectangular block with a cylindrical hole
with the axis passing through the centroid and aligned with the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> axis. The block
dimensions are <span class="math inline">\(a\times b\times c\)</span>.
The cylindrical hole has radius <span class="math inline">\(r\)</span>.
The pertinent line in <span><code>ddscat.par</code></span> should
read<br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code><span
class="math inline">\(_3\)</span><code> SHPAR</code><span
class="math inline">\(_4\)</span></span><br />
where<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
<span class="math inline">\(a/d\)</span> (<span
class="math inline">\(d\)</span> is the interdipole spacing)<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
<span class="math inline">\(b/a\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_3\)</span></span> =
<span class="math inline">\(c/a\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_4\)</span></span> =
<span class="math inline">\(r/a\)</span><br />
Ideally, <span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span>, <span><code>SHPAR</code></span><span
class="math inline">\(_2\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span>, <span><code>SHPAR</code></span><span
class="math inline">\(_3\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span> will be integers (so that the cubic
lattice can accurately approximate the desired target geometry), and
<span><code>SHPAR</code></span><span
class="math inline">\(_4\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span> will be large enough for the circular
cross section to be well-approximated.<br />
The TF origin is at the center of the top surface (the top surface lies
in the <span class="math inline">\(\hat{\bf y}_{\rm TF}-\hat{\bf z}_{\rm
TF}\)</span> plane, and extends from <span class="math inline">\(y_{{\rm
TF}}=-b/2\)</span> to <span class="math inline">\(+b/2\)</span>, and
<span class="math inline">\(z_{\rm TF}=-c/2\)</span> to <span
class="math inline">\(+c/2\)</span>). The cylindrical hole axis runs
from <span class="math inline">\((x_{\rm TF}=0,y_{\rm TF}=0,z_{\rm
TF}=0)\)</span> to <span class="math inline">\((x_{\rm TF}=-a,y_{\rm
TF}=0,z_{\rm TF}=0)\)</span>.</p>
<h2
id="spheres_n-multisphere-target-union-of-n-spheres-of-single-isotropic-material">
SPHERES_N = Multisphere target = union of <span
class="math inline">\(N\)</span> spheres of single isotropic material
<span id="sec:SPHERES_N" label="sec:SPHERES_N"></span></h2>
<p>Spheres may overlap if desired. The relative locations and sizes of
these spheres are defined in an external file, whose name (enclosed in
single quotes) is passed through <span><code>ddscat.par</code></span>.
The length of the file name should not exceed 80 characters. The
pertinent line in <span><code>ddscat.par</code></span> should read<br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span></span>
<span><em>’filename’</em></span> (quotes must be used)<br />
where <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> = target diameter in <span
class="math inline">\(x\)</span> direction (in Target Frame) in units of
<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>=
0 to have <span class="math inline">\(a_1=(1,0,0)_{\rm TF}\)</span>,
<span class="math inline">\(a_2=(0,1,0)_{\rm TF}\)</span>.<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>=
1 to use principal axes of moment of inertia tensor for <span
class="math inline">\(a_1\)</span> (largest <span
class="math inline">\(I\)</span>) and <span
class="math inline">\(a_2\)</span> (intermediate <span
class="math inline">\(I\)</span>).<br />
<span><em>filename</em></span> is the name of the file specifying the
locations and relative sizes of the spheres.<br />
The overall size of the multisphere target (in terms of numbers of
dipoles) is determined by parameter <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, which is the extent of the
multisphere target in the <span
class="math inline">\(x\)</span>-direction, in units of the lattice
spacing <span class="math inline">\(d\)</span>.<br />
The file <span><em>‘filename’</em></span> should have the following
structure:<br />
<br />
<span class="math inline">\(N\)</span> (= number of spheres)<br />
line of comments (may be blank)<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
<span class="math inline">\(x_1\)</span> <span
class="math inline">\(y_1\)</span> <span
class="math inline">\(z_1\)</span> <span
class="math inline">\(a_1\)</span> (arb. units)<br />
<span class="math inline">\(x_2\)</span> <span
class="math inline">\(y_2\)</span> <span
class="math inline">\(z_2\)</span> <span
class="math inline">\(a_2\)</span> (arb. units)<br />
...<br />
<span class="math inline">\(x_N\)</span> <span
class="math inline">\(y_N\)</span> <span
class="math inline">\(z_N\)</span> <span
class="math inline">\(a_N\)</span> (arb. units)<br />
<br />
where <span class="math inline">\(x_j\)</span>, <span
class="math inline">\(y_j\)</span>, <span
class="math inline">\(z_j\)</span> are the coordinates (in the TF) of
the center of sphere <span class="math inline">\(j\)</span>, and <span
class="math inline">\(a_j\)</span> is the radius of sphere <span
class="math inline">\(j\)</span>.<br />
Note that <span class="math inline">\(x_j\)</span>, <span
class="math inline">\(y_j\)</span>, <span
class="math inline">\(z_j\)</span>, <span
class="math inline">\(a_j\)</span> (<span
class="math inline">\(j=1,...,N\)</span>) establish only the
<span><em>shape</em></span> of the <span
class="math inline">\(N-\)</span>sphere target. For instance, a target
consisting of two touching spheres with the line between centers
parallel to the <span class="math inline">\(x\)</span> axis could
equally well be described by lines 6 and 7 being<br />
0  0  0  0.5<br />
1  0  0  0.5<br />
or<br />
0  0  0  1<br />
2  0  0  1<br />
The actual size (in physical units) is set by the value of <span
class="math inline">\(a_{\rm eff}\)</span> specified in
<span><code>ddscat.par</code></span>, where, as always, <span
class="math inline">\(a_{\rm eff}\equiv (3 V/4\pi)^{1/3}\)</span>, where
<span class="math inline">\(V\)</span> is the total volume of material
in the target.<br />
Target axes <span class="math inline">\(\hat{\bf a}_1\)</span> and <span
class="math inline">\(\hat{\bf a}_2\)</span> are set to be principal
axes of moment of inertia tensor (for uniform density), where <span
class="math inline">\(\hat{\bf a}_1\)</span> corresponds to the largest
eigenvalue, and <span class="math inline">\(\hat{\bf a}_2\)</span> to
the intermediate eigenvalue.<br />
The TF origin is taken to be located at the volume-weighted
centroid.<br />
User must set <span><code>NCOMP</code></span>=1.</p>
<h3 id="sample-calculation-in-directory-examples_expspheres_n"><span
id="sec:example SPHERES_N" label="sec:example SPHERES_N"></span>
<strong>Sample calculation in directory
examples_exp/SPHERES_N</strong></h3>
<p>The directory <span><code>examples_exp/SPHERES_N</code></span>
contains <span><code>ddscat.par</code></span> for a sample scattering
problem using target option <span><code>SPHERES_N</code></span>.
<span><code>ddscat.par</code></span> specifies that the locations of the
spheres is to be read in from the file
<span><code>BAM2.16.1.targ</code></span>, which contains locations and
radii of 16 spheres in a cluster formed by “Ballistic Aggregation with 2
Migrations” (see <span class="citation"
data-cites="Shen+Draine+Johnson_2008"></span> for a description of this
procedure for producting random aggregates). The spheres are assumed to
be composed of material with refractive index <span
class="math inline">\(m=1.33+0.01i\)</span>. The effective radius <span
class="math inline">\({a}_{\rm eff}=0.25198{\mu{\rm m}}\)</span>, so
that each sphere has a radius <span class="math inline">\({a}_{\rm
eff}/16^{1/3}=0.10{\mu{\rm m}}\)</span>. The calculation is done for
wavelength <span class="math inline">\(\lambda=0.6{\mu{\rm m}}\)</span>,
so that each monomer has <span class="math inline">\(x=2\pi a/\lambda =
1.047\)</span>, and <span class="math inline">\(|m|kd=0.3386\)</span>.
Mueller matrix elements are evaluated for two scattering planes.</p>
<p>This calculation required 1.7 cpu sec on a 2.53 GHz cpu.</p>
<h2
id="sphroid_2-two-touching-homogeneous-isotropic-spheroids-with-distinct-compositions">
SPHROID_2 = Two touching homogeneous, isotropic spheroids, with distinct
compositions <span id="sec:SPHROID_2" label="sec:SPHROID_2"></span></h2>
<p>First spheroid has length <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> along symmetry axis, diameter
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>
perpendicular to symmetry axis. Second spheroid has length
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
along symmetry axis, diameter <span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span> perpendicular to symmetry axis.
Contact point is on line connecting centroids. Line connecting centroids
is in <span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>
direction. Symmetry axis of first spheroid is in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction. Symmetry
axis of second spheroid is in direction <span
class="math inline">\(\hat{\bf y}_{\rm TF}\cos({\tt SHPAR}_5)+\hat{\bf
z}_{\rm TF}\sin({\tt SHPAR}_5)\)</span>, and
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>
is in degrees. If <span><code>SHPAR</code></span><span
class="math inline">\(_6=0.\)</span>, then target axes <span
class="math inline">\({\hat{\bf a}}_1=(1,0,0)_{\rm TF}\)</span>, <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>. If
<span><code>SHPAR</code></span><span
class="math inline">\(_6=1.\)</span>, then axes <span
class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span> are set to principal axes
with largest and 2nd largest moments of inertia assuming spheroids to be
of uniform density.<br />
Origin of TF is located between spheroids, at point of contact.<br />
User must set <span><code>NCOMP</code></span>=2 and provide dielectric
function files for each spheroid.</p>
<h2
id="sph_ani_n-multisphere-target-consisting-of-the-union-of-n-spheres-of-various-materials-possibly-anisotropic">
SPH_ANI_N = Multisphere target consisting of the union of <span
class="math inline">\(N\)</span> spheres of various materials, possibly
anisotropic <span id="sec:SPH_ANI_N" label="sec:SPH_ANI_N"></span></h2>
<p>Spheres may NOT overlap. The relative locations and sizes of these
spheres are defined in an external file, whose name (enclosed in single
quotes) is passed through <span><code>ddscat.par</code></span>. The
length of the file name should not exceed 80 characters. Target axes
<span class="math inline">\(\hat{\bf a}_1\)</span> and <span
class="math inline">\(\hat{\bf a}_2\)</span> are set to be principal
axes of moment of inertia tensor (for uniform density), where <span
class="math inline">\(\hat{\bf a}_1\)</span> corresponds to the largest
eigenvalue, and <span class="math inline">\(\hat{\bf a}_2\)</span> to
the intermediate eigenvalue.<br />
The TF origin is taken to be located at the volume-weighted
centroid.<br />
The pertinent line in <span><code>ddscat.par</code></span> should
read<br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span></span>
<span><em>‘filename’</em></span> (quotes must be used)<br />
where <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span> = target diameter in <span
class="math inline">\(x\)</span> direction (in Target Frame) in units of
<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>=
0 to have <span class="math inline">\(a_1=(1,0,0)_{\rm TF}\)</span>,
<span class="math inline">\(a_2=(0,1,0)_{\rm TF}\)</span> in Target
Frame.<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>=
1 to use principal axes of moment of inertia tensor for <span
class="math inline">\(a_1\)</span> (largest <span
class="math inline">\(I\)</span>) and <span
class="math inline">\(a_2\)</span> (intermediate <span
class="math inline">\(I\)</span>).<br />
<span><em>filename</em></span> is the name of the file specifying the
locations and relative sizes of the spheres.<br />
The overall size of the multisphere target (in terms of numbers of
dipoles) is determined by parameter <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, which is the extent of the
multisphere target in the <span
class="math inline">\(x\)</span>-direction, in units of the lattice
spacing <span class="math inline">\(d\)</span>. The file
<span><em>‘filename’</em></span> should have the following
structure:<br />
<br />
<span class="math inline">\(N\)</span> (= number of spheres)<br />
line of comments (may be blank)<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
<span class="math inline">\(x_1\)</span>  <span
class="math inline">\(y_1\)</span>  <span
class="math inline">\(z_1\)</span>  <span
class="math inline">\(r_1\)</span>  <span
class="math inline">\(Cx_1\)</span>  <span
class="math inline">\(Cy_1\)</span>  <span
class="math inline">\(Cz_1\)</span>  <span
class="math inline">\(\Theta_{{\rm DF},1}\)</span>  <span
class="math inline">\(\Phi_{{\rm DF},1}\)</span>  <span
class="math inline">\(\beta_{{\rm DF},1}\)</span><br />
<span class="math inline">\(x_2\)</span>  <span
class="math inline">\(y_2\)</span>  <span
class="math inline">\(z_2\)</span>  <span
class="math inline">\(r_2\)</span>  <span
class="math inline">\(Cx_2\)</span>  <span
class="math inline">\(Cy_2\)</span>  <span
class="math inline">\(Cz_2\)</span>  <span
class="math inline">\(\Theta_{{\rm DF},2}\)</span>  <span
class="math inline">\(\Phi_{{\rm DF},2}\)</span>  <span
class="math inline">\(\beta_{{\rm DF},2}\)</span><br />
...<br />
<span class="math inline">\(x_N\)</span> <span
class="math inline">\(y_N\)</span> <span
class="math inline">\(z_N\)</span> <span
class="math inline">\(r_N\)</span> <span
class="math inline">\(Cx_N\)</span> <span
class="math inline">\(Cy_N\)</span> <span
class="math inline">\(Cz_N\)</span> <span
class="math inline">\(\Theta_{{\rm DF},N}\)</span> <span
class="math inline">\(\Phi_{{\rm DF},N}\)</span> <span
class="math inline">\(\beta_{{\rm DF},N}\)</span><br />
<br />
where <span class="math inline">\(x_j\)</span>, <span
class="math inline">\(y_j\)</span>, <span
class="math inline">\(z_j\)</span> are the coordinates of the center,
and <span class="math inline">\(r_j\)</span> is the radius of sphere
<span class="math inline">\(j\)</span> (arbitrary units), <span
class="math inline">\(Cx_j\)</span>, <span
class="math inline">\(Cy_j\)</span>, <span
class="math inline">\(Cz_j\)</span> are integers specifying the
“composition” of sphere <span class="math inline">\(j\)</span> in the
<span class="math inline">\(x,y,z\)</span> directions in the “Dielectric
Frame” (see §<a href="#sec:composite anisotropic targets"
data-reference-type="ref"
data-reference="sec:composite anisotropic targets">[sec:composite
anisotropic targets]</a>) of sphere <span
class="math inline">\(j\)</span>, and <span
class="math inline">\(\Theta_{{\rm DF},j}\)</span> <span
class="math inline">\(\Phi_{{\rm DF},j}\)</span> <span
class="math inline">\(\beta_{{\rm DF},j}\)</span> are angles (in
radians) specifying orientation of the dielectric frame (DF) of sphere
<span class="math inline">\(j\)</span> relative to the Target Frame.
Note that <span class="math inline">\(x_j\)</span>, <span
class="math inline">\(y_j\)</span>, <span
class="math inline">\(z_j\)</span>, <span
class="math inline">\(r_j\)</span> (<span
class="math inline">\(j=1,...,N\)</span>) establish only the
<span><em>shape</em></span> of the <span
class="math inline">\(N-\)</span>sphere target, just as for target
option <span><code>NSPHER</code></span>. The actual size (in physical
units) is set by the value of <span class="math inline">\(a_{\rm
eff}\)</span> specified in <span><code>ddscat.par</code></span>, where,
as always, <span class="math inline">\(a_{\rm eff}\equiv (3
V/4\pi)^{1/3}\)</span>, where <span class="math inline">\(V\)</span> is
the volume of material in the target.<br />
User must set <span><code>NCOMP</code></span> to the number of different
dielectric functions being invoked (i.e., the range of <span
class="math inline">\(\{Cx_j,Cy_j,Cz_j\}\)</span>.</p>
<p>Note that while the spheres can be anisotropic and of differing
composition, they can of course also be isotropic and of a single
composition, in which case the relevant lines in the file
<span><em>’filename’</em></span> would be simply<br />
<br />
<span class="math inline">\(N\)</span> (= number of spheres)<br />
line of comments (may be blank)<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
line of comments (may be blank) [N.B.: changed from v7.0.7]<br />
<span class="math inline">\(x_1\)</span>  <span
class="math inline">\(y_1\)</span>  <span
class="math inline">\(z_1\)</span>  <span
class="math inline">\(r_1\)</span>  1  1  1  0  0  0<br />
<span class="math inline">\(x_2\)</span>  <span
class="math inline">\(y_2\)</span>  <span
class="math inline">\(z_2\)</span>  <span
class="math inline">\(r_2\)</span>  1  1  1  0  0  0<br />
...<br />
<span class="math inline">\(x_N\)</span> <span
class="math inline">\(y_N\)</span> <span
class="math inline">\(z_N\)</span> <span
class="math inline">\(r_N\)</span>  1  1  1  0  0  0<br />
</p>
<h3
id="sample-calculation-in-directory-examples_expsph_ani_n"><strong>Sample
calculation in directory examples_exp/SPH_ANI_N</strong></h3>
<p>Subdirectory <span><code>examples_exp/SPH_ANI_N</code></span>
contains <span><code>ddscat.par</code></span> for calculating scattering
by a random aggregate of 64 spheres [aggregated according following the
“BAM2” aggregation process described by <span class="citation"
data-cites="Shen+Draine+Johnson_2008"></span>]. 32 of the spheres are
assumed to consist of “astrosilicate”, and 32 of crystalline graphite,
with random orientations for each of the 32 graphite spheres. Each
sphere is assumed to have a radius <span
class="math inline">\(0.050{\mu{\rm m}}\)</span>. The entire cluster is
represented by <span class="math inline">\(N=7947\)</span> dipoles, or
about 124 dipoles per sphere. Scattering and absorption are calculated
for <span class="math inline">\(\lambda=0.55{\mu{\rm m}}\)</span>.</p>
<h2 id="tetrahdrn-homogeneous-isotropic-tetrahedron"> TETRAHDRN =
Homogeneous, isotropic tetrahedron <span id="sec:TETRAHDRN"
label="sec:TETRAHDRN"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>=length/<span
class="math inline">\(d\)</span> of one edge. Orientation: one face
parallel to <span class="math inline">\(\hat{\bf y}_{\rm TF},\hat{\bf
z}_{\rm TF}\)</span> plane, opposite “vertex" is in <span
class="math inline">\(+\hat{\bf x}_{\rm TF}\)</span> direction, and one
edge is parallel to <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span>. Target axes <span class="math inline">\({\hat{\bf
a}}_1=(1,0,0)_{\rm TF}\)</span> [emerging from one vertex] and <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>
[emerging from an edge] in the TF. User must set
<span><code>NCOMP</code></span>=1.</p>
<h2 id="trnglprsm-triangular-prism-of-homogeneous-isotropic-material">
TRNGLPRSM = Triangular prism of homogeneous, isotropic material <span
id="sec:TRNGLPRSM" label="sec:TRNGLPRSM"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code>, SHPAR</code><span
class="math inline">\(_2\)</span><code>, SHPAR</code><span
class="math inline">\(_3\)</span><code>, SHPAR</code><span
class="math inline">\(_4\)</span></span> <span class="math inline">\(=
a/d\)</span>, <span class="math inline">\(b/a\)</span>, <span
class="math inline">\(c/a\)</span>, <span
class="math inline">\(L/a\)</span><br />
The triangular cross section has sides of width <span
class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, <span
class="math inline">\(c\)</span>. <span class="math inline">\(L\)</span>
is the length of the prism. <span class="math inline">\(d\)</span> is
the lattice spacing. The triangular cross-section has interior angles
<span class="math inline">\(\alpha\)</span>, <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\gamma\)</span> (opposite sides <span
class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, <span
class="math inline">\(c\)</span>) given by <span
class="math inline">\(\cos\alpha=(b^2+c^2-a^2)/2bc\)</span>, <span
class="math inline">\(\cos\beta=(a^2+c^2-b^2)/2ac\)</span>, <span
class="math inline">\(\cos\gamma=(a^2+b^2-c^2)/2ab\)</span>. In the
Target Frame, the prism axis is in the <span
class="math inline">\(\hat{\bf x}\)</span> direction, the normal to the
rectangular face of width <span class="math inline">\(a\)</span> is
(0,1,0), the normal to the rectangular face of width <span
class="math inline">\(b\)</span> is <span
class="math inline">\((0,-\cos\gamma,\sin\gamma)\)</span>, and the
normal to the rectangular face of width <span
class="math inline">\(c\)</span> is <span
class="math inline">\((0,-\cos\beta,-\sin\beta)\)</span>.</p>
<h2
id="uniaxicyl-homogeneous-finite-cylinder-with-uniaxial-anisotropic-dielectric-tensor">
UNIAXICYL = Homogeneous finite cylinder with uniaxial anisotropic
dielectric tensor <span id="sec:UNIAXICYL"
label="sec:UNIAXICYL"></span></h2>
<p><span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span> have same meaning as for
<span><code>CYLINDER1</code></span>. Cylinder axis <span
class="math inline">\(={\hat{\bf a}}_1=(1,0,0)_{\rm TF}\)</span>, <span
class="math inline">\({\hat{\bf a}}_2=(0,1,0)_{\rm TF}\)</span>. It is
assumed that the dielectric tensor <span
class="math inline">\(\epsilon\)</span> is diagonal in the TF, with
<span class="math inline">\(\epsilon_{yy}=\epsilon_{zz}\)</span>. User
must set <span><code>NCOMP</code></span>=2. Dielectric function 1 is for
<span class="math inline">\({\bf E} \parallel {\bf\hat{a}}_1\)</span>
(cylinder axis), dielectric function 2 is for <span
class="math inline">\({\bf E} \perp {\bf\hat{a}}_1\)</span>.</p>
<h2 id="modifying-existing-routines-or-writing-new-ones"> Modifying
Existing Routines or Writing New Ones</h2>
<p>The user should be able to easily modify these routines, or write new
routines, to generate targets with other geometries. The user should
first examine the routine <span><code>target.f90</code></span> and
modify it to call any new target generation routines desired.
Alternatively, targets may be generated separately, and the target
description (locations of dipoles and “composition" corresponding to
x,y,z dielectric properties at each dipole site) read in from a file by
invoking the option <span><code> FROM_FILE</code></span> in
<span><code>ddscat.f90</code></span>.</p>
<p>Note that it will also be necessary to modify the routine
<span><code>reapar.f90</code></span> so that it will accept whatever new
target option is added to the target generation code .</p>
<h2 id="testing-target-generation-using-calltarget"> Testing Target
Generation using CALLTARGET</h2>
<p>It is often desirable to be able to run the target generation
routines without running the entire
<span><strong>DDSCAT</strong></span> code. We have therefore provided a
program <span><code>CALLTARGET</code></span> which allows the user to
generate targets interactively; to create this executable just type<a
href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a> . The program
<span><code>calltarget</code></span> is to be run interactively; the
prompts are self-explanatory. You may need to edit the code to change
the device number <span><code>IDVOUT</code></span> as for
<span><code>DDSCAT</code></span> (see §<a href="#subsec:IDVOUT"
data-reference-type="ref"
data-reference="subsec:IDVOUT">[subsec:IDVOUT]</a> above).</p>
<p>After running, <span><code>calltarget</code></span> will leave behind
an ASCII file <span><code>target.out</code></span> which is a list of
the occupied lattice sites in the last target generated. The format of
<span><code>target.out</code></span> is the same as the format of the
<span><code>shape.dat</code></span> files read if option
<span><code>FROM_FILE</code></span> is used (see above). Therefore you
can simply<br />
<br />
and then use <span><code>DDSCAT</code></span> with the option
<span><code>FROM_FILE</code></span> (or option
<span><code>ANIFRMFIL</code></span> in the case of anisotropic target
materials with arbitrary orientation relative to the Target Frame) in
order to input a target shape generated by
<span><code>CALLTARGET</code></span>.</p>
<p>Note that <span><code>CALLTARGET</code></span> – designed to generate
finite targets – can be used with some of the “PBC” target options (see
§<a href="#sec:target_generation_PBC" data-reference-type="ref"
data-reference="sec:target_generation_PBC">[sec:target_generation_PBC]</a>
below) to generate a list of dipoles in the TUC. At the moment,
<span><code>CALLTARGET</code></span> has support for target options
<span><code>BISLINPBC</code></span>,
<span><code>DSKBLYPBC</code></span>, and
<span><code>DSKRCTPBC</code></span>.</p>
<h1 id="target-generation-periodic-targets">Target Generation: Periodic
Targets <span id="sec:target_generation_PBC"
label="sec:target_generation_PBC"></span></h1>
<p>A periodic target consists of a “Target Unit Cell” (TUC) which is
then repeated in either the <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction, the <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction, or both. Please see <span class="citation"
data-cites="Draine+Flatau_2008a"></span> for illustration of how
periodic targets are assembled out of TUCs, and how the scattering from
these targets in different diffraction orders <span
class="math inline">\(M\)</span> or <span
class="math inline">\((M,N)\)</span> is constrained by the
periodicity.</p>
<p>The following options for the TUC geometry are included in
<span><strong>DDSCAT</strong></span>:</p>
<ul>
<li><p><span><strong>FRMFILPBC</strong></span> : TUC geometry read from
file (§<a href="#sec:FRMFILPBC" data-reference-type="ref"
data-reference="sec:FRMFILPBC">[sec:FRMFILPBC]</a>)</p></li>
<li><p><span><strong>ANIFILPBC</strong></span> : TUC geometry read from
file, anisotropic materials supported (§<a href="#sec:ANIFILPBC"
data-reference-type="ref"
data-reference="sec:ANIFILPBC">[sec:ANIFILPBC]</a>)</p></li>
<li><p><span><strong>BISLINPBC</strong></span> : TUC = bilayer slab (§<a
href="#sec:BISLINPBC" data-reference-type="ref"
data-reference="sec:BISLINPBC">22.3</a>)</p></li>
<li><p><span><strong>CYLNDRPBC</strong></span> : TUC = finite cylinder
(§<a href="#sec:CYLNDRPBC" data-reference-type="ref"
data-reference="sec:CYLNDRPBC">22.4</a>)</p></li>
<li><p><span><strong>DSKBLYPBC</strong></span> : TUC = disk plus bilayer
slab (§<a href="#sec:DSKBLYPBC" data-reference-type="ref"
data-reference="sec:DSKBLYPBC">22.5</a>)</p></li>
<li><p><span><strong>DSKRCTPBC</strong></span> : TUC = disk plus brick
(§<a href="#sec:DSKRCTPBC" data-reference-type="ref"
data-reference="sec:DSKRCTPBC">22.6</a>)</p></li>
<li><p><span><strong>HEXGONPBC</strong></span> : TUC = hexagonal prism
(§<a href="#sec:HEXGONPBC" data-reference-type="ref"
data-reference="sec:HEXGONPBC">22.7</a>)</p></li>
<li><p><span><strong>LYRSLBPBC</strong></span> : TUC = layered slab (up
to 4 layers) (§<a href="#sec:LYRSLBPBC" data-reference-type="ref"
data-reference="sec:LYRSLBPBC">22.8</a>)</p></li>
<li><p><span><strong>RCTGL_PBC</strong></span> : TUC = brick (§<a
href="#sec:RCTGL_PBC" data-reference-type="ref"
data-reference="sec:RCTGL_PBC">22.9</a>)</p></li>
<li><p><span><strong>RECRECPBC</strong></span> : TUC = brick resting on
brick (§<a href="#sec:RECRECPBC" data-reference-type="ref"
data-reference="sec:RECRECPBC">22.10</a>)</p></li>
<li><p><span><strong>SLBHOLPBC</strong></span> : TUC = brick with
cylindrical hole (§<a href="#sec:SLBHOLPBC" data-reference-type="ref"
data-reference="sec:SLBHOLPBC">22.11</a>)</p></li>
<li><p><span><strong>SPHRN_PBC</strong></span> : TUC = N spheres (§<a
href="#sec:SPHRN_PBC" data-reference-type="ref"
data-reference="sec:SPHRN_PBC">22.12</a>)</p></li>
<li><p><span><strong>TRILYRPBC</strong></span> : TUC = three stacked
bricks (§<a href="#sec:TRILYRPBC" data-reference-type="ref"
data-reference="sec:TRILYRPBC">22.13</a>)</p></li>
</ul>
<p>Each option is decribed in detail below.</p>
<h2
id="frmfilpbc-periodic-target-with-tuc-geometry-and-composition-input-from-a-file">
FRMFILPBC = periodic target with TUC geometry and composition input from
a file <span id="sec:FRMFILPBC" label="sec:FRMFILPBC"></span></h2>
<p>The TUC can have arbitrary geometry and inhomogeneous composition,
and is assumed to repeat periodically in either 1-d (y or z) or 2-d (y
and z).<br />
The pertinent line in <span><code>ddscat.par</code></span> should
read<br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span></span>
<span><em>’filename’</em></span> (quotes must be used)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
<span class="math inline">\(P_y/d\)</span>    (<span
class="math inline">\(P_y\)</span> = periodicity in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span> =
<span class="math inline">\(P_z/d\)</span>    (<span
class="math inline">\(P_z\)</span> = periodicity in <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction)<br />
<span><em>filename</em></span> is the name of the file specifying the
locations of the dipoles, and the “composition" at each dipole location.
The composition can be anisotropic, but the dielectric tensor must be
diagonal in the TF. The shape and composition of the TUC are provided
<span><em>exactly</em></span> as for target option
<span><code>FROM</code><span
class="math inline">\(\_\)</span><code>FILE</code></span> – see §<a
href="#sec:FROM_FILE" data-reference-type="ref"
data-reference="sec:FROM_FILE">[sec:FROM_FILE]</a><br />
If <span><code>SHPAR</code></span><span
class="math inline">\(_1=0\)</span> then the target does
<span><em>not</em></span> repeat in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction.<br />
If <span><code>SHPAR</code></span><span
class="math inline">\(_2=0\)</span> then the target does
<span><em>not</em></span> repeat in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction.<br />
</p>
<h3
id="sample-calculation-in-directory-examples_expfrmfilpbc"><strong>Sample
calculation in directory examples_exp/FRMFILPBC</strong></h3>
<p>Subdirectory <span><code>examples_exp/FRMFILPBC</code></span>
contains <span><code>ddscat.par</code></span> and
<span><code>shape.dat</code></span> for the same scattering calculation
as in <span><code>examples_exp/DSKRCTPBC</code></span>: a slab of
Si<span class="math inline">\(_3\)</span>N<span
class="math inline">\(_4\)</span> glass, thickness <span
class="math inline">\(0.05{\mu{\rm m}}\)</span>, supporting a periodic
array of Au disks, with center-to-center distance <span
class="math inline">\(0.08{\mu{\rm m}}\)</span>. Here the slab and Au
disk geometry is input via a file <span><code>shape.dat</code></span>.
<span><code>shape.dat</code></span> is a copy of the file
<span><code>target.out</code></span> created after running the
calculation in <span><code>examples_exp/DSKRCTPBC</code></span>.</p>
<h2
id="anifilpbc-general-anisotropic-periodic-target-with-tuc-geometry-and-composition-input-from-a-file">
ANIFILPBC = general anisotropic periodic target with TUC geometry and
composition input from a file <span id="sec:ANIFILPBC"
label="sec:ANIFILPBC"></span> </h2>
<p>The TUC can have arbitrary geometry and inhomogeneous composition,
and is assumed to repeat periodically in either 1-d (y or z) or 2-d (y
and z).<br />
The pertinent line in <span><code>ddscat.par</code></span> should
read<br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span></span>
<span><em>’filename’</em></span> (quotes must be used)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
<span class="math inline">\(P_y/d\)</span>    (<span
class="math inline">\(P_y\)</span> = periodicity in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span> =
<span class="math inline">\(P_z/d\)</span>    (<span
class="math inline">\(P_z\)</span> = periodicity in <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction)<br />
<span><em>filename</em></span> is the name of the file specifying the
locations of the dipoles, and the "composition" at each dipole location.
The composition can be anisotropic, and the dielectric tensor need not
be diagonal in the TF. The shape and composition of the TUC are provided
<span><em>exactly</em></span> as for target option
<span><code>ANIFRMFIL</code></span> – see §<a href="#sec:ANIFRMFIL"
data-reference-type="ref"
data-reference="sec:ANIFRMFIL">[sec:ANIFRMFIL]</a><br />
If <span><code>SHPAR</code></span><span
class="math inline">\(_1=0\)</span> then the target does
<span><em>not</em></span> repeat in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction.<br />
If <span><code>SHPAR</code></span><span
class="math inline">\(_2=0\)</span> then the target does
<span><em>not</em></span> repeat in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction.<br />
</p>
<h2 id="sec:BISLINPBC"> BISLINPBC = Bi-Layer Slab with Parallel
Lines</h2>
<p>The target consists of a bi-layer slab, on top of which there is a
“line” with rectangular cross-section.<br />
The “line” on top is composed of material 1, has height <span
class="math inline">\(X_1\)</span> (in the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> direction), width
<span class="math inline">\(Y_1\)</span> (in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction), and is
infinite in extent in the <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction.<br />
The bilayer slab has width <span class="math inline">\(Y_2\)</span> (in
the <span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>
direction). It is consists of a layer of thickness <span
class="math inline">\(X_2\)</span> of material 2, on top of a layer of
material 3 with thickness <span
class="math inline">\(X_3\)</span>.<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
<span class="math inline">\(X_1/d\)</span>     (<span
class="math inline">\(X_1\)</span> = thickness of line)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span> =
<span class="math inline">\(Y_1/d\)</span>     (<span
class="math inline">\(Y_1\)</span> = width of line)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
<span class="math inline">\(X_2/d\)</span>     (<span
class="math inline">\(X_2\)</span> = thickness of upper layer of
slab)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
<span class="math inline">\(X_3/d\)</span>     (<span
class="math inline">\(X_3\)</span> = thickness of lower layer of
slab)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
<span class="math inline">\(Y_2/d\)</span>     (<span
class="math inline">\(Y_2\)</span> = width of slab)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
<span class="math inline">\(P_y/d\)</span>     (<span
class="math inline">\(P_y\)</span> = periodicity in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction).<br />
If <span><code>SHPAR</code></span><span
class="math inline">\(_6\)</span> = 0, the target is NOT periodic in the
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction,
consisting of a single column, infinite in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction.</p>
<h2 id="sec:CYLNDRPBC"> CYLNDRPBC = Target consisting of homogeneous
cylinder repeated in target y and/or z directions using periodic
boundary conditions</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of an infinite array of cylinders. The individual
cylinders are assumed to be homogeneous and isotropic, just as for
option RCTNGL (see §<a href="#sec:RCTGLPRSM" data-reference-type="ref"
data-reference="sec:RCTGLPRSM">[sec:RCTGLPRSM]</a>).  <br />
Let us refer to a single cylinder as the Target Unit Cell (TUC). The TUC
is then repeated in the target y- and/or z-directions, with
periodicities <span><code>PYD</code></span><span
class="math inline">\(\times d\)</span> and
<span><code>PZD</code></span><span class="math inline">\(\times
d\)</span>, where <span class="math inline">\(d\)</span> is the lattice
spacing. To repeat in only one direction, set either
<span><code>PYD</code></span> or <span><code>PZD</code></span> to
zero.<br />
This option requires 5 shape parameters: The pertinent line in
<span><code>ddscat.par</code></span> should read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code><span
class="math inline">\(_3\)</span><code> SHPAR</code><span
class="math inline">\(_4\)</span><code> SHPAR</code></span><span
class="math inline">\(_5\)</span><br />
 <br />
where <span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code>,SHPAR</code><span
class="math inline">\(_2\)</span><code>,SHPAR</code><span
class="math inline">\(_3\)</span><code>,SHPAR</code><span
class="math inline">\(_4\)</span><code>,SHPAR</code><span
class="math inline">\(_5\)</span></span> are numbers:<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
cylinder length along axis (in units of <span
class="math inline">\(d\)</span>) in units of <span
class="math inline">\(d\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
cylinder diameter/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
1 for cylinder axis <span class="math inline">\(\parallel \hat{\bf
x}_{\rm TF}\)</span><br />
= 2 for cylinder axis <span class="math inline">\(\parallel \hat{\bf
y}_{\rm TF}\)</span><br />
= 3 for cylinder axis <span class="math inline">\(\parallel \hat{\bf
z}_{\rm TF}\)</span> (see below)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
<span><code>PYD</code></span> = periodicity/<span
class="math inline">\(d\)</span> in <span class="math inline">\(\hat{\bf
y}_{\rm TF}\)</span> direction ( = 0 to suppress repetition)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
<span><code>PZD</code></span> = periodicity/<span
class="math inline">\(d\)</span> in <span class="math inline">\(\hat{\bf
z}_{\rm TF}\)</span> direction ( = 0 to suppress repetition)<br />
 <br />
The overall size of the TUC (in terms of numbers of dipoles) is
determined by parameters <span><code>SHPAR1</code></span> and
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>.
The orientation of a single cylinder is determined by
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>.
The periodicity in the TF <span class="math inline">\(y\)</span> and
<span class="math inline">\(z\)</span> directions is determined by
parameters <span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span> and
<span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span>.<br />
The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>, with
the usual correspondence <span
class="math inline">\(d=(4\pi/3N)^{1/3}{a}_{\rm eff}\)</span>, where
<span class="math inline">\(N\)</span> is the number of dipoles in the
TUC.</p>
<p>With target option <span><code>CYLNDRPBC</code></span>, the target
becomes a periodic structure, of infinite extent.</p>
<ul>
<li><p>If <span class="math inline">\({\tt NPY}&gt;0\)</span> and <span
class="math inline">\({\tt NPZ}=0\)</span>, then the target cylindrical
TUC repeats in the <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction, with periodicity <span
class="math inline">\({\tt NPY}\times d\)</span>.</p></li>
<li><p>If <span class="math inline">\({\tt NPY}=0\)</span> and <span
class="math inline">\({\tt NPZ}&gt;0\)</span> then the target
cylindrical TUC repeats in the <span class="math inline">\(\hat{\bf
z}_{\rm TF}\)</span> direction, with periodicity <span
class="math inline">\({\tt NPZ}\times d\)</span>.</p></li>
<li><p>If <span class="math inline">\({\tt NPY}&gt;0\)</span> and <span
class="math inline">\({\tt NPZ}&gt;0\)</span> then the target
cylindrical TUC repeats in the <span class="math inline">\(\hat{\bf
y}_{\rm TF}\)</span> direction, with periodicity <span
class="math inline">\({\tt NPY}\times d\)</span>, and in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction, with
periodicity <span class="math inline">\({\tt NPZ}\times
d\)</span>.</p></li>
</ul>
<p><span><strong>Target Orientation:</strong></span> The target axes (in
the TF) are set to <span class="math inline">\({\hat{\bf a}}_1 =
(1,0,0)_{\rm TF}\)</span> and <span class="math inline">\({\hat{\bf
a}}_2 = (0,1,0)_{\rm TF}\)</span>. Note that <span
class="math inline">\({\hat{\bf a}}_1\)</span> does
<span><strong>not</strong></span> necessarily coincide with the cylinder
axis: individual cylinders may have any of 3 different orientations in
the TF.<br />
 <br />
<span><strong>Example 1:</strong></span> One could construct a single
infinite cylinder with the following two lines in
<span><code>ddscat.par</code></span>:<br />
 <br />
100 1 100<br />
1.0   100.49   2   1.0   0.<br />
 <br />
The first line ensures that there will be enough memory allocated to
generate the target. The TUC would be a thin circular “slice” containing
just one layer of dipoles. The diameter of the circular slice would be
about 100.49<span class="math inline">\(d\)</span> in extent, so the TUC
would have approximately <span
class="math inline">\((\pi/4)\times(100.49)^2=7931\)</span> dipoles
(7932 in the actual realization) within a <span
class="math inline">\(100\times1\times100\)</span> “extended target
volume”. The TUC would be oriented with the cylinder axis in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction
(<span><code>SHPAR3=2</code></span>) and the structure would repeat in
the <span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction
with a period of <span class="math inline">\(1.0\times d\)</span>.
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>=0
means that there will be no repetition in the <span
class="math inline">\(z\)</span> direction. As noted above, the “target
axis” vector <span class="math inline">\(\hat{\bf a}_1 = \hat{\bf
x}_{\rm TF}\)</span>.</p>
<p>Note that <span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span>, <span><code>SHPAR</code></span><span
class="math inline">\(_2\)</span>, <span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span>, and
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>
need not be integers. However, <span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span>, determining the orientation of the
cylinders in the TF, can only take on the values 1,2,3.</p>
<p>The orientation of the incident radiation relative to the target is,
as for all other targets, set by the usual orientation angles <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the periodic structure.</p>
<h3
id="sample-calculation-in-directory-examples_expcylndrpbc"><strong>Sample
calculation in directory examples_exp/CYLNDRPBC</strong></h3>
<p>The subdirectory <span><code>examples_exp/CYLNDRPBC</code></span>
contains <span><code>ddscat.par</code></span> for calculating scattering
by an infinite cylinder with <span
class="math inline">\(m=1.33+0.01i\)</span> for <span
class="math inline">\(x\equiv 2\pi R/\lambda=5\)</span>, where <span
class="math inline">\(R\)</span> is the cylinder radius. Thus <span
class="math inline">\(R=x\lambda/2\pi\)</span>. We set <span
class="math inline">\(\lambda=1\)</span>.</p>
<p>The TUC is a disk of thickness <span
class="math inline">\(d\)</span>. The sample calculation calls for the
cylinder diameter <span class="math inline">\(2R\)</span> to be <span
class="math inline">\(64.499d\)</span>, where <span
class="math inline">\(d\)</span> is the dipole spacing.</p>
<p>With this choice, the TUC (disk of thickness <span
class="math inline">\(d\)</span>) turns out to be represented by <span
class="math inline">\(N=3260\)</span> dipoles. Thus <span
class="math inline">\(\pi R^2 = N d^2\)</span>, or <span
class="math inline">\(d=(\pi/N)^{1/2} R\)</span>.</p>
<p>The volume of the TUC is <span class="math inline">\(V=Nd^3\)</span>.
The effective radius of the TUC is <span class="math inline">\({a}_{\rm
eff}=(3V/4\pi)^{1/3} =
(3N/4\pi)^{1/3} d =
(3N/4\pi)^{1/3} (\pi/N)^{1/2} R =
(3/4\pi)^{1/3} \pi^{1/2} R N^{-1/6}\)</span>. With <span
class="math inline">\(R=x\lambda/2\pi\)</span> we have <span
class="math inline">\({a}_{\rm eff}=(3/4\pi)^{1/3} \pi^{1/2}
(x\lambda/2\pi) N^{-1/6} = 0.22723\)</span> for <span
class="math inline">\(x=5\)</span> and <span
class="math inline">\(\lambda=1\)</span>.</p>
<p>With the standard error tolerance
<span><code>TOL=1.0e-5</code></span>, the calculation converges in
<span><code>IT=7</code></span> iterations for each incident
polarization. The scattering properties are reported in
<span><code>w000r000k000.sca</code></span>. The calculation used
required 40 MB of RAM, and used 39 cpu sec on a 2.53 GHz cpu.</p>
<h2 id="sec:DSKBLYPBC"> DSKBLYPBC = Target consisting of a periodic
array of disks on top of a two-layer rectangular slabs.</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of a periodic or biperiodic array of Target Unit Cells
(TUCs), each TUC consisting of a disk of composition 1 resting on top of
a rectangular block consisting of two layers: composition 2 on top and
composition 3 below. Materials 1, 2, and 3 are assumed to be homogeneous
and isotropic.  <br />
This option requires 8 shape parameters: The pertinent line in
<span><code>ddscat.par</code></span> should read<br />
 <br />
<span class="math inline">\({\tt SHPAR}_1~~{\tt SHPAR}_2~~{\tt
SHPAR}_3~~{\tt SHPAR}_4~~{\tt SHPAR}_5~~{\tt SHPAR}_6~~{\tt
SHPAR}_7~~{\tt SHPAR}_8\)</span><br />
 <br />
where<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
disk thickness in <span class="math inline">\(x\)</span> direction (in
Target Frame) in units of <span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span> =
(disk diameter)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
(upper slab thickness)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
(lower slab thickness)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
(slab extent in <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
(slab extent in <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span> =
period in <span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>
direction/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_8\)</span> =
period in <span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>
direction/<span class="math inline">\(d\)</span><br />
 <br />
The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>.<br />
 <br />
The “computational volume” is determined by<br />
(<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code>+SHPAR</code><span
class="math inline">\(_3\)</span><code>+SHPAR</code><span
class="math inline">\(_4\)</span></span>)<span
class="math inline">\(\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_5\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_6\)</span>.<br />
 <br />
The lower surface of the cylindrical disk is in the <span
class="math inline">\(x=0\)</span> plane. The upper surface of the slab
is also in the <span class="math inline">\(x=0\)</span> plane. It is
required that <span class="math inline">\({\tt SHPAR}_2\leq{\rm
min}({\tt SHPAR}_4,{\tt SHPAR}_5)\)</span>.<br />
 <br />
The Target Frame origin (0,0,0) is located where the symmetry axis of
the disk intersects the <span class="math inline">\(x=0\)</span> plane
(the upper surface of the slab, and the lower surface of the
disk).<br />
In the Target Frame, dipoles representing the disk are located at<br />
<span class="math inline">\(x/d = 0.5 , 1.5 ,...,
        [{\rm int}({\tt SHPAR}_1+0.5)-0.5]\)</span><br />
and at <span class="math inline">\((y,z)\)</span> values<br />
<span class="math inline">\(y/d = \pm 0.5, \pm 1.5, ...\)</span>
and<br />
<span class="math inline">\(z/d = \pm 0.5, \pm 1.5, ...\)</span>
satisfying<br />
<span class="math inline">\((y^2+z^2) \leq ({\tt SHPAR}_2/2)^2
d^2\)</span>.</p>
<p>Dipoles representing the rectangular slab are located at <span
class="math inline">\((x/d,y/d,z/d)=(j_x+0.5,j_y+\Delta y,j_z+\Delta
z)\)</span>, where <span class="math inline">\(j_x\)</span>, <span
class="math inline">\(j_y\)</span>, and <span
class="math inline">\(j_z\)</span> are integers. <span
class="math inline">\(\Delta y=0\)</span> or 0.5 depending on whether
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>
is even or odd. <span class="math inline">\(\Delta z=0\)</span> or 0.5
depending on whether <span><code>SHPAR</code></span><span
class="math inline">\(_6\)</span> is even or odd.<br />
 <br />
The TUC is repeated in the target y- and z-directions, with
periodicities <span><code>SHPAR</code><span
class="math inline">\(_7\)</span></span><span
class="math inline">\(\times d\)</span> and
<span><code>SHPAR</code></span><span
class="math inline">\(_8\)</span><span class="math inline">\(\times
d\)</span>.</p>
<p>As always, the physical size of the target is fixed by specifying the
value of the effective radius <span class="math inline">\({a}_{\rm
eff}\equiv(3V_{\rm TUC}/4\pi)^{1/3}\)</span>, where <span
class="math inline">\(V_{\rm TUC}\)</span> is the total volume of solid
material in one TUC. For this geometry, the number of dipoles in the
target will be approximately <span class="math display">\[N=
        (\pi/4)\times{\tt SHPAR}_1\times({\tt SHPAR}_2)^2+
        [{\tt SHPAR}_3+{\tt SHPAR}_4]
        \times{\tt SHPAR}_5\times{\tt SHPAR}_6\]</span> although the
exact number may differ because of the dipoles are required to be
located on a rectangular lattice. The dipole spacing <span
class="math inline">\(d\)</span> in physical units is determined from
the specified value of <span class="math inline">\({a}_{\rm
eff}\)</span> and the number <span class="math inline">\(N\)</span> of
dipoles in the target: <span
class="math inline">\(d=(4\pi/3N)^{1/3}{a}_{\rm eff}\)</span>.<br />
The target axes (in the TF) are set to <span
class="math inline">\({\hat{\bf a}}_1 = \hat{\bf x}_{\rm TF}=
(1,0,0)_{\rm TF}\)</span> – i.e., normal to the “slab” – and <span
class="math inline">\({\hat{\bf a}}_2 = \hat{\bf y}_{\rm TF}=
(0,1,0)_{\rm TF}\)</span>. The orientation of the incident radiation
relative to the target is, as for all other targets, set by the usual
orientation angles <span class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the slab.</p>
<h2 id="sec:DSKRCTPBC"> DSKRCTPBC = Target consisting of homogeneous
rectangular brick plus a disk, extended in target y and z directions
using periodic boundary conditions</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of a biperiodic array of Target Unit Cells. Each
Target Unit Cell (TUC) consists of a disk of composition 1 resting on
top of a rectangular block of composition 2. Materials 1 and 2 are
assumed to be homogeneous and isotropic.  <br />
The cylindrical disk has thickness <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span><span
class="math inline">\(\times d\)</span> in the x-direction, and diameter
<span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span><span
class="math inline">\(\times d\)</span>. The rectangular block is
assumed to have thickness <span><code>SHPAR</code></span><span
class="math inline">\(_3\)</span><span
class="math inline">\(\times\)</span>d in the x-direction, extent
<span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span><span class="math inline">\(\times
d\)</span> in the y-direction, and extent
<span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span><span class="math inline">\(\times
d\)</span> in the z-direction. The lower surface of the cylindrical disk
is in the <span class="math inline">\(x=0\)</span> plane. The upper
surface of the slab is also in the <span
class="math inline">\(x=0\)</span> plane. It is required that
<span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span><span
class="math inline">\(\leq\)</span>min(<span><code>SHPAR4,SHPAR</code></span><span
class="math inline">\(_5\)</span>).</p>
<p>The Target Frame origin (0,0,0) is located where the symmetry axis of
the disk intersects the <span class="math inline">\(x=0\)</span> plane
(the upper surface of the slab, and the lower surface of the disk). In
the Target Frame, dipoles representing the rectangular block are located
at <span class="math inline">\((x/d,y/d,z/d)=(j_x+0.5,j_y+\Delta
y,j_z+\Delta z)\)</span>, where <span
class="math inline">\(j_x\)</span>, <span
class="math inline">\(j_y\)</span>, and <span
class="math inline">\(j_z\)</span> are integers. <span
class="math inline">\(\Delta y=0\)</span> or 0.5 depending on whether
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span>
is even or odd. <span class="math inline">\(\Delta z=0\)</span> or 0.5
depending on whether <span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span> is even or odd.<br />
<span class="math inline">\(j_x = -[{\rm int}({\tt SHPAR}_3+0.5)] , ...
, -1\)</span>.<br />
<span class="math inline">\(j_y = -[{\rm int}(0.5\times{\tt
SHPAR}_4-0.5) + 1]\)</span> , ... , <span class="math inline">\(j_z =
-[{\rm int}({\tt SHPAR}_4+0.5)-0.5]\)</span><br />
<span class="math inline">\(y/d = -[{\rm int}(0.5\times{\tt
SHPAR}_4+0.5)-0.5] , ... ,
                    [{\rm int}(0.5\times{\tt
SHPAR}_4+0.5)-0.5]\)</span><br />
<span class="math inline">\(z/d =  -[{\rm int}(0.5\times{\tt
SHPAR}_5+0.5)-0.5] , ... ,
                     [{\rm int}(0.5\times{\tt
SHPAR}_5+0.5)-0.5]\)</span><br />
where <span class="math inline">\({\rm int}(x)\)</span> is the greatest
integer less than or equal to <span class="math inline">\(x\)</span>.
Dipoles representing the disk are located at<br />
<span class="math inline">\(x/d = 0.5 , 1.5 ,...,
        [{\rm int}({\tt SHPAR}_4+0.5)-0.5]\)</span><br />
and at <span class="math inline">\((y,z)\)</span> values<br />
<span class="math inline">\(y/d = \pm 0.5, \pm 1.5, ...\)</span>
and<br />
<span class="math inline">\(z/d = \pm 0.5, \pm 1.5, ...\)</span>
satisfying<br />
<span class="math inline">\((y^2+z^2) \leq ({\tt SHPAR}_5/2)^2
d^2\)</span>.</p>
<p>The TUC is repeated in the target y- and z-directions, with
periodicities <span><code>SHPAR</code><span
class="math inline">\(_6\)</span></span><span
class="math inline">\(\times d\)</span> and
<span><code>SHPAR</code></span><span
class="math inline">\(_7\)</span><span class="math inline">\(\times
d\)</span>. As always, the physical size of the target is fixed by
specifying the value of the effective radius <span
class="math inline">\({a}_{\rm eff}\equiv(3V_{\rm
TUC}/4\pi)^{1/3}\)</span>, where <span class="math inline">\(V_{\rm
TUC}\)</span> is the total volume of solid material in one TUC. For this
geometry, the number of dipoles in the target will be approximately
<span class="math inline">\(N=[{\tt SHPAR}_1\times{\tt
SHPAR}_2\times{\tt SHPAR}_3 +
        (\pi/4)(({\tt SHPAR}_4)^2\times{\tt SHPAR}_5)]\)</span>,
although the exact number may differ because of the dipoles are required
to be located on a rectangular lattice. The dipole spacing <span
class="math inline">\(d\)</span> in physical units is determined from
the specified value of <span class="math inline">\({a}_{\rm
eff}\)</span> and the number <span class="math inline">\(N\)</span> of
dipoles in the target: <span
class="math inline">\(d=(4\pi/3N)^{1/3}{a}_{\rm eff}\)</span>. This
option requires 7 shape parameters: The pertinent line in
<span><code>ddscat.par</code></span> should read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code><span
class="math inline">\(_3\)</span><code> SHPAR</code><span
class="math inline">\(_4\)</span><code> SHPAR</code><span
class="math inline">\(_5\)</span><code> SHPAR</code><span
class="math inline">\(_6\)</span><code> SHPAR</code><span
class="math inline">\(_7\)</span></span><br />
 <br />
where<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
[disk thickness (in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)]/<span class="math inline">\(d\)</span>
[material 1]<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
(disk diameter)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
(brick thickness in <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span> [material
2]<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
(brick length in <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
(brick length in <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction)/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
periodicity in <span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>
direction/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span> =
periodicity in <span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>
direction/<span class="math inline">\(d\)</span><br />
 <br />
The overall extent of the TUC (the “computational volume”) is determined
by parameters <span><code>(SHPAR1 +SHPAR4), max(SHPAR</code><span
class="math inline">\(_2\)</span><code>,SHPAR</code><span
class="math inline">\(_4\)</span></span>), and
<span><code>max(SHPAR</code><span
class="math inline">\(_3\)</span><code>,SHPAR</code><span
class="math inline">\(_5\)</span><code>)</code></span>. The periodicity
in the TF <span class="math inline">\(y\)</span> and <span
class="math inline">\(z\)</span> directions is determined by parameters
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span>
and <span><code>SHPAR</code></span><span
class="math inline">\(_7\)</span>.<br />
The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g. cm
– the same unit as used to specify the wavelength), specified in the
file <span><code>ddscat.par</code></span>.</p>
<p>The target is a periodic structure, of infinite extent in the target
y- and z- directions. The target axes (in the TF) are set to <span
class="math inline">\({\hat{\bf a}}_1 = \hat{\bf x}_{\rm TF}=
(1,0,0)_{\rm TF}\)</span> – i.e., normal to the “slab” – and <span
class="math inline">\({\hat{\bf a}}_2 = \hat{\bf y}_{\rm TF}=
(0,1,0)_{\rm TF}\)</span>. The orientation of the incident radiation
relative to the target is, as for all other targets, set by the usual
orientation angles <span class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the slab.</p>
<h3
id="sample-calculation-in-directory-examples_expdskrctpbc"><strong>Sample
calculation in directory examples_exp/DSKRCTPBC</strong></h3>
<p>Subdirectory <span><code>examples_exp/DSKRCTPBC</code></span>
contains <span><code>ddscat.par</code></span> for calculating scattering
by a <span class="math inline">\(0.0500{\mu{\rm m}}\)</span> thick
Si<span class="math inline">\(_3\)</span>N<span
class="math inline">\(_4\)</span> slab supporting a doubly periodic
array of Au disks, with periodicity <span
class="math inline">\(0.0800{\mu{\rm m}}\)</span>, disk diameter <span
class="math inline">\(0.0400{\mu{\rm m}}\)</span>, and disk height <span
class="math inline">\(0.0200{\mu{\rm m}}\)</span>, for light with
wavelength <span class="math inline">\(\lambda=0.5320{\mu{\rm
m}}\)</span>.</p>
<p>The TUC consists of a rectangular block of Si<span
class="math inline">\(_3\)</span>N<span
class="math inline">\(_4\)</span>, of dimension <span
class="math inline">\(15d\times24d\times24d\)</span> (8640 dipoles),
supporting an Au disk of thickness <span
class="math inline">\(6d\)</span> and a diameter <span
class="math inline">\(\sim\)</span><span
class="math inline">\(12d\)</span> (672 dipoles). With a “diameter” of
only <span class="math inline">\(12d\)</span>, the cross section of the
“disk” is only roughly circular; each layer of the disk contains 112
dipoles.</p>
<p>The volume of the ideal TUC is <span class="math inline">\(V_{\rm
TUC}=(0.08)^2\times0.05 + \pi
(0.02)^2\times0.02=3.4513\times10^{-4}{\mu{\rm m}}^3\)</span>. Thus we
set <span class="math inline">\({a}_{\rm eff}=(3V_{\rm
TUC}/4\pi)^{1/3}=4.3514\times10^{-2}{\mu{\rm m}}\)</span>. The DDA
calculation has <span class="math inline">\(kd=.039377\)</span>.</p>
<p>The radiation is incident at an angle of <span
class="math inline">\(60^\circ\)</span> relative to the surface normal.
The entire calculation required 2400 cpu sec on a 2.53 GHz cpu. Most of
the cpu time was spent computing the effective <span
class="math inline">\({\bf A}\)</span> matrix for the calculation, which
requires extensive summations; once this was obtained, the solution was
found in 31 and 33 iterations, respectively, for the two incident
polarizations, requiring <span class="math inline">\(\sim\)</span>8
cpu sec.</p>
<h2 id="sec:HEXGONPBC"> HEXGONPBC = Target consisting of homogeneous
hexagonal prism repeated in target y and/or z directions using periodic
boundary conditions</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of a periodic or biperiodic array of hexagonal prisms.
The individual prisms are assumed to be homogeneous and isotropic, just
as for option RCTNGL (see §<a href="#sec:RCTGLPRSM"
data-reference-type="ref"
data-reference="sec:RCTGLPRSM">[sec:RCTGLPRSM]</a>).  <br />
Let us refer to a single hexagonal prism as the Target Unit Cell (TUC).
The TUC is then repeated in the target y- and z-directions, with
periodicities <span><code>PYD</code></span><span
class="math inline">\(\times d\)</span> and
<span><code>PZD</code></span><span class="math inline">\(\times
d\)</span>, where <span class="math inline">\(d\)</span> is the lattice
spacing. To repeat in only one direction, set either
<span><code>PYD</code></span> or <span><code>PZD</code></span> to
zero.<br />
This option requires 5 shape parameters: The pertinent line in
<span><code>ddscat.par</code></span> should read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR3 SHPAR4 SHPAR</code></span><span
class="math inline">\(_5\)</span><br />
 <br />
where<span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>,
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span>,
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>
are numbers:<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
prism length along prism axis (in units of <span
class="math inline">\(d\)</span>) in units of <span
class="math inline">\(d\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
2<span class="math inline">\(\times\)</span>length of one hexagonal
side/<span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
1,2,3,4,5 or 6 to specify prism orientation in the TF (see below)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
<span><code>PYD</code></span> = periodicity in TF <span
class="math inline">\(y\)</span> direction/<span
class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
<span><code>PZD</code></span> = periodicity in TF <span
class="math inline">\(z\)</span> direction/<span
class="math inline">\(d\)</span><br />
 <br />
The overall size of the TUC (in terms of numbers of dipoles) is
determined by parameters <span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code>, SHPAR</code><span
class="math inline">\(_2\)</span></span>, and
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>.
The periodicity in the TF <span class="math inline">\(y\)</span> and
<span class="math inline">\(z\)</span> directions is determined by
parameters <span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span> and
<span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span>.<br />
The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>, with
the usual correspondence <span
class="math inline">\(d=(4\pi/3N)^{1/3}{a}_{\rm eff}\)</span>, where
<span class="math inline">\(N\)</span> is the number of dipoles in the
TUC.</p>
<p>With target option <span><code>HEXGONPBC</code></span>, the target
becomes a periodic structure, of infinite extent in the target y- and z-
directions (assuming both <span><code>NPY</code></span> and
<span><code>NPZ</code></span> are nonzero).</p>
<p>The target axes (in the TF) are set to <span
class="math inline">\({\hat{\bf a}}_1 = \hat{\bf x}_{\rm TF}=
(1,0,0)_{\rm TF}\)</span> – i.e., normal to the “slab” – and <span
class="math inline">\({\hat{\bf a}}_2 = \hat{\bf y}_{\rm TF}=
(0,1,0)_{\rm TF}\)</span>.</p>
<p>The individual hexagons may have any of 6 different orientations
relative to the slab: Let unit vectors <span
class="math inline">\(\hat{\bf h}\)</span> be <span
class="math inline">\(\parallel\)</span> to the axis of the hexagonal
prism, and let unit vector <span class="math inline">\(\hat{\bf
f}\)</span> be normal to one of the rectangular faces of the hexagonal
prism. Then<br />
<span><code>SHPAR3=1</code></span> for <span
class="math inline">\(\hat{\bf h}\parallel \hat{\bf x}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf f}\parallel \hat{\bf
y}_{\rm TF}\)</span><br />
<span><code>SHPAR3=2</code></span> for <span
class="math inline">\(\hat{\bf h}\parallel \hat{\bf x}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf f}\parallel \hat{\bf
z}_{\rm TF}\)</span><br />
<span><code>SHPAR3=3</code></span> for <span
class="math inline">\(\hat{\bf h}\parallel \hat{\bf y}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf f}\parallel \hat{\bf
x}_{\rm TF}\)</span><br />
<span><code>SHPAR3=4</code></span> for <span
class="math inline">\(\hat{\bf h}\parallel \hat{\bf y}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf f}\parallel \hat{\bf
z}_{\rm TF}\)</span><br />
<span><code>SHPAR3=5</code></span> for <span
class="math inline">\(\hat{\bf h}\parallel \hat{\bf z}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf f}\parallel \hat{\bf
x}_{\rm TF}\)</span><br />
<span><code>SHPAR3=6</code></span> for <span
class="math inline">\(\hat{\bf h}\parallel \hat{\bf z}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf f}\parallel \hat{\bf
y}_{\rm TF}\)</span><br />
For example, one could construct a single infinite hexagonal column with
the following line in <span><code>ddscat.par</code></span>:<br />
 <br />
2.0   100.0   3   2.0   0.<br />
 <br />
The TUC would be a thin hexagonal “slice” containing two layers of
dipoles. The edges of the hexagon would be about 50<span
class="math inline">\(d\)</span> in extent, so the TUC would have
approximately <span
class="math inline">\((3\sqrt{3}/2)\times50^2\times2=
    12990\)</span> dipoles (13024 in the actual realization) within a
<span class="math inline">\(90\times2\times100\)</span> “extended target
volume”. The TUC would be oriented with the hexagonal axis in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction, with
<span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> normal to a
rectangular faces of the prism (<span><code>SHPAR3=3</code></span>), and
the structure would repeat in the <span class="math inline">\(\hat{\bf
y}_{\rm TF}\)</span> direction with a period of <span
class="math inline">\(2\times d\)</span>
(<span><code>SHPAR4=2.0</code></span>).
<span><code>SHPAR5=0</code></span> means that there will be no
repetition in the <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction.</p>
<p>Note that <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, <span><code>SHPAR</code><span
class="math inline">\(_2\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span>,
and <span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span> need not be integers. However,
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>,
determining the orientation of the prisms in the TF, can only take on
the values 1,2,3,4,5,6.</p>
<p><span><strong>Important Note:</strong></span> For technical reasons,
<span><code>PYD</code></span> and <span><code>PZD</code></span> must not
be smaller than the “extended” target extent in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> and <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> directions. When the
GPFAFT option is used for the 3-dimensional FFT calculations, the
extended target volume always has dimensions/<span
class="math inline">\(d = 2^a3^b5^c\)</span>, where <span
class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, and <span
class="math inline">\(c\)</span> are nonnegative integers, with
(dimension/<span class="math inline">\(d)\geq 1\)</span>).</p>
<p>The orientation of the incident radiation relative to the target is,
as for all other targets, set by the usual orientation angles <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the periodic structure.</p>
<h2 id="sec:LYRSLBPBC"> LYRSLBPBC = Target consisting of layered slab,
extended in target y and z directions using periodic boundary
conditions</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of an array of multilayer bricks, layered in the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> direction. The size
of each brick in the <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> and <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction is specified. Up to 4 layers are allowed.<br />
The bricks are repeated in the <span class="math inline">\(\hat{\bf
y}_{\rm TF}\)</span> and <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> direction with a specified periodicity. If <span
class="math inline">\(L_y=P_y\)</span> and <span
class="math inline">\(L_z=P_z\)</span>, then the target consists of a
continuous multilayer slab. For this case, it is most economical to set
<span class="math inline">\(L_y/d=L_z/d=P_y/d=P_z/d=1\)</span>.<br />
If <span class="math inline">\(P_y=0\)</span>, then repetition in the
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction is
suppressed – the target repeats only in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction.<br />
If <span class="math inline">\(P_z=0\)</span>, then repetition in the
<span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction is
suppressed – the target repeats only in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction.<br />
The upper surface of the slab is asssume to be located at <span
class="math inline">\(x_{\rm TF}=0\)</span>. The lower surface of the
slab is at <span class="math inline">\(x_{\rm
TF}=-L_x=-\)</span> <span><code>SHPAR1</code></span><span
class="math inline">\(\times d\)</span>.<br />
The multilayer slab geometry is specified with 9 parameters. The
pertinent line in <span><code>ddscat.par</code></span> should read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code><span
class="math inline">\(_3\)</span><code> SHPAR</code><span
class="math inline">\(_4\)</span><code> SHPAR</code><span
class="math inline">\(_5\)</span><code> SHPAR</code><span
class="math inline">\(_6\)</span><code> SHPAR</code><span
class="math inline">\(_7\)</span><code> SHPAR</code><span
class="math inline">\(_8\)</span><code> SHPAR</code><span
class="math inline">\(_9\)</span></span><br />
 <br />
where<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
<span class="math inline">\(L_x/d\)</span> = (brick thickness in <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> direction)<span
class="math inline">\(/d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span> =
<span class="math inline">\(L_y/d\)</span> = (brick extent in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction)/<span
class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
<span class="math inline">\(L_z/d\)</span> = (brick extent in <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction)/<span
class="math inline">\(d\)</span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
fraction of the slab with composition 1<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
fraction of the slab with composition 2<br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
fraction of the slab with composition 3<br />
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span> =
fraction of the slab with composition 4<br />
<span><code>SHPAR</code></span><span class="math inline">\(_8\)</span> =
<span class="math inline">\(P_y/d\)</span> = (periodicity in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction)/<span
class="math inline">\(d\)</span> (0 to suppress repetition in <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction)<br />
<span><code>SHPAR</code></span><span class="math inline">\(_9\)</span> =
<span class="math inline">\(P_z/d\)</span> = (periodicity in <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction)/<span
class="math inline">\(d\)</span> (0 to suppress repetition in <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction)<br />
 <br />
For a slab with only one layer, set <span><code>SHPAR</code></span><span
class="math inline">\(_5=0\)</span>,
<span><code>SHPAR</code></span><span
class="math inline">\(_6=0\)</span>,
<span><code>SHPAR</code></span><span
class="math inline">\(_7=0\)</span>.<br />
For a slab with only two layers, set
<span><code>SHPAR</code></span><span class="math inline">\(_6=0\)</span>
and <span><code>SHPAR</code></span><span
class="math inline">\(_7=0\)</span>.<br />
For a slab with only three layers, set
<span><code>SHPAR</code></span><span
class="math inline">\(_7=0\)</span>.<br />
The user must set <span><code>NCOMP</code></span> equal to the number of
nonzero thickness layers.<br />
The number <span class="math inline">\(N\)</span> of dipoles in one TUC
is <span class="math inline">\(N={\rm nint}({\tt SHPAR}_1)\times{\rm
nint}({\tt SHPAR}_2)\times
    {\rm nint}({\tt SHPAR}_3)\)</span>.</p>
<p>The fractions <span><code>SHPAR</code><span
class="math inline">\(_4\)</span></span>,
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>,
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span>,
and <span><code>SHPAR</code></span><span
class="math inline">\(_7\)</span> <span><em>must</em></span> sum to 1.
The number of dipoles in each of the layers will be integers that are
close to <span class="math inline">\({\rm  nint}({\tt SHPAR}_1*{\tt
SHPAR}_4)\)</span>, <span class="math inline">\({\rm  nint}({\tt
SHPAR}_1*{\tt SHPAR}_5)\)</span>, <span
class="math inline">\({\rm  nint}({\tt SHPAR}_1*{\tt SHPAR}_6)\)</span>,
<span class="math inline">\({\rm  nint}({\tt SHPAR}_1*{\tt
SHPAR}_7)\)</span>,</p>
<p>The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>. Because
of the way <span class="math inline">\({a}_{\rm eff}\)</span> is defined
(<span class="math inline">\(4\pi {a}_{\rm eff}^3/3 \equiv
Nd^3\)</span>), it should be set to <span
class="math display">\[{a}_{\rm eff}= (3/4\pi)^{1/3} N^{1/3} d =
(3/4\pi)^{1/3}
    (L_x L_y L_z)^{1/3}\]</span>.</p>
<p>With target option <span><code>LYRSLBPBC</code></span>, the target
becomes a periodic structure, of infinite extent in the target y- and z-
directions. The target axes (in the TF) are set to <span
class="math inline">\({\hat{\bf a}}_1 = (1,0,0)_{\rm TF}\)</span> –
i.e., normal to the “slab” – and <span class="math inline">\({\hat{\bf
a}}_2 = (0,1,0)_{\rm TF}\)</span>. The orientation of the incident
radiation relative to the target is, as for all other targets, set by
the usual orientation angles <span class="math inline">\(\beta\)</span>,
<span class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the slab.</p>
<p>For this option, there are only two allowed scattering directions,
corresponding to transmission and specular reflection.
<span><strong>DDSCAT</strong></span> will calculate both the
transmission and reflection coefficients.<br />
The last two lines in <span><code>ddscat.par</code></span> should appear
as in the following example <span><code>ddscat.par</code></span> file.
This example is for a slab with two layers: the slab is 26 dipole layers
thick; the first layer comprises 76.92% of the thickness, the second
layer 23.08% of the thickness. The wavelength is <span
class="math inline">\(0.532\mu\)</span>m, the thickness is <span
class="math inline">\(L_x=(4\pi/3)^{1/3}N_x^{2/3}{a}_{\rm
eff}=(4\pi/3)^{1/3}(26)^{2/3}0.009189=
    0.1300{\mu{\rm m}}\)</span>.<br />
The upper layer thickness is <span
class="math inline">\(0.2308L_x=0.0300{\mu{\rm m}}\)</span><br />
<span><code>ddscat.par</code></span> below is set up to calculate a
single orientation: in the Lab Frame, the target is rotated through an
angle <span class="math inline">\(\Theta=120^\circ\)</span>, with <span
class="math inline">\(\Phi=0\)</span>. In this orientation, the incident
radiation is propagating in the <span
class="math inline">\((-0.5,0.866,0)\)</span> direction in the Target
Frame, so that it is impinging on target layer 2 (Au).<br />
</p>
<pre><code>&#39; =========== Parameter file for v7.3 ===================&#39; 
&#39;**** PRELIMINARIES ****&#39;
&#39;NOTORQ&#39; = CMTORQ*6 (DOTORQ, NOTORQ) -- either do or skip torque calculations
&#39;PBCGS2&#39; = CMDSOL*6 (PBCGS2, PBCGST, PETRKP) -- CCG method
&#39;GPFAFT&#39; = CMETHD*6 (GPFAFT, FFTMKL) -- FFT method
&#39;GKDLDR&#39; = CALPHA*6 (GKDLDR, LATTDR, FLTRCD) -- DDA method
&#39;NOTBIN&#39; = CBINFLAG (ALLBIN, ORIBIN, NOTBIN)
&#39;**** Initial Memory Allocation ****&#39;
26  1  1  = upper bounds on size of TUC 
&#39;**** Target Geometry and Composition ****&#39;
&#39;LYRSLBPBC&#39; = CSHAPE*9 shape directive
26 1 1 0.7692 0.2308 0 0 1 1 = shape parameters SHPAR1 - SHPAR9
2         = NCOMP = number of dielectric materials
&#39;/u/draine/work/DDA/diel/Eagle_2000&#39; = refractive index 1
&#39;/u/draine/work/DDA/diel/Au_evap&#39;    = refractive index 2
&#39;**** Additional Nearfield calculation? ****&#39;
0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
0 0 0 0 0 0 (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)
&#39;**** Error Tolerance ****&#39;
1.00e-5 = TOL = MAX ALLOWED (NORM OF |G&gt;=AC|E&gt;-ACA|X&gt;)/(NORM OF AC|E&gt;)
&#39;**** Maximum number of iterations ****&#39;
100     = MXITER
&#39;**** Interaction cutoff parameter for PBC calculations ****&#39;
5.00e-3 = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)
&#39;**** Angular resolution for calculation of &lt;cos&gt;, etc. ****&#39;
0.5 = ETASCA (number of angles is proportional to [(3+x)/ETASCA]^2 )
&#39;**** Wavelengths (micron) ****&#39;
0.5320 0.5320 1 &#39;INV&#39; = wavelengths (first,last,how many,how=LIN,INV,LOG)
&#39;**** Effective Radii (micron) **** &#39;
0.009189 0.009189 1 &#39;LIN&#39; = eff. radii (first,last,how many,how=LIN,INV,LOG)
&#39;**** Define Incident Polarizations ****&#39;
(0,0) (1.,0.) (0.,0.) = Polarization state e01 (k along x axis)
2 = IORTH  (=1 to do only pol. state e01; =2 to also do orth. pol. state)
&#39;**** Specify which output files to write ****&#39;
1 = IWRKSC (=0 to suppress, =1 to write &quot;.sca&quot; file for each target orient.
&#39;**** Prescribe Target Rotations ****&#39;
0.   0.   1  = BETAMI, BETAMX, NBETA (beta=rotation around a1)
120. 120. 1  = THETMI, THETMX, NTHETA (theta=angle between a1 and k)
0.   0.   1  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
&#39;**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****&#39;
0   0   0    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
&#39;**** Select Elements of S_ij Matrix to Print ****&#39;
6   = NSMELTS = number of elements of S_ij to print (not more than 9)
11 12 21 22 31 41   = indices ij of elements to print
&#39;**** Specify Scattered Directions ****&#39;
&#39;TFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
1 = number of scattering orders
0.  0. = (M,N) for scattering</code></pre>
<h2 id="sec:RCTGL_PBC"> RCTGL_PBC = Target consisting of homogeneous
rectangular brick, extended in target y and z directions using periodic
boundary conditions</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of a biperiodic array of rectangular bricks. The
bricks are assumed to be homogeneous and isotropic, just as for option
RCTNGL (see §<a href="#sec:RCTGLPRSM" data-reference-type="ref"
data-reference="sec:RCTGLPRSM">[sec:RCTGLPRSM]</a>).  <br />
Let us refer to a single rectangular brick as the Target Unit Cell
(TUC). The TUC is then repeated in the <span
class="math inline">\(y_{\rm TF}\)</span>- and <span
class="math inline">\(z_{\rm TF}\)</span>-directions, with periodicities
<span><code>PYAEFF</code></span><span class="math inline">\(\times
{a}_{\rm eff}\)</span> and <span><code>PZAEFF</code></span><span
class="math inline">\(\times {a}_{\rm eff}\)</span>, where <span
class="math inline">\({a}_{\rm eff}\equiv(3V_{\rm
TUC}/4\pi)^{1/3}\)</span>, where <span class="math inline">\(V_{\rm
TUC}\)</span> is the total volume of solid material in one TUC. This
option requires 5 shape parameters: The pertinent line in
<span><code>ddscat.par</code></span> should read<br />
 <br />
<span class="math inline">\({\tt SHPAR}_1~~{\tt SHPAR}_2~~{\tt
SHPAR}_3~~{\tt SHPAR}_4~~{\tt SHPAR}_5\)</span><br />
 <br />
where<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
(brick thickness)/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(x_{\rm TF}\)</span> direction<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
(brick thickness)/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(y_{\rm TF}\)</span> direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
(brick thickness)/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(z_{\rm TF}\)</span> direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
periodicity/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(y_{\rm TF}\)</span> direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
periodicity/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(z_{\rm TF}\)</span> direction<br />
 <br />
The overall size of the TUC (in terms of numbers of dipoles) is
determined by parameters <span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code>, SHPAR</code><span
class="math inline">\(_2\)</span></span>, and
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>.
The periodicity in the <span class="math inline">\(y_{\rm TF}\)</span>
and <span class="math inline">\(z_{\rm TF}\)</span> directions is
determined by parameters <span><code>SHPAR</code></span><span
class="math inline">\(_4\)</span> and
<span><code>SHPAR</code></span><span
class="math inline">\(_5\)</span>.<br />
The physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>.</p>
<p>With target option <span><code>RCTGL_PBC</code></span>, the target
becomes a periodic structure, of infinite extent in the target y- and z-
directions. The target axes (in the TF) are set to <span
class="math inline">\({\hat{\bf a}}_1 = (1,0,0)_{\rm TF}\)</span> –
i.e., normal to the “slab” – and <span class="math inline">\({\hat{\bf
a}}_2 = (0,1,0)_{\rm TF}\)</span>. The orientation of the incident
radiation relative to the target is, as for all other targets, set by
the usual orientation angles <span class="math inline">\(\beta\)</span>,
<span class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above); for example, <span class="math inline">\(\Theta=0\)</span> would
be for radiation incident normal to the slab.</p>
<h3
id="sample-calculation-in-directory-examples_exprctgl_pbc"><strong>Sample
calculation in directory examples_exp/RCTGL_PBC</strong></h3>
<p>Subdirectory <span><code>examples_exp/RCTGL_PBC</code></span>
contains <span><code>ddscat.par</code></span> for scattering by an
infinite slab, constituted from <span
class="math inline">\(20\times1\times1\)</span> dipole TUCs. The
wavelength <span class="math inline">\(\lambda=0.5{\mu{\rm m}}\)</span>,
and the slab thickness is <span class="math inline">\(h=0.10{\mu{\rm
m}}\)</span>. The slab has refractive index <span
class="math inline">\(m=1.50+0.02i\)</span>. The interdipole spacing
<span class="math inline">\(d=0.32{\mu{\rm m}}/20=0.005{\mu{\rm
m}}\)</span>. The TUC has dimension <span
class="math inline">\(V=0.10{\mu{\rm m}}\times0.005{\mu{\rm
m}}\times0.005{\mu{\rm m}}\)</span>, and hence <span
class="math inline">\({a}_{\rm
eff}=(3V/4\pi)^{1/3}=(3\times0.10\times0.005\times0.005/4\pi)^{1/3}{\mu{\rm
m}}=
0.0084195{\mu{\rm m}}\)</span>. The incident radiation is at an angle
<span class="math inline">\(\theta_i=40^\circ\)</span> relative to the
surface normal.</p>
<h3
id="sample-calculation-in-directory-examples_exprctgl_pbc_nearfield"><strong>Sample
calculation in directory examples_exp/RCTGL_PBC_NEARFIELD</strong></h3>
<p>The directory
<span><code>examples_exp/RCTGL_PBC_NEARFIELD</code></span> contains
<span><code>ddscat.par</code></span> for calculation of scattering and
absorption by an infinite slab of material with refractive index <span
class="math inline">\(m=1.50+0.02i\)</span> and thickness <span
class="math inline">\(h=0.10{\mu{\rm m}}\)</span> in vacuo. The incident
radiation has wavelength <span class="math inline">\(\lambda_{\rm
vac}=0.5{\mu{\rm m}}\)</span> and incidence angle <span
class="math inline">\(\theta_i=40^\circ\)</span>. The interdipole
spacing is set to <span class="math inline">\(d=h/20 = 0.005{\mu{\rm
m}}\)</span>. This is the example problem shown in Fig. 7b of <span
class="citation" data-cites="Draine+Flatau_2008a"></span>.</p>
<p>The slab is treated as a periodic array of <span
class="math inline">\(1d\times1d\times20d\)</span> structures with
periodicity <span class="math inline">\(P_y=1d\)</span> and <span
class="math inline">\(P_z=1d\)</span>. The volume of the TUC is <span
class="math inline">\(V_{\rm TUC}=20d^3=2.50\times10^{-6}{\mu{\rm
m}}^3\)</span>, and the effective radius is <span
class="math inline">\({a}_{\rm eff}=(3V_{\rm
TUC}/4\pi)^{1/3}=0.0084195{\mu{\rm m}}\)</span>.</p>
<div class="center">
<figure>
<img src="f_rctgl_pbc_nf.png"
alt=" Normalized macroscopic electric field intensity |{\bf E}|^2/|{\bf E}_0|^2 along a line normal to a slab of thickness h, refractive index m=1.5+0.02i. Radiation with \lambda/h=5 is incident with incidence angle \theta_i=40^\circ. The interdipole spacing is set to d=h/20=0.01\lambda. This is the same problem reported in Fig. 7b of . Eq. ([eq:macro_vs_micro]) gives the relation between microscopic and macroscopic {\bf E} fields. " />
<figcaption aria-hidden="true"> Normalized macroscopic electric field
intensity <span class="math inline">\(|{\bf E}|^2/|{\bf E}_0|^2\)</span>
along a line normal to a slab of thickness <span
class="math inline">\(h\)</span>, refractive index <span
class="math inline">\(m=1.5+0.02i\)</span>. Radiation with <span
class="math inline">\(\lambda/h=5\)</span> is incident with incidence
angle <span class="math inline">\(\theta_i=40^\circ\)</span>. The
interdipole spacing is set to <span
class="math inline">\(d=h/20=0.01\lambda\)</span>. This is the same
problem reported in Fig. 7b of <span class="citation"
data-cites="Draine+Flatau_2008a"></span>. Eq. (<a
href="#eq:macro_vs_micro" data-reference-type="ref"
data-reference="eq:macro_vs_micro">[eq:macro_vs_micro]</a>) gives the
relation between microscopic and macroscopic <span
class="math inline">\({\bf E}\)</span> fields. </figcaption>
</figure>
</div>
<h3
id="sample-calculation-in-directory-examples_exprctgl_pbc_nearfld_b"><strong>Sample
calculation in directory examples_exp/RCTGL_PBC_NEARFLD_B</strong></h3>
<p>The directory
<span><code>examples_exp/RCTGL_PBC_NEARFLD_B</code></span> contains
<span><code>ddscat.par</code></span> for calculation of scattering and
absorption by an infinite slab of material with refractive index <span
class="math inline">\(m=1.50+0.02i\)</span> and thickness <span
class="math inline">\(h=0.1{\mu{\rm m}}\)</span> in vacuo. The incident
radiation has wavelength <span class="math inline">\(\lambda_{\rm
vac}=0.5{\mu{\rm m}}\)</span> and incidence angle <span
class="math inline">\(\theta_i=40^\circ\)</span>. The interdipole
spacing is set to <span class="math inline">\(d=h/20 = 0.005{\mu{\rm
m}}\)</span>. This is the example problem shown in Fig. 7b of <span
class="citation" data-cites="Draine+Flatau_2008a"></span>, and is the
same problem as in directory examples_exp/RCTGL_PBC_NEARFIELD.</p>
<p>The slab is treated as a periodic array of <span
class="math inline">\(1d\times1d\times20d\)</span> structures with
periodicity <span class="math inline">\(P_y=1d\)</span> and <span
class="math inline">\(P_z=1d\)</span>. The volume of the TUC is <span
class="math inline">\(V_{\rm TUC}=20d^3=2.5\times10^{-6}{\mu{\rm
m}}^3\)</span>, and the effective radius is <span
class="math inline">\({a}_{\rm eff}=(3V_{\rm
TUC}/4\pi)^{1/3}=0.0084195{\mu{\rm m}}\)</span>.</p>
<p>In this example, we set <span><code>NRFLD</code></span>=2 so that, in
addition to calculating <span class="math inline">\({\bf E}\)</span> in
the nearfield volume, <span><strong>DDSCAT 7.3</strong></span> will
calculate <span class="math inline">\({\bf B}\)</span> throughout the
nearfield volume. With both <span class="math inline">\({\bf E}\)</span>
and <span class="math inline">\({\bf B}\)</span> available, we can also
compute the Poynting vector <span class="math inline">\((c/4\pi){\bf
E}\times{\bf B}\)</span>.</p>
<div class="center">
<p><img src="f_rctgl_pbc_nf_b.png" style="width:8cm" alt="image" /> <img
src="f_rctgl_pbc_nf_b_fcd.png" style="width:8cm" alt="image" /></p>
</div>
<p>In Figure <a href="#fig:example_RCTGL_PBC_NEARFLD_B"
data-reference-type="ref"
data-reference="fig:example_RCTGL_PBC_NEARFLD_B">[fig:example_RCTGL_PBC_NEARFLD_B]</a>
we show the component of the time-averaged Poynting flux normal to the
slab, <span class="math inline">\((c/4\pi)\langle({\bf E}\times{\bf
B})\rangle\cdot \hat{\bf x}_{\rm TF}\)</span>, divided by the
time-averaged value of the incident Poynting flux, <span
class="math inline">\((c/8\pi)E_0^2\cos\theta_i\)</span>. Figure <a
href="#fig:example_RCTGL_PBC_NEARFLD_B" data-reference-type="ref"
data-reference="fig:example_RCTGL_PBC_NEARFLD_B">[fig:example_RCTGL_PBC_NEARFLD_B]</a>a
shows results computed using the standard DDA (method option
<span><code>GKDLDR</code></span>) and Figure <a
href="#fig:example_RCTGL_PBC_NEARFLD_B" data-reference-type="ref"
data-reference="fig:example_RCTGL_PBC_NEARFLD_B">[fig:example_RCTGL_PBC_NEARFLD_B]</a>b
shows results computed using the filtered couple dipole method (option
<span><code>FLTRCD</code></span>). Both methods give accurate results.
The main difference is in the computed <span class="math inline">\({\bf
E}\)</span> field near the surface of the slab: the standard "point
dipole" calculation (GKDLDR) has small-scale structure in the computed
<span class="math inline">\({\bf E}\)</span> near the surface, resulting
in errors of a few % in the computed Poynting vector near the surface
(see Figure <a href="#fig:example_RCTGL_PBC_NEARFLD_B"
data-reference-type="ref"
data-reference="fig:example_RCTGL_PBC_NEARFLD_B">[fig:example_RCTGL_PBC_NEARFLD_B]</a>a).
The filtered coupled dipole method, on the other hand, explicitly
filters out the small-scale structure in the <span
class="math inline">\({\bf E}\)</span> field, thereby suppressing the
"blips" in the Poynting flux near the two surfaces of the slab (see
Figure <a href="#fig:example_RCTGL_PBC_NEARFLD_B"
data-reference-type="ref"
data-reference="fig:example_RCTGL_PBC_NEARFLD_B">[fig:example_RCTGL_PBC_NEARFLD_B]</a>b).
Otherwise the two solutions are nearly identical, and both are smooth
near the middle of the slab.</p>
<p>The numerical accuracy can be assessed from Table <a
href="#tab:GKDLDR_vs_FLTRCD" data-reference-type="ref"
data-reference="tab:GKDLDR_vs_FLTRCD">2</a>. For this problem, with
<span class="math inline">\(N=20\)</span>, both GKDLDR and FLTRCD give
reflection and transmission coefficients accurate to better than 0.5%.
The absorption coefficients are somewhat less accurate, but the
fractional errors do not exceed 4.2%. Note that the filtered coupled
dipole method (FLTRCD) does not give greater accuracy than GKDLDR, at
least for this problem. If desired, the accuracy could be further
improved by increasing <span class="math inline">\(N\)</span>.</p>
<p>The CPU time required for the filtered coupled dipole calculations is
about twice that required for the GKDLDR method, because for this
calculation the dominant calculational task is calculation of the
elements of the dipole-dipole interaction matrix (or Green
function).</p>
<div class="center">
<div id="tab:GKDLDR_vs_FLTRCD">
<table>
<caption>Results for <span class="math inline">\(m=1.5+0.02i\)</span>,
<span class="math inline">\(h/\lambda=0.2\)</span>, <span
class="math inline">\(\theta_i=40^\circ\)</span></caption>
<thead>
<tr class="header">
<th style="text-align: center;">quantity</th>
<th style="text-align: center;">exact</th>
<th style="text-align: center;">GKDLDR</th>
<th style="text-align: center;">FLTRCD</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(R_\parallel\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.051875\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.05179\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.051740\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(R_\perp\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.25046\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.25047\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.25042\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(T_\parallel\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.89545\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.89534\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.89592\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(T_\perp\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.70280\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.70524\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.70478\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(A_\parallel\)</span></td>
<td style="text-align: center;">0.052675</td>
<td style="text-align: center;"><span
class="math inline">\(0.052482\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.052259\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(A_\perp\)</span></td>
<td style="text-align: center;">0.046748</td>
<td style="text-align: center;"><span
class="math inline">\(0.044970\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.044801\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(R_\parallel+T_\parallel+A_\parallel\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span
class="math inline">\(0.99961\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.99992\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(R_\perp+T_\perp+A_\perp\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span
class="math inline">\(1.00068\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1.00000\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(R_\parallel/{\rm exact}-1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span
class="math inline">\(-0.0017\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-0.0026\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(R_\perp/{\rm
exact}-1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span
class="math inline">\(+0.0001\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-0.0002\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(T_\parallel/{\rm exact}-1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span
class="math inline">\(-0.0001\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(+0.0005\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(T_\perp/{\rm
exact}-1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span
class="math inline">\(+0.0035\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(+0.0042\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(A_\parallel/{\rm exact}-1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span
class="math inline">\(-0.0037\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-0.0079\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(A_\perp/{\rm
exact}-1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span
class="math inline">\(-0.0380\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-0.0416\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">CPU time (s) (2.53GHz Intel, 1
core)</td>
<td style="text-align: center;">–</td>
<td style="text-align: center;">1298.</td>
<td style="text-align: center;">2770.</td>
</tr>
</tbody>
</table>
</div>
</div>
<h2 id="sec:RECRECPBC"> RECRECPBC = Rectangular solid resting on top of
another rectangular solid, repeated periodically in target y and z
directions using periodic boundary conditions</h2>
<p>The TUC consists of a single rectangular “brick”, of material 1,
resting on top of a second rectangular brick, of material 2. The
centroids of the two bricks along a line in the <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span> direction. The
bricks are assumed to be homogeneous, and materials 1 and 2 are assumed
to be isotropic. The TUC is then repeated in the <span
class="math inline">\(y_{\rm TF}\)</span>- and <span
class="math inline">\(z_{\rm TF}\)</span>-directions, with periodicities
<span><code>SHPAR</code></span><span class="math inline">\(_4\times
d\)</span> and <span><code>SHPAR</code></span><span
class="math inline">\(_5\times d\)</span>. is the total volume of solid
material in one TUC. This option requires 8 shape parameters: The
pertinent line in <span><code>ddscat.par</code></span> should read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code><span
class="math inline">\(_3\)</span><code> SHPAR</code><span
class="math inline">\(_4\)</span><code> SHPAR</code><span
class="math inline">\(_5\)</span><code> SHPAR</code><span
class="math inline">\(_6\)</span><code> SHPAR</code><span
class="math inline">\(_7\)</span><code> SHPAR</code><span
class="math inline">\(_8\)</span></span><br />
 <br />
where<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span> =
(upper brick thickness)/<span class="math inline">\(d\)</span> in the
<span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>
direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span> =
(upper brick thickness)/<span class="math inline">\(d\)</span> in the
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>
direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
(upper brick thickness)/<span class="math inline">\(d\)</span> in the
<span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>
direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
(lower brick thickness)/<span class="math inline">\(d\)</span> in the
<span class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>
direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
(lower brick thickness)/<span class="math inline">\(d\)</span> in the
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>
direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
(lower brick thickness)/<span class="math inline">\(d\)</span> in the
<span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>
direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span> =
periodicity/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction<br />
<span><code>SHPAR</code></span><span class="math inline">\(_8\)</span> =
periodicity/<span class="math inline">\(d\)</span> in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction<br />
 <br />
The actual numbers of dipoles <span
class="math inline">\(N_{1x}\)</span>, <span
class="math inline">\(N_{1y}\)</span>, <span
class="math inline">\(N_{1z}\)</span>, along each dimension of the upper
brick, and <span class="math inline">\(N_{2x}\)</span>, <span
class="math inline">\(N_{2y}\)</span>, <span
class="math inline">\(N_{2z}\)</span> along each dimension of the lower
brick, must be integers. Usually, <span
class="math inline">\(N_{1x}={\rm nint}({\tt SHPAR}_1)\)</span>, <span
class="math inline">\(N_{1y}={\rm nint}({\tt SHPAR}_2)\)</span>, <span
class="math inline">\(N_{1z}={\rm nint}({\tt SHPAR}_3)\)</span>, <span
class="math inline">\(N_{2x}={\rm nint}({\tt SHPAR}_4)\)</span>, <span
class="math inline">\(N_{2y}={\rm nint}({\tt SHPAR}_5)\)</span>, <span
class="math inline">\(N_{2z}={\rm nint}({\tt SHPAR}_6)\)</span>, where
<span class="math inline">\({\rm nint}(x)\)</span> is the integer
nearest to <span class="math inline">\(x\)</span>, but under some
circumstances <span class="math inline">\(N_{1x}\)</span>, <span
class="math inline">\(N_{1y}\)</span>, <span
class="math inline">\(N_{1z}\)</span>, <span
class="math inline">\(N_{2x}\)</span>, <span
class="math inline">\(N_{2y}\)</span>, <span
class="math inline">\(N_{2z}\)</span> might be larger or smaller by 1
unit.</p>
<p>The overall size of the TUC (in terms of numbers of dipoles) is
determined by parameters <span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span> – <span><code>SHPAR</code></span><span
class="math inline">\(_6\)</span>: <span class="math display">\[N =
\left(N_{1x}\times N_{1y}\times N_{1z}\right)
    + \left(N_{2x}\times N_{2y}\times N_{2z}\right)\]</span> The
physical size of the TUC is specified by the value of <span
class="math inline">\({a}_{\rm eff}\)</span> (in physical units, e.g.
cm), specified in the file <span><code>ddscat.par</code></span>: <span
class="math display">\[d = (4\pi/3N)^{1/3}{a}_{\rm eff}\]</span></p>
<p>The periodicity in the <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> and <span class="math inline">\(\hat{\bf z}_{\rm
TF}\)</span> directions is determined by parameters
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span>
and <span><code>SHPAR</code></span><span
class="math inline">\(_8\)</span>.<br />
The periodicity should not be smaller than the extent of the target, so
that one should have<br />
 <br />
<span class="math inline">\({\tt SHPAR}_7 \geq {\rm max}({\tt
SHPAR}_2,{\tt SHPAR}_5)\)</span><br />
<span class="math inline">\({\tt SHPAR}_8 \geq {\rm max}({\tt
SHPAR}_3,{\tt SHPAR}_6)\)</span><br />
The target is a periodic structure, of infinite extent in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> and <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> directions. The
target axes are set to <span class="math inline">\({\hat{\bf a}}_1 =
\hat{\bf x}_{\rm TF}\)</span> – i.e., normal to the “slab” – and <span
class="math inline">\({\hat{\bf a}}_2 = \hat{\bf y}_{\rm TF}\)</span>.
The orientation of the incident radiation relative to the target is, as
for all other targets, set by the usual orientation angles <span
class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above) specifying the orientation of the target axes <span
class="math inline">\({\hat{\bf a}}_1\)</span> and <span
class="math inline">\({\hat{\bf a}}_2\)</span> relative to the direction
of incidence; for example, <span class="math inline">\(\Theta=0\)</span>
would be for radiation incident normal to the slab.</p>
<p>The scattering directions are specified by specifying the diffraction
order <span class="math inline">\((M,N)\)</span>; for each diffraction
order one transmitted wave direction and one reflected wave direction
will be calculated, with the dimensionless <span
class="math inline">\(4\times4\)</span> scattering matrix <span
class="math inline">\(S^{(2d)}\)</span> calculated for each scattering
direction. At large distances from the infinite slab, the scattered
Stokes vector in the (M,N) diffraction order is <span
class="math display">\[I_{sca,i}(M,N) = \sum_{j=1}^{4} S_{ij}^{(2d)}
I_{in,j}\]</span> where <span class="math inline">\(I_{in,j}\)</span> is
the incident Stokes vector. See <span class="citation"
data-cites="Draine+Flatau_2008a"></span> for interpretation of the <span
class="math inline">\(S_{ij}\)</span> as transmission and reflection
efficiencies.</p>
<h2 id="sec:SLBHOLPBC"> SLBHOLPBC = Target consisting of a periodic
array of rectangular blocks, each containing a cylindrical hole <span
id="sec:SLBHOLPBC" label="sec:SLBHOLPBC"></span></h2>
<p>Individual blocks have extent <span
class="math inline">\((a,b,c)\)</span> in the <span
class="math inline">\((\hat{\bf x}_{\rm TF},\hat{\bf y}_{\rm
TF},\hat{\bf z}_{\rm TF})\)</span> directions, and the cylindrical hole
has radius <span class="math inline">\(r\)</span>. The period in the
<span class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>-direction is
<span class="math inline">\(P_y\)</span>, and the period in the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>-direction is <span
class="math inline">\(P_z\)</span>.<br />
The pertinent line in <span><code>ddscat.par</code></span> should
consist of<br />
<span><code>SHPAR</code></span><span class="math inline">\(_1\)</span>
<span><code>SHPAR</code></span><span class="math inline">\(_2\)</span>
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span>
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span>
<span><code>SHPAR</code></span><span
class="math inline">\(_6\)</span><br />
where <span><code>SHPAR</code></span><span class="math inline">\(_1 =
a/d\)</span> (<span class="math inline">\(d\)</span> is the interdipole
spacing)<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
<span class="math inline">\(b/a\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_3\)</span></span> =
<span class="math inline">\(c/a\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_4\)</span></span> =
<span class="math inline">\(r/a\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_5\)</span></span> =
<span class="math inline">\(P_y/d\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_6\)</span></span> =
<span class="math inline">\(P_z/d\)</span>.<br />
Ideally, <span
class="math inline">\(a/d=\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span>, <span
class="math inline">\(b/d=\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_2\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span>, and <span
class="math inline">\(c/d=\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_3\times\)</span><span><code>SHPAR</code></span><span
class="math inline">\(_1\)</span> will be integers (so that the cubic
lattice can accurately approximate the desired target). If <span
class="math inline">\(P_y=0\)</span> and <span
class="math inline">\(P_z&gt;0\)</span> the target is periodic in the
<span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>-direction
only.<br />
If <span class="math inline">\(P_y&gt;0\)</span> and <span
class="math inline">\(P_z=0\)</span> the target is periodic in the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>-direction
only.<br />
If <span class="math inline">\(P_y&gt;0\)</span> it is required that
<span class="math inline">\(P_y\geq b\)</span>, and if <span
class="math inline">\(P_z&gt;0\)</span> it is required that <span
class="math inline">\(P_z\geq c\)</span>, so that the blocks do not
overlap.<br />
With <span class="math inline">\(P_y=b\)</span> and <span
class="math inline">\(P_z=c\)</span>, the blocks are juxtaposed to form
a periodic array of cylindrical holes in a solid slab.<br />
Example: <span><code>ddscat_SLBHOLPBC.par</code></span> is a sample
<span><code>ddscat.par</code></span> for a periodic array of cylindrical
holes in a slab of thickness <span class="math inline">\(a\)</span>,
with holes of radius <span class="math inline">\(r\)</span>, and period
<span class="math inline">\(P_y\)</span> and <span
class="math inline">\(P_d\)</span></p>
<h2 id="sec:SPHRN_PBC"> SPHRN_PBC = Target consisting of group of N
spheres, extended in target y and z directions using periodic boundary
conditions</h2>
<p>This option causes <span><strong>DDSCAT</strong></span> to create a
target consisting of a periodic array of <span
class="math inline">\(N-\)</span>sphere structures, where one <span
class="math inline">\(N-\)</span>sphere structure consists of <span
class="math inline">\(N\)</span> spheres, just as for target option
<span><code>NANSPH</code></span> (see §<a href="#sec:SPH_ANI_N"
data-reference-type="ref"
data-reference="sec:SPH_ANI_N">[sec:SPH_ANI_N]</a>). Each sphere can be
of arbitrary composition, and can be anisotropic if desired. Information
for the description of one <span class="math inline">\(N\)</span>-sphere
structure is supplied via an external file, just as for target option
<span><code>NANSPH</code></span> – see §<a href="#sec:SPH_ANI_N"
data-reference-type="ref"
data-reference="sec:SPH_ANI_N">[sec:SPH_ANI_N]</a>).<br />
 <br />
Let us refer to a single <span class="math inline">\(N\)</span>-sphere
structure as the Target Unit Cell (TUC). The TUC is then repeated in the
<span class="math inline">\(y_{\rm TF}\)</span>- and <span
class="math inline">\(z_{\rm TF}\)</span>-directions, with periodicities
<span><code>PYAEFF</code></span><span class="math inline">\(\times
{a}_{\rm eff}\)</span> and <span><code>PZAEFF</code></span><span
class="math inline">\(\times {a}_{\rm eff}\)</span>, where <span
class="math inline">\({a}_{\rm eff}\equiv(3V_{\rm
TUC}/4\pi)^{1/3}\)</span>, where <span class="math inline">\(V_{\rm
TUC}\)</span> is the total volume of solid material in one TUC. This
option requires 3 shape parameters: <span><code>DIAMX</code></span> =
maximum extent of target in the target frame x direction/<span
class="math inline">\(d\)</span> <span><code>PYAEFF</code></span> =
periodicity in target y direction/<span class="math inline">\({a}_{\rm
eff}\)</span> <span><code>PZAEFF</code></span> = periodicity in target z
direction/<span class="math inline">\({a}_{\rm eff}\)</span>.</p>
<p>The pertinent line in <span><code>ddscat.par</code></span> should
read<br />
 <br />
<span><code>SHPAR</code><span
class="math inline">\(_1\)</span><code> SHPAR</code><span
class="math inline">\(_2\)</span><code> SHPAR</code></span><span
class="math inline">\(_3\)</span> <span><em>‘filename’</em></span>
(quotes must be used)<br />
 <br />
where<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
target diameter in <span class="math inline">\(x\)</span> direction (in
Target Frame) in units of <span class="math inline">\(d\)</span><br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span>=
<span><code>PYAEFF</code></span><br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span>=
<span><code>PZAEFF</code></span>.<br />
<span><em>filename</em></span> is the name of the file specifying the
locations and relative sizes of the spheres.<br />
 <br />
The overall size of the TUC (in terms of numbers of dipoles) is
determined by parameter <span><code>SHPAR</code><span
class="math inline">\(_1\)</span></span>, which is the extent of the
multisphere target in the <span
class="math inline">\(x\)</span>-direction, in units of the lattice
spacing <span class="math inline">\(d\)</span>. The physical size of the
TUC is specified by the value of <span class="math inline">\({a}_{\rm
eff}\)</span> (in physical units, e.g. cm), specified in the file
<span><code>ddscat.par</code></span>.</p>
<p>The location of the spheres in the TUC, and their composition, is
specified in file <span><em>‘filename’</em></span>. <span> Please
consult §<a href="#sec:SPH_ANI_N" data-reference-type="ref"
data-reference="sec:SPH_ANI_N">[sec:SPH_ANI_N]</a> above for detailed
information concerning the information in this file, and its
arrangement.</span></p>
<p>Note that while the spheres can be anisotropic and of differing
composition, they can of course also be isotropic and of a single
composition, in which case the relevant lines in the file
<span><em>’filename’</em></span> should read<br />
<span class="math inline">\(x_1\)</span> <span
class="math inline">\(y_1\)</span> <span
class="math inline">\(z_1\)</span> <span
class="math inline">\(r_1\)</span> 1 1 1 0 0 0<br />
<span class="math inline">\(x_2\)</span> <span
class="math inline">\(y_2\)</span> <span
class="math inline">\(z_2\)</span> <span
class="math inline">\(r_2\)</span> 1 1 1 0 0 0<br />
<span class="math inline">\(x_3\)</span> <span
class="math inline">\(y_3\)</span> <span
class="math inline">\(z_3\)</span> <span
class="math inline">\(r_3\)</span> 1 1 1 0 0 0<br />
...<br />
i.e., every sphere has isotropic composition
<span><code>ICOMP=1</code></span> and the three dielectric function
orientation angles are set to zero.</p>
<p>When the user uses target option <span><code>SPHRN_PBC</code></span>,
the target now becomes a periodic structure, of infinite extent in the
target y- and z- directions. The target axis <span
class="math inline">\({\hat{\bf a}}_1 = \hat{\bf x}_{\rm LF}=
(1,0,0)_{\rm TF}\)</span> – i.e., normal to the “slab” – and target axis
<span class="math inline">\({\hat{\bf a}}_2 = \hat{\bf y}_{\rm LF}=
(0,1,0)_{\rm TF}\)</span>. The orientation of the incident radiation
relative to the target is, as for all other targets, set by the usual
orientation angles <span class="math inline">\(\beta\)</span>, <span
class="math inline">\(\Theta\)</span>, and <span
class="math inline">\(\Phi\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>
above). The scattering directions are, just as for other targets,
determined by the scattering angles <span
class="math inline">\(\theta_s\)</span>, <span
class="math inline">\(\phi_s\)</span> (see §<a
href="#sec:scattering_directions" data-reference-type="ref"
data-reference="sec:scattering_directions">[sec:scattering_directions]</a>
below).</p>
<p>The scattering problem for this infinite structure, assumed to be
illuminated by an incident monochromatic plane wave, is essentially
solved “exactly”, in the sense that the electric polarization of each of
the constituent dipoles is due to the electric field produced by the
incident plane wave plus <span><em>all</em></span> of the other dipoles
in the infinite target.</p>
<p>However, the assumed target will, of course, act as a perfect
diffraction grating if the scattered radiation is calculated as the
coherent sum of all the oscillating dipoles in this periodic structure:
the far-field scattered intensity would be zero in all directions except
those where the Bragg scattering condition is satisfied, and in those
directions the far-field scattering intensity would be infinite.</p>
<p>To suppress this singular behavior, we calculate the far-field
scattered intensity as though the separate TUCs scatter incoherently.
The scattering efficiency <span class="math inline">\(Q_{\rm
sca}\)</span> and the absorption efficiency <span
class="math inline">\(Q_{\rm abs}\)</span> are defined to be the
scattering and absorption cross section per TUC, divided by <span
class="math inline">\(\pi {a}_{\rm eff}^2\)</span>, where <span
class="math inline">\({a}_{\rm eff}\equiv(3V_{\rm
TUC}/4\pi)^{1/3}\)</span>, where <span class="math inline">\(V_{\rm
TUC}\)</span> is the volume of solid material per TUC.</p>
<p>Note: the user is allowed to set the target periodicity in the target
<span class="math inline">\(y_{\rm TF}\)</span> (or <span
class="math inline">\(z_{\rm TF}\)</span>) direction to values that
could be smaller than the total extent of one TUC in the target <span
class="math inline">\(y_{\rm TF}\)</span> (or <span
class="math inline">\(z_{\rm TF}\)</span>) direction. This is physically
allowable, <span><em>provided that the spheres from one TUC do not
overlap with the spheres from neighboring TUCs</em></span>. Note that
<span><strong>DDSCAT</strong></span> does <span><em>not</em></span>
check for such overlap.</p>
<h3
id="sample-calculation-in-directory-examples_expsphrn_pbc"><strong>Sample
calculation in directory examples_exp/SPHRN_PBC</strong></h3>
<p>Subdirectory <span><code>examples_exp/SPHRN_PBC</code></span>
contains <span><code>ddscat.par</code></span> to calculate scattering by
a doubly-periodic array with the target unit cell consisting of a random
cluster of 16 spheres. The calculation is carried out with double
precision arithmetic. Because convergence is slow, the error tolerance
is set to <span><code>TOL = 5.e-5</code></span> rather than the usual
<span><code>1.e-5</code></span>, and the maximum number of iterations
allowed is increased to <span><code>MXITER = 2000</code></span>.</p>
<h2 id="sec:TRILYRPBC"> TRILYRPBC = Three stacked rectangular blocks,
repeated periodically</h2>
<p>The target unit cell (TUC) consists of a stack of 3 rectangular
blocks with centers on the <span class="math inline">\(\hat{\bf x}_{\rm
TF}\)</span> axis. The TUC is repeated in either the <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span> direction, the <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span> direction, or both.
A total of 11 shape parameters must be specified:<br />
<span><code>SHPAR</code><span class="math inline">\(_1\)</span></span> =
x-thickness of upper layer/<span class="math inline">\(d\)</span>
[material 1]<br />
<span><code>SHPAR</code><span class="math inline">\(_2\)</span></span> =
y-width/<span class="math inline">\(d\)</span> of upper layer<br />
<span><code>SHPAR</code></span><span class="math inline">\(_3\)</span> =
z-width/<span class="math inline">\(d\)</span> of upper layer<br />
<span><code>SHPAR</code></span><span class="math inline">\(_4\)</span> =
x-thickness/<span class="math inline">\(d\)</span> of middle layer
[material 2]<br />
<span><code>SHPAR</code></span><span class="math inline">\(_5\)</span> =
y-width/<span class="math inline">\(d\)</span> of middle layer<br />
<span><code>SHPAR</code></span><span class="math inline">\(_6\)</span> =
z-width/<span class="math inline">\(d\)</span> of middle layer<br />
<span><code>SHPAR</code></span><span class="math inline">\(_7\)</span> =
x-width/<span class="math inline">\(d\)</span> of lower layer<br />
<span><code>SHPAR</code></span><span class="math inline">\(_8\)</span> =
y-width/<span class="math inline">\(d\)</span> of lower layer<br />
<span><code>SHPAR</code></span><span class="math inline">\(_9\)</span> =
z-width/<span class="math inline">\(d\)</span> of lower layer<br />
<span><code>SHPAR</code></span><span
class="math inline">\(_{10}\)</span> = period/<span
class="math inline">\(d\)</span> in y direction<br />
<span><code>SHPAR</code></span><span
class="math inline">\(_{11}\)</span>= period/<span
class="math inline">\(d\)</span> in z direction</p>
<h1 id="scattering-directions">Scattering Directions <span
id="sec:scattering_directions"
label="sec:scattering_directions"></span></h1>
<h2 id="isolated-finite-targets-1"> Isolated Finite Targets</h2>
<p><span><strong>DDSCAT</strong></span> calculates scattering in
selected directions, and elements of the scattering matrix are reported
in the output files
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.sca</code></span>
. The scattering direction is specified through angles <span
class="math inline">\(\theta_s\)</span> and <span
class="math inline">\(\phi_s\)</span> (not to be confused with the
angles <span class="math inline">\(\Theta\)</span> and <span
class="math inline">\(\Phi\)</span> which specify the orientation of the
target relative to the incident radiation!).</p>
<p>For isolated finite targets (<span><em>i.e.,</em></span> PBC
<span><em>not</em></span> employed) there are two options for specifying
the scattering direction, with the option determined by the value of the
string <span><code>CMDFRM</code></span> read from the input file
<span><code>ddscat.par</code></span>.</p>
<ol>
<li><p>If the user specifies <span><code>CMDFRM=’LFRAME’</code></span>,
then the angles <span class="math inline">\(\theta\)</span>, <span
class="math inline">\(\phi\)</span> input from
<span><code>ddscat.par</code></span> are understood to specify the
scattering directions relative to the Lab Frame (the frame where the
incident beam is in the <span
class="math inline">\(x-\)</span>direction).</p>
<p>When <span><code>CMDFRM=’LFRAME’</code></span>, the angle <span
class="math inline">\(\theta\)</span> is simply the scattering angle
<span class="math inline">\(\theta_s\)</span>: the angle between the
incident beam (in direction <span class="math inline">\(\hat{\bf x}_{\rm
LF}\)</span>) and the scattered beam (<span
class="math inline">\(\theta_s=0\)</span> for forward scattering, <span
class="math inline">\(\theta_s=180^\circ\)</span> for
backscattering).</p>
<p>The angle <span class="math inline">\(\phi\)</span> specifies the
orientation of the “scattering plane” relative to the <span
class="math inline">\(\hat{\bf x}_{\rm LF}- \hat{\bf y}_{\rm
LF}\)</span> plane. When <span class="math inline">\(\phi=0\)</span> the
scattering plane is assumed to coincide with the <span
class="math inline">\(\hat{\bf x}_{\rm LF}- \hat{\bf y}_{\rm
LF}\)</span> plane. When <span
class="math inline">\(\phi=90^\circ\)</span> the scattering plane is
assumed to coincide with the <span class="math inline">\({\hat{\bf
x}_{\rm LF}-\hat{\bf z}_{\rm LF}}\)</span> plane. Within the scattering
plane the scattering directions are specified by <span
class="math inline">\(0\leq\theta\leq180^\circ\)</span>. Thus: <span
class="math display">\[\hat{\bf n}_s =
\hat{\bf x}_{\rm LF}\cos\theta + \hat{\bf y}_{\rm LF}\sin\theta\cos\phi
+ \hat{\bf z}_{\rm LF}\sin\theta\sin\phi
~~~,~~~\]</span></p></li>
<li><p>If the user specifies <span><code>CMDFRM=’TFRAME’</code></span>,
then the angles <span class="math inline">\(\theta\)</span>, <span
class="math inline">\(\phi\)</span> input from
<span><code>ddscat.par</code></span> are understood to specify the
scattering directions <span class="math inline">\(\bf\hat{n}_s\)</span>
relative to the Target Frame (the frame defined by target axes <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>). <span
class="math inline">\(\theta\)</span> is the angle between <span
class="math inline">\(\hat{\bf n}_s\)</span> and <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, and <span
class="math inline">\(\phi\)</span> is the angle between the <span
class="math inline">\(\hat{\bf n}_s-\hat{\bf x}_{\rm TF}\)</span> plane
and the <span class="math inline">\(\hat{\bf x}_{\rm TF}-\hat{\bf
y}_{\rm TF}\)</span> plane. Thus: <span class="math display">\[\hat{\bf
n}_s = \hat{\bf x}_{\rm TF}\cos\theta + \hat{\bf y}_{\rm
TF}\sin\theta\cos\phi + \hat{\bf z}_{\rm TF}\sin\theta\sin\phi
~~~.~~~\]</span></p></li>
</ol>
<p>Scattering directions for which the scattering properties are to be
calculated are set in the parameter file
<span><code>ddscat.par</code></span> by specifying one or more
scattering planes (determined by the value of <span
class="math inline">\(\phi_s\)</span>) and for each scattering plane,
the number and range of <span class="math inline">\(\theta_s\)</span>
values. The only limitation is that the number of scattering directions
not exceed the parameter <span><code>MXSCA</code></span> in
<span><code>DDSCAT.f</code></span> (in the code as distributed it is set
to <span><code>MXSCA=1000</code></span>).</p>
<h2
id="scattering-directions-for-targets-that-are-periodic-in-1-dimension">Scattering
Directions for Targets that are Periodic in 1 Dimension <span
id="sec:scattering_directions:1d"
label="sec:scattering_directions:1d"></span></h2>
<p>For targets that are periodic, scattering is only allowed in certain
directions <span class="citation"
data-cites="Draine+Flatau_2008a"></span>. If the user has chosen a PBC
target (e.g, <span><code>CYLNDRPBC</code></span>,
<span><code>HEXGONPBC</code></span>, or
<span><code>RCTGL_PBC</code></span>),
<span><code>SPHRN_PBC</code></span> but has set one of the periodicities
to zero, then the target is periodic in only one dimension – e.g.,
<span><code>CYLNDRPBC</code></span> could be used to construct a single
infinite cylinder.</p>
<p>In this case, the scattering directions are specified by giving an
integral diffraction order <span
class="math inline">\(M=0,\pm1,\pm2,...\)</span> and one angle, the
azimuthal angle <span class="math inline">\(\zeta\)</span> around the
target repetition axis. The diffraction order <span
class="math inline">\(M\)</span> determines the projection of <span
class="math inline">\({\bf k}_{s}\)</span> onto the repetition
direction. For a given order <span class="math inline">\(M\)</span>, the
scattering angles with <span
class="math inline">\(\zeta=0\rightarrow2\pi\)</span> form a cone around
the repetition direction.</p>
<p>For example, if <span class="math inline">\({\tt PYD}&gt;0\)</span>
(target repeating in the <span class="math inline">\(y_{\rm TF}\)</span>
direction), then <span class="math inline">\(M\)</span> determines the
value of <span class="math inline">\(k_{sy}={\bf k}_s \cdot \hat{\bf
y}_{\rm TF}\)</span>, where <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span> is the unit vector in the Target Frame <span
class="math inline">\(y-\)</span>direction: <span
class="math display">\[k_{sy} = k_{0y} + 2\pi M/L_y\]</span> where <span
class="math inline">\(k_{0y}\equiv {\bf k}_0\cdot \hat{\bf y}_{\rm
TF}\)</span>, where <span class="math inline">\({\bf k}_0\)</span> is
the incident <span class="math inline">\(k\)</span> vector. Note that
the diffraction order <span class="math inline">\(M\)</span>
<span><em>must</em></span> satisfy the condition <span
class="math display">\[\label{eq:condition on M}
(k_{0y}-k_{0})(L_y/2\pi) &lt; M &lt; (k_0-k_{0y})(L_y/2\pi)\]</span>
where <span class="math inline">\(L_y={\tt PYD}\times d\)</span> is the
periodicity along the <span class="math inline">\(y\)</span> axis in the
Target Frame. <span class="math inline">\(M=0\)</span> is always an
allowed diffraction order.</p>
<p>The azimuthal angle <span class="math inline">\(\zeta\)</span>
defines a right-handed rotation of the scattering direction around the
target repetition axis. Thus for a target repetition axis <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, <span
class="math display">\[\begin{aligned}
k_{sx} &amp;=&amp; k_\perp \cos\zeta ~~~,
\\
k_{sz} &amp;=&amp; k_\perp \sin\zeta ~~~,
\end{aligned}\]</span> where <span class="math inline">\(k_\perp =
(k_0^2-k_{sy}^2)^{1/2}\)</span>, with <span
class="math inline">\(k_{sy}=k_{0y}+2\pi M/L_y\)</span>. For a target
with repetition axis <span class="math inline">\(z_{\rm TF}\)</span>,
<span class="math display">\[\begin{aligned}
k_{sx} &amp;=&amp; k_\perp \cos\zeta ~~~,
\\
k_{sy} &amp;=&amp; k_\perp \sin\zeta ~~~,
\end{aligned}\]</span> where <span class="math inline">\(k_\perp =
(k_0^2-k_{sz}^2)^{1/2}\)</span>, <span
class="math inline">\(k_{sz}=k_{0z}+2\pi M/L_z\)</span>.</p>
<p>The user selects a diffraction order <span
class="math inline">\(M\)</span> and the azimuthal angles <span
class="math inline">\(\zeta\)</span> to be used for that <span
class="math inline">\(M\)</span> via one line in
<span><code>ddscat.par</code></span>. An example would be to use
<span><code>CYLNDRPBC</code></span> to construct an infinite cylinder
with the cylinder direction in the <span class="math inline">\(\hat{\bf
y}_{\rm TF}\)</span> direction: e.g.,
<span><code>examples_exp/CYLNDRPBC/ddscat.par</code></span> :</p>
<pre><code>&#39; ========== Parameter file for v7.3 ===================&#39; 
&#39;**** Preliminaries ****&#39;
&#39;NOTORQ&#39; = CMTORQ*6 (DOTORQ, NOTORQ) -- either do or skip torque calculations
&#39;PBCGS2&#39; = CMDSOL*6 (PBCGS2, PBCGST, GPBICG, QMRCCG, PETRKP) -- CCG method
&#39;GPFAFT&#39; = CMETHD*6 (GPFAFT, FFTMKL) -- FFT method
&#39;GKDLDR&#39; = CALPHA*6 (GKDLDR, LATTDR, FLTRCD) -- DDA method
&#39;NOTBIN&#39; = CBINFLAG (NOTBIN, ORIGIN, ALLBIN)
&#39;**** Initial Memory Allocation ****&#39;
100 100 100 = dimensioning allowance for target generation
&#39;**** Target Geometry and Composition ****&#39;
&#39;CYLNDRPBC&#39; = CSHAPE*9 shape directive
1 64.499 2 1.0 0.0  = shape parameters 1 - 7
1         = NCOMP = number of dielectric materials
&#39;../diel/m1.33_0.01&#39; = file with refractive index 1
&#39;**** Additional Nearfield calculation? ****&#39;
0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
0.0 0.0 0.0 0.0 0.0 0.0 (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)
&#39;**** Error Tolerance ****&#39;
1.00e-5 = TOL = MAX ALLOWED (NORM OF |G&gt;=AC|E&gt;-ACA|X&gt;)/(NORM OF AC|E&gt;)
&#39;**** Maximum number of iterations ****&#39;
200      = MXITER
&#39;**** Integration limiter for PBC calculations ****&#39;
1.00e-3 = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)
&#39;**** Angular resolution for calculation of &lt;cos&gt;, etc. ****&#39;
0.5 = ETASCA (number of angles is proportional to [(3+x)/ETASCA]^2 )
&#39;**** Vacuum wavelengths (micron) ****&#39;
6.283185 6.283185 1 &#39;LIN&#39; = wavelengths (first,last,how many,how=LIN,INV,LOG)
&#39;**** Refractive index of ambient medium&#39;
1.0000 = NAMBIENT
&#39;**** Effective Radii (micron) **** &#39;
2.8555 2.8555 1 &#39;LIN&#39; = aeff (first,last,how many,how=LIN,INV,LOG)
&#39;**** Define Incident Polarizations ****&#39;
(0,0) (1.,0.) (0.,0.) = Polarization state e01 (k along x axis)
2 = IORTH  (=1 to do only pol. state e01; =2 to also do orth. pol. state)
&#39;**** Specify which output files to write ****&#39;
1 = IWRKSC (=0 to suppress, =1 to write &quot;.sca&quot; file for each target orient.
&#39;**** Specify Target Rotations ****&#39;
0.    0.   1  = BETAMI, BETAMX, NBETA  (beta=rotation around a1)
60.  60.   1  = THETMI, THETMX, NTHETA (theta=angle between a1 and k)
0.    0.   1  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
&#39;**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****&#39;
0   0   0    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
&#39;**** Select Elements of S_ij Matrix to Print ****&#39;
6   = NSMELTS = number of elements of S_ij to print (not more than 9)
11 12 21 22 31 41   = indices ij of elements to print
&#39;**** Specify Scattered Directions ****&#39;
&#39;TFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
1 = NPLANES = number of scattering cones
0.  0. 180. 1  = OrderM zetamin zetamax dzeta for scattering cone 1</code></pre>
<p>In this example, a single diffraction order <span
class="math inline">\(M=0\)</span> is selected, and <span
class="math inline">\(\zeta\)</span> is to run from <span
class="math inline">\(\zeta_{\rm min}=0\)</span> to <span
class="math inline">\(\zeta_{\rm max}=180^\circ\)</span> in increments
of <span class="math inline">\(\delta\zeta = 0.05^\circ\)</span>.</p>
<p>There may be additional lines, one per diffraction order. Remember,
however, that every diffraction order must satisfy eq. (<a
href="#eq:condition on M" data-reference-type="ref"
data-reference="eq:condition on M">[eq:condition on M]</a>).</p>
<h2
id="scattering-directions-for-targets-for-doubly-periodic-targets">Scattering
Directions for Targets for Doubly-Periodic Targets <span
id="sec:scattering_directions:2d"
label="sec:scattering_directions:2d"></span></h2>
<p>If the user has specified nonzero periodicity in both the <span
class="math inline">\(y\)</span> and <span
class="math inline">\(z\)</span> directions, then the scattering
directions are specified by two integers – the diffraction orders <span
class="math inline">\(M,N\)</span> for the <span
class="math inline">\(\hat{\bf y},\hat{\bf z}\)</span> directions. The
scattering directions are <span
class="math display">\[\label{eq:k_s(M,N)}
{\bf k}_s = \pm\, \frac{k_n}{k_0} \left({\bf k}_0\cdot\hat{\bf x}_{\rm
TF}\right)\hat{\bf x}_{\rm TF}+
          \left({\bf k}_{0}\cdot\hat{\bf y}_{\rm TF}+\frac{2\pi
M}{L_y}\right)\hat{\bf y}_{\rm TF}+
          \left({\bf k}_{0}\cdot\hat{\bf z}_{\rm TF}+\frac{2\pi
N}{L_z}\right)\hat{\bf z}_{\rm TF}\]</span> <span
class="math display">\[k_n \equiv \left[k_0^2 -
           \left({\bf k}_0\cdot\hat{\bf y}_{\rm TF}+\frac{2\pi
M}{L_y}\right)^2 +
           \left({\bf k}_0\cdot\hat{\bf z}_{\rm TF}+\frac{2\pi
N}{L_z}\right)^2
           \right]^{1/2}\]</span> where the <span
class="math inline">\(+\)</span> sign gives transmission, and the <span
class="math inline">\(-\)</span> sign gives reflection. The integers
<span class="math inline">\(M\)</span> and <span
class="math inline">\(N\)</span> <span><em>must</em></span> together
satisfy the inequality <span class="math display">\[\label{eq:condition
on M and N}
({\bf k}_0\cdot\hat{\bf y}_{\rm TF}+ 2\pi M/L_y)^2 + ({\bf
k}_0\cdot\hat{\bf z}_{\rm TF}+ 2\pi N/L_z)^2 &lt; k_{0}^2\]</span>
which, for small values of <span class="math inline">\(L_y\)</span> and
<span class="math inline">\(L_z\)</span>, may limit the scattering to
only <span class="math inline">\((M,N)=(0,0)\)</span>. [Of course, <span
class="math inline">\((0,0)\)</span> is <span><em>always</em></span>
allowed]. For each <span class="math inline">\((M,N)\)</span> specified
in <span><code>ddscat.par</code></span>, <span><strong>DDSCAT
7.3</strong></span> will calculate the generalized Mueller matrix <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> – see §<a
href="#subsec:S^{(2d)}" data-reference-type="ref"
data-reference="subsec:S^{(2d)}">[subsec:S^{(2d)}]</a>. At large
distances from the infinite slab, the scattered Stokes vector in the
<span class="math inline">\((M,N)\)</span> diffraction order is <span
class="math display">\[I_{sca,i}(M,N) = \sum_{j=1}^{4}
S_{ij}^{(2d)}(M,N) I_{in,j}\]</span> where <span
class="math inline">\(I_{in,j}\)</span> is the incident Stokes vector,
and <span class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> is the
generalization of the <span class="math inline">\(4\times4\)</span>
Müller scattering matrix to targets that are periodic in 2-directions
<span class="citation" data-cites="Draine+Flatau_2008a"></span>. There
are distinct <span class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> for
transmission and for reflection, corresponding to the <span
class="math inline">\(\pm\)</span> in eq. (<a href="#eq:k_s(M,N)"
data-reference-type="ref"
data-reference="eq:k_s(M,N)">[eq:k_s(M,N)]</a>).</p>
<p><span class="citation" data-cites="Draine+Flatau_2008a"></span> (eq.
69-71) show how the <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> are easily related to
familiar "transmission coefficients" and "reflection coefficients".</p>
<p>Here is <span><code>examples_exp/RCTGL_PBC/ddscat.par</code></span>
file as an example:</p>
<pre><code>&#39; =========== Parameter file for v7.3 ===================&#39; 
&#39;**** Preliminaries ****&#39;
&#39;NOTORQ&#39; = CMTORQ*6 (DOTORQ, NOTORQ) -- either do or skip torque calculations
&#39;PBCGS2&#39; = CMDSOL*6 (PBCGS2,PBCGST, GPBICG, QMRCCG, PETRKP) -- CCG method
&#39;GPFAFT&#39; = CMDFFT*6 (GPFAFT, FFTMKL) -- FFT method
&#39;GKDLDR&#39; = CALPHA*6 (GKDLDR, LATTDR, FLTRCD) -- DDA method
&#39;NOTBIN&#39; = CBINFLAG (NOTBIN, ORIBIN, ALLBIN)
&#39;**** Initial Memory Allocation ****&#39;
100 100 100 = dimensioning allowance for target generation
&#39;**** Target Geometry and Composition ****&#39;
&#39;RCTGL_PBC&#39; = CSHAPE*9 shape directive
20 1 1 1 1 = shpar1 - shpar5 (see README.txt)
1         = NCOMP = number of dielectric materials
&#39;../diel/m1.50_0.02&#39;    = refractive index 1
&#39;**** Additional Nearfield calculation? ****&#39;
0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
0.0 0.0 0.0 0.0 0.0 0.0 (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)
&#39;**** Error Tolerance ****&#39;
1.00e-5 = TOL = MAX ALLOWED (NORM OF |G&gt;=AC|E&gt;-ACA|X&gt;)/(NORM OF AC|E&gt;)
&#39;**** Maximum number of iterations ****&#39;
100      = MXITER
&#39;**** Integration limiter for PBC calculations ****&#39;
1.00e-2 = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)
&#39;**** Angular resolution for calculation of &lt;cos&gt;, etc. ****&#39;
1.  = ETASCA (number of angles is proportional to [(3+x)/ETASCA]^2 )
&#39;**** Vacuum wavelengths (micron) ****&#39;
0.5 0.5 1 &#39;LIN&#39; = wavelengths (first,last,how many,how=LIN,INV,LOG)
&#39;**** Refractive index of ambient medium&#39;
1.000 = NAMBIENT
&#39;**** Effective Radii (micron) **** &#39;
0.0084195 0.0084195 1 &#39;LIN&#39; = aeff (first,last,how many,how=LIN,INV,LOG)
&#39;**** Define Incident Polarizations ****&#39;
(0,0) (1.,0.) (0.,0.) = Polarization state e01 (k along x axis)
2 = IORTH  (=1 to do only pol. state e01; =2 to also do orth. pol. state)
&#39;**** Specify which output files to write ****&#39;
1 = IWRKSC (=0 to suppress, =1 to write &quot;.sca&quot; file for each target orient.
&#39;**** Prescribe Target Rotations ****&#39;
0.   0.   1  = BETAMI, BETAMX, NBETA (beta=rotation around a1)
40. 40.   1  = THETMI, THETMX, NTHETA (theta=angle between a1 and k)
0.   0.   1  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
&#39;**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****&#39;
0   0   0    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
&#39;**** Select Elements of S_ij Matrix to Print ****&#39;
6       = NSMELTS = number of elements of S_ij to print (not more than 9)
11 12 21 22 31 41       = indices ij of elements to print
&#39;**** Specify Scattered Directions ****&#39;
&#39;TFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
1 = NORDERS = number of diffraction orders for transmission
0. 0.</code></pre>
<h1 id="incident-polarization-state">Incident Polarization State<span
id="sec:incident_polarization"
label="sec:incident_polarization"></span></h1>
<p>Recall that the “Lab Frame” is defined such that the incident
radiation is propagating along the <span class="math inline">\(\hat{\bf
x}_{\rm LF}\)</span> axis. <span><strong>DDSCAT</strong></span> allows
the user to specify a general elliptical polarization for the incident
radiation, by specifying the (complex) polarization vector <span
class="math inline">\({\hat{\bf e}}_{01}\)</span>. The orthonormal
polarization state <span class="math inline">\({\hat{\bf
e}}_{02}=\hat{\bf x}_{\rm LF}\times{\hat{\bf e}}_{01}^*\)</span> is
generated automatically if <span><code>ddscat.par</code></span>
specifies <span><code>IORTH=2</code></span>.</p>
<p>For incident linear polarization, one can simply set <span
class="math inline">\({\hat{\bf
e}}_{01}={\hat{\bf y}}\)</span> by specifying<br />
<span><code>(0,0) (1,0) (0,0)</code></span><br />
in <span><code>ddscat.par</code></span>; then <span
class="math inline">\({\hat{\bf e}}_{02}={\hat{\bf z}}\)</span>. For
polarization mode <span class="math inline">\({\hat{\bf
e}}_{01}\)</span> to correspond to right-handed circular polarization,
set <span class="math inline">\({\hat{\bf e}}_{01}=({\hat{\bf
y}}+i{\hat{\bf
z}})/\surd2\)</span> by specifying
<span><code>(0,0) (1,0) (0,1)</code></span> in
<span><code>ddscat.par</code></span>
(<span><strong>DDSCAT</strong></span> automatically takes care of the
normalization of <span class="math inline">\({\hat{\bf
e}}_{01}\)</span>); then <span class="math inline">\({\hat{\bf
e}}_{02}=(i{\hat{\bf y}}+{\hat{\bf z}})/\surd2\)</span>, corresponding
to left-handed circular polarization.</p>
<h1
id="averaging-over-scattering-directions-g1langlecostheta_srangle-etc.">Averaging
over Scattering Directions: <span
class="math inline">\(g(1)=\langle\cos\theta_s\rangle\)</span>,
etc.<span id="sec:averaging_scattering"
label="sec:averaging_scattering"></span></h1>
<h2 id="angular-averaging">Angular Averaging</h2>
<div class="center">
<figure>
<img src="f_cube_S11.png" id="fig:cube_S11" style="width:8.3cm"
alt="Scattered intensity for incident unpolarized light for a cube with m=1.5+0.001i and x=2\pi a_{\rm eff}/\lambda=6.5 (i.e., d/\lambda=1.6676, where d is the length of a side). The cube is tilted with respect to the incident radiation, with \Theta=30^\circ, and rotated by \beta=15^\circ around its axis to break reflection symmetry. The Mueller matrix element S_{11} is shown for 4 different scattering planes. The strong forward scattering lobe is evident. It is also seen that the scattered intensity is a strong function of scattering angle \phi_s as well as \theta_s – at a given value of \theta_s (e.g., \theta_s=120^\circ), the scattered intensity can vary by orders of magnitude as \phi_s changes by 90^\circ." />
<figcaption aria-hidden="true">Scattered intensity for incident
unpolarized light for a cube with <span
class="math inline">\(m=1.5+0.001i\)</span> and <span
class="math inline">\(x=2\pi a_{\rm eff}/\lambda=6.5\)</span> (i.e.,
<span class="math inline">\(d/\lambda=1.6676\)</span>, where <span
class="math inline">\(d\)</span> is the length of a side). The cube is
tilted with respect to the incident radiation, with <span
class="math inline">\(\Theta=30^\circ\)</span>, and rotated by <span
class="math inline">\(\beta=15^\circ\)</span> around its axis to break
reflection symmetry. The Mueller matrix element <span
class="math inline">\(S_{11}\)</span> is shown for 4 different
scattering planes. The strong forward scattering lobe is evident. It is
also seen that the scattered intensity is a strong function of
scattering angle <span class="math inline">\(\phi_s\)</span> as well as
<span class="math inline">\(\theta_s\)</span> – at a given value of
<span class="math inline">\(\theta_s\)</span> (e.g., <span
class="math inline">\(\theta_s=120^\circ\)</span>), the scattered
intensity can vary by orders of magnitude as <span
class="math inline">\(\phi_s\)</span> changes by <span
class="math inline">\(90^\circ\)</span>.</figcaption>
</figure>
</div>
<p>An example of scattering by a nonspherical target is shown in Fig. <a
href="#fig:cube_S11" data-reference-type="ref"
data-reference="fig:cube_S11">9</a>, showing the scattering for a tilted
cube. Results are shown for four different scattering planes.</p>
<p><span><strong>DDSCAT</strong></span> automatically carries out
numerical integration of various scattering properties, including</p>
<ul>
<li><p><span
class="math inline">\(\langle\cos\theta_s\rangle\)</span>;</p></li>
<li><p><span
class="math inline">\(\langle\cos^2\theta_s\rangle\)</span>;</p></li>
<li><p><span class="math inline">\({\bf
g}=\langle\cos\theta_s\rangle\hat{\bf x}_{\rm LF}+
    \langle\sin\theta_s\cos\phi_s\rangle{\hat{\bf y}}+
    \langle\sin\theta_s\sin\phi_s\rangle{\hat{\bf z}}~\)</span> (see §<a
href="#sec:force and torque calculation" data-reference-type="ref"
data-reference="sec:force and torque calculation">[sec:force and torque
calculation]</a>);</p></li>
<li><p><span class="math inline">\({\bf Q}_{\Gamma}\)</span>, provided
option <span><code>DOTORQ</code></span> is specified (see §<a
href="#sec:force and torque calculation" data-reference-type="ref"
data-reference="sec:force and torque calculation">[sec:force and torque
calculation]</a>).</p></li>
</ul>
<p>The angular averages are accomplished by evaluating the scattered
intensity for selected scattering directions <span
class="math inline">\((\theta_s,\phi_s)\)</span>, and taking the
appropriately weighted sum. Suppose that we have <span
class="math inline">\(N_\theta\)</span> different values of <span
class="math inline">\(\theta_s\)</span>, <span
class="math display">\[\theta = \theta_j, ~~~j=1,..., N_\theta
~~~,\]</span> and for each value of <span
class="math inline">\(\theta_j\)</span>, <span
class="math inline">\(N_\phi(j)\)</span> different values of <span
class="math inline">\(\phi_s\)</span>: <span
class="math display">\[\phi_s = \phi_{j,k}, ~~~k=1,...,N_\phi(j)
~~~.\]</span> For a given <span class="math inline">\(j\)</span>, the
values of <span class="math inline">\(\phi_{j,k}\)</span> are assumed to
be uniformly spaced: <span
class="math inline">\(\phi_{j,k+1}-\phi_{j,k}=2\pi/N_\phi(j)\)</span>.
The angular average of a quantity <span
class="math inline">\(f(\theta_s,\phi_s)\)</span> is approximated by
<span class="math display">\[\label{eq:average}
\langle f \rangle \equiv \frac{1}{4\pi}\int_{0}^{\pi}\sin\theta_s
d\theta_s
\int_{0}^{2\pi}d\phi_s f(\theta_s,\phi_s)
~\approx~ \frac{1}{4\pi}\sum_{j=1}^{N_\theta}
                    \sum_{k=1}^{N_\phi(j)} f(\theta_j,\phi_{j,k})
\Omega_{j,k}\]</span> <span class="math display">\[\Omega_{j,k} =
\frac{\pi}{N_\phi(j)}
\left[\cos(\theta_{j-1})-\cos(\theta_{j+1})\right]
~~~,
~~~j=2,...,N_\theta-1
~~~.\]</span> <span class="math display">\[\Omega_{1,k} =
\frac{2\pi}{N_\phi(1)}
\left[1-\frac{\cos(\theta_1)+\cos(\theta_2)}{2}\right]
~~~,\]</span> <span class="math display">\[\Omega_{N_\theta,k} =
\frac{2\pi}{N_\phi(N_\theta)}
\left[
\frac{\cos(\theta_{N_\theta-1})+\cos(\theta_{N_\theta})}{2}
+1\right]
~~~.\]</span> For a sufficiently large number of scattering directions
<span class="math display">\[N_{\rm sca}\equiv \sum_{j=1}^{N_\theta}
N_\phi(j)\]</span> the sum (<a href="#eq:average"
data-reference-type="ref" data-reference="eq:average">[eq:average]</a>)
approaches the desired integral, but the calculations can be a
significant cpu-time burden, so efficiency is an important
consideration.</p>
<h2 id="selection-of-scattering-angles-theta_sphi_s">Selection of
Scattering Angles <span
class="math inline">\(\theta_s,\phi_s\)</span></h2>
<p>Beginning with <span><strong>DDSCAT 6.1</strong></span>, an improved
approach is taken to evaluation of the angular average. Since targets
with large values of <span class="math inline">\(x=2\pi a_{\rm
eff}/\lambda\)</span> in general have strong forward scattering, it is
important to obtain good sampling of the forward scattering direction.
To implement a preferential sampling of the forward scattering
directions, the scattering directions <span
class="math inline">\((\theta,\phi)\)</span> are chosen so that <span
class="math inline">\(\theta\)</span> values correspond to equal
intervals in a monotonically increasing function <span
class="math inline">\(s(\theta)\)</span>. The function <span
class="math inline">\(s(\theta)\)</span> is chosen to have a negative
second derivative <span class="math inline">\(d^2s/d\theta^2 &lt;
0\)</span> so that the density of scattering directions will be higher
for small values of <span class="math inline">\(\theta\)</span>.
<span><strong>DDSCAT</strong></span> takes <span
class="math display">\[s(\theta) = \theta +
\frac{\theta}{\theta+\theta_0} ~~~.\]</span> This provides increased
resolution (i.e., increased <span
class="math inline">\(ds/d\theta\)</span>) for <span
class="math inline">\(\theta &lt; \theta_0\)</span>. We want this for
the forward scattering lobe, so we take <span
class="math display">\[\theta_0 = \frac{2\pi}{1+x}
~~.\]</span> The <span class="math inline">\(\theta\)</span> values run
from <span class="math inline">\(\theta=0\)</span> to <span
class="math inline">\(\theta=\pi\)</span>, corresponding to uniform
increments <span class="math display">\[\Delta
s=\frac{1}{N_\theta-1}\left(\pi+\frac{\pi}{\pi+\theta_0}\right)
~~~.\]</span> If we now require that <span
class="math display">\[\max[\Delta\theta] \approx \frac{\Delta
s}{(ds/d\theta)_{\theta=\pi} }=
\eta \frac{\pi/2}{3+x}
~~~,\]</span> we determine the number of values of <span
class="math inline">\(\theta\)</span>: <span
class="math display">\[N_\theta = 1 + \frac{2(3+x)}{\eta} \frac{
\left[1+1/(\pi+\theta_0)\right]}{\left[1+\theta_0/(\pi+\theta_0)^2\right]}
~~~.\]</span> Thus for small values of <span
class="math inline">\(x\)</span>, <span
class="math inline">\(\max[\Delta\theta]=30^\circ \eta\)</span>, and for
<span class="math inline">\(x\gg 1\)</span>, <span
class="math inline">\(\max[\Delta\theta]\rightarrow
90^\circ\eta/x\)</span>. For a sphere, minima in the scattering pattern
are separated by <span class="math inline">\(\sim180^\circ/x\)</span>,
so <span class="math inline">\(\eta=1\)</span> would be expected to
marginally resolve structure in the scattering function. Smaller values
of <span class="math inline">\(\eta\)</span> will obviously lead to
improved sampling of the scattering function, and more accurate angular
averages.</p>
<div class="center">
<figure>
<img src="f_sph_eta.png" id="fig:err_eta_sphere" style="width:8.3cm"
alt="Errors in \langle\cos\theta\rangle and \langle\cos^2\theta\rangle calculated for a N=17904 dipole pseudosphere with m=1.33+0.01i, as functions of x=2\pi a/\lambda. Results are shown for different values of the parameter \eta. " />
<figcaption aria-hidden="true">Errors in <span
class="math inline">\(\langle\cos\theta\rangle\)</span> and <span
class="math inline">\(\langle\cos^2\theta\rangle\)</span> calculated for
a <span class="math inline">\(N=17904\)</span> dipole pseudosphere with
<span class="math inline">\(m=1.33+0.01i\)</span>, as functions of <span
class="math inline">\(x=2\pi a/\lambda\)</span>. Results are shown for
different values of the parameter <span
class="math inline">\(\eta\)</span>. </figcaption>
</figure>
</div>
<div class="center">
<figure>
<img src="f_cube_eta.png" id="fig:err_eta_cube" style="width:8.3cm"
alt="Same as Fig. 10, but for a N=32768 dipole cube with m=1.5+0.001i. " />
<figcaption aria-hidden="true">Same as Fig. <a
href="#fig:err_eta_sphere" data-reference-type="ref"
data-reference="fig:err_eta_sphere">10</a>, but for a <span
class="math inline">\(N=32768\)</span> dipole cube with <span
class="math inline">\(m=1.5+0.001i\)</span>. </figcaption>
</figure>
</div>
<p>The scattering angles <span class="math inline">\(\theta_j\)</span>
used for the angular averaging are then given by <span
class="math display">\[\theta_j = \frac{(s_j-1-\theta_0)+
\left[(1+\theta_0-s_j)^2+4\theta_0s_j\right]^{1/2}}{2}
~~~,\]</span> where <span class="math display">\[s_j =
\frac{(j-1)\pi}{N_\theta-1}\left[1+\frac{1}{\pi+\theta_0}\right]
~~~j=1,...,N_\theta
~~~.\]</span></p>
<p>For each <span class="math inline">\(\theta_j\)</span>, we must
choose values of <span class="math inline">\(\phi\)</span>. For <span
class="math inline">\(\theta_1=0\)</span> and <span
class="math inline">\(\theta_{N_\theta}=\pi\)</span> only a single value
of <span class="math inline">\(\phi\)</span> is needed (the scattering
is independent of <span class="math inline">\(\phi\)</span> in these two
directions). For <span
class="math inline">\(0&lt;\theta_j&lt;\pi\)</span> we use <span
class="math display">\[N_\phi=\max\left\{3,{\rm
nint}\left[4\pi\sin(\theta_j)/
(\theta_{j+1}-\theta_{j-1})\right]\right\}
~~~,\]</span> where <span class="math inline">\({\rm nint}=\)</span>
nearest integer. This provides sampling in <span
class="math inline">\(\phi\)</span> consistent with the sampling in
<span class="math inline">\(\theta\)</span>.</p>
<h2 id="accuracy-of-angular-averaging-as-a-function-of-eta">Accuracy of
Angular Averaging as a Function of <span
class="math inline">\(\eta\)</span></h2>
<p>Figure <a href="#fig:err_eta_sphere" data-reference-type="ref"
data-reference="fig:err_eta_sphere">10</a> shows the absolute errors in
<span class="math inline">\(\langle\cos\theta\rangle\)</span> and <span
class="math inline">\(\langle\cos^2\theta\rangle\)</span> calculated for
a sphere with refractive index <span
class="math inline">\(m=1.33+0.01i\)</span> using the above prescription
for choosing scattering angles. The error is shown as a function of
scattering parameter <span class="math inline">\(x\)</span>. We see that
accuracies of order 0.01 are attained with <span
class="math inline">\(\eta=1\)</span>, and that the above prescription
provides an accuracy which is approximately independent of <span
class="math inline">\(x\)</span>. We recommend using values of <span
class="math inline">\(\eta\leq 1\)</span> unless accuracy in the angular
averages is not important.</p>
<h1 id="scattering-by-finite-targets-the-mueller-matrix">Scattering by
Finite Targets: The Mueller Matrix <span id="sec:mueller_matrix"
label="sec:mueller_matrix"></span></h1>
<h2 id="two-orthogonal-incident-polarizations-iorth2"><span
id="sec:IORTH=2" label="sec:IORTH=2"></span> Two Orthogonal Incident
Polarizations (<span><code>IORTH=2</code></span>)</h2>
<p>Subsection <a href="#sec:IORTH=2" data-reference-type="ref"
data-reference="sec:IORTH=2">[sec:IORTH=2]</a> is intended for those
studying the internals of <span><strong>DDSCAT</strong></span> to see
how it obtains the elements of the scattering amplitude matrix <span
class="citation" data-cites="Bohren+Huffman_1983"></span> <span
class="math display">\[\left(
\begin{array}{c c}
S_2 &amp; S_3 \\
S_4 &amp; S_1
\end{array}
\right)
~~~.\]</span> Unless you are interested in such computational details,
you can skip this subsection and go forward to §<a href="#sec:Stokes"
data-reference-type="ref"
data-reference="sec:Stokes">[sec:Stokes]</a>.</p>
<p>Throughout the following discussion, <span
class="math inline">\(\hat{\bf x}_{\rm LF}\)</span>, <span
class="math inline">\(\hat{\bf y}_{\rm LF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm LF}\)</span> are unit vectors
defining the Lab Frame (thus <span class="math inline">\(\hat{\bf
k}_0=\hat{\bf x}_{\rm LF}\)</span>).</p>
<p><span><strong>DDSCAT</strong></span> internally computes the
scattering properties of the dipole array in terms of a complex
scattering matrix <span
class="math inline">\(f_{ml}(\theta_s,\phi_s)\)</span> <span
class="citation" data-cites="Draine_1988"></span>, where index <span
class="math inline">\(l=1,2\)</span> denotes the incident polarization
state, <span class="math inline">\(m=1,2\)</span> denotes the scattered
polarization state, and <span
class="math inline">\(\theta_s\)</span>,<span
class="math inline">\(\phi_s\)</span> specify the scattering direction.
Normally <span><strong>DDSCAT</strong></span> is used with
<span><code>IORTH=2</code></span> in
<span><code>ddscat.par</code></span>, so that the scattering problem
will be solved for both incident polarization states (<span
class="math inline">\(l=1\)</span> and 2); in this subsection it will be
assumed that this is the case.</p>
<p>Incident polarization states <span
class="math inline">\(l=1,2\)</span> correspond to polarization states
<span class="math inline">\({\hat{\bf e}}_{01}\)</span>, <span
class="math inline">\({\hat{\bf e}}_{02}\)</span>; recall that
polarization state <span class="math inline">\({\hat{\bf
e}}_{01}\)</span> is user-specified, and <span
class="math inline">\({\hat{\bf e}}_{02}=
\hat{\bf k}_0\times{\hat{\bf e}}_{01}^*=
\hat{\bf x}_{\rm LF}\times{\hat{\bf e}}_{01}^*\)</span>.<a href="#fn14"
class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a><span
class="math inline">\(^,\)</span><a href="#fn15" class="footnote-ref"
id="fnref15" role="doc-noteref"><sup>15</sup></a> In the
<span><strong>DDSCAT</strong></span> code, which follows the convention
in <span class="citation" data-cites="Draine_1988"></span>, scattered
polarization state <span class="math inline">\(m=1\)</span> corresponds
to linear polarization of the scattered wave parallel to the scattering
plane (<span class="math inline">\({\hat{\bf e}}_1={\hat{\bf
e}}_{\parallel s}=\hat{\theta}_s\)</span>) and <span
class="math inline">\(m=2\)</span> corresponds to linear polarization
perpendicular to the scattering plane (in the <span
class="math inline">\(+\hat{\phi}_s\)</span> direction: <span
class="math inline">\(\hat{\bf e}_2=\hat{\phi}_s\)</span>). The
scattering matrix <span class="math inline">\(f_{ml}\)</span> was
defined <span class="citation" data-cites="Draine_1988"></span> so that
the scattered electric field <span class="math inline">\({\bf
E}_s\)</span> is related to the incident electric field <span
class="math inline">\({\bf E}_i(0)\)</span> at the origin (where the
target is assumed to be located) by <span class="math display">\[\left(
\begin{array}{c}
    {\bf E}_s\cdot\hat{\theta}_s\\
    {\bf E}_s\cdot\hat{\phi}_s
\end{array}
\right)
=
{\exp(i{\bf k}_s\cdot{\bf r})\over kr}
\left(
\begin{array}{cc}
    f_{11}&amp;f_{12}\\
    f_{21}&amp;f_{22}
\end{array}
\right)
\left(
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{01}^*\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{02}^*
\end{array}
\right) ~~~.
\label{eq:f_ml_def}\]</span> The 2<span
class="math inline">\(\times\)</span>2 complex <span><em>scattering
amplitude matrix</em></span> (with elements <span
class="math inline">\(S_1\)</span>, <span
class="math inline">\(S_2\)</span>, <span
class="math inline">\(S_3\)</span>, and <span
class="math inline">\(S_4\)</span>) is defined so that <span
class="citation" data-cites="Bohren+Huffman_1983"></span> <span
class="math display">\[\left(
\begin{array}{c}
    {\bf E}_s\cdot\hat{\theta}_s\\
    -{\bf E}_s\cdot\hat{\phi}_s
\end{array}
\right)
=
{\exp(i{\bf k}_s\cdot{\bf r})\over -ikr}
\left(
\begin{array}{cc}
    S_2&amp;S_3\\
    S_4&amp;S_1
\end{array}
\right)
\left(
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\parallel}\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\perp}
\end{array}
\right)~~~,
\label{eq:S_ampl_def}\]</span> where <span
class="math inline">\({\hat{\bf e}}_{i\parallel}\)</span>, <span
class="math inline">\({\hat{\bf e}}_{i\perp}\)</span> are (real) unit
vectors for incident polarization parallel and perpendicular to the
scattering plane (with the customary definition of <span
class="math inline">\({\hat{\bf e}}_{i\perp}={\hat{\bf
e}}_{i\parallel}\times\hat{\bf k}_0=
{\hat{\bf e}}_{i\parallel}\times{\hat{\bf x}_{\rm LF}}\)</span>).</p>
<p>From (<a href="#eq:f_ml_def" data-reference-type="ref"
data-reference="eq:f_ml_def">[eq:f_ml_def]</a>,<a href="#eq:S_ampl_def"
data-reference-type="ref"
data-reference="eq:S_ampl_def">[eq:S_ampl_def]</a>) we may write <span
class="math display">\[\left(
\begin{array}{cc}
    S_2&amp;S_3\\
    S_4&amp;S_1
\end{array}
\right)
\left(
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\parallel}\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\perp}
\end{array}
\right)
=
-i
\left(
\begin{array}{cc}
    f_{11}&amp;f_{12}\\
    -f_{21}&amp;-f_{22}
\end{array}
\right)
\left(
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{01}^*\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{02}^*
\end{array}
\right) ~~~.
\label{eq:fml_rel_S_v1}\]</span></p>
<p>Let <span class="math display">\[\begin{aligned}
    a&amp;\equiv&amp; {\hat{\bf e}}_{01}^*\cdot\hat{\bf y}_{\rm
LF}~~~,\\
    b&amp;\equiv&amp; {\hat{\bf e}}_{01}^*\cdot\hat{\bf z}_{\rm
LF}~~~,\\
    c&amp;\equiv&amp; {\hat{\bf e}}_{02}^*\cdot\hat{\bf y}_{\rm
LF}~~~,\\
    d&amp;\equiv&amp; {\hat{\bf e}}_{02}^*\cdot\hat{\bf z}_{\rm LF}~~~.
\end{aligned}\]</span> Note that since <span
class="math inline">\({\hat{\bf e}}_{01}, {\hat{\bf e}}_{02}\)</span>
could be complex (i.e., elliptical polarization), the quantities <span
class="math inline">\(a,b,c,d\)</span> are complex. Then <span
class="math display">\[\left(
\begin{array}{c}
    {\hat{\bf e}}_{01}^*\\
    {\hat{\bf e}}_{02}^*
\end{array}
\right)
=
\left(
\begin{array}{cc}
    a&amp;b\\
    c&amp;d
\end{array}
\right)
\left(
\begin{array}{c}
    \hat{\bf y}_{\rm LF}\\
    \hat{\bf z}_{\rm LF}
\end{array}
\right)\]</span> and eq. (<a href="#eq:fml_rel_S_v1"
data-reference-type="ref"
data-reference="eq:fml_rel_S_v1">[eq:fml_rel_S_v1]</a>) can be written
<span class="math display">\[\left(
\begin{array}{cc}
    S_2&amp;S_3\\
    S_4&amp;S_1
\end{array}
\right)
\left(
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\parallel}\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\perp}
\end{array}
\right)
=
i
\left(
\begin{array}{cc}
    -f_{11}&amp;-f_{12}\\
    f_{21}&amp;f_{22}
\end{array}
\right)
\left(
\begin{array}{cc}
    a&amp;b\\
    c&amp;d
\end{array}
\right)
\left(
\begin{array}{c}
    {\bf E}_i(0)\cdot\hat{\bf y}_{\rm LF}\\
    {\bf E}_i(0)\cdot\hat{\bf z}_{\rm LF}
\end{array}
\right) ~~~.
\label{eq:fml_rel_S_v2}\]</span></p>
<p>The incident polarization states <span
class="math inline">\({\hat{\bf e}}_{i\parallel}\)</span> and <span
class="math inline">\({\hat{\bf e}}_{i\perp}\)</span> are related to
<span class="math inline">\(\hat{\bf y}_{\rm LF}\)</span>, <span
class="math inline">\(\hat{\bf z}_{\rm LF}\)</span> by <span
class="math display">\[\left(
\begin{array}{c}
        \hat{\bf{e}}_{i\parallel}\\
        \hat{\bf{e}}_{i\perp}
\end{array}
\right)
=
\left(
\begin{array}{cc}
    \cos\phi_s&amp; \sin\phi_s\\
    \sin\phi_s&amp; -\cos\phi_s
\end{array}
\right)
\left(
\begin{array}{c}
    \hat{\bf y}_{\rm LF}\\
    \hat{\bf z}_{\rm LF}
\end{array}
\right)\]</span> <span class="math display">\[\left(
\begin{array}{c}
    \hat{\bf y}_{\rm LF}\\
    \hat{\bf z}_{\rm LF}
\end{array}
\right)
=
\left(
\begin{array}{cc}
    \cos\phi_s&amp; \sin\phi_s\\
    \sin\phi_s&amp; -\cos\phi_s
\end{array}
\right)
\left(
\begin{array}{c}
    {\hat{\bf e}}_{i\parallel}\\
    {\hat{\bf e}}_{i\perp}
\end{array}
\right).
\label{eq:yz_vs_eis}\]</span> The angle <span
class="math inline">\(\phi_s\)</span> specifies the scattering plane,
with <span class="math display">\[\begin{aligned}
\cos\phi_s &amp;\!=\!&amp; \hat{\phi}_s \cdot \hat{\bf z}_{\rm LF}\,=\,
\hat{\bf e}_2 \cdot \hat{\bf z}_{\rm LF}~~~,
\\
\sin\phi_s &amp;\!=\!&amp; -\hat{\phi}_s \cdot \hat{\bf y}_{\rm LF}\,=\,
-\hat{\bf e}_2 \cdot \hat{\bf y}_{\rm LF}
~~~.
\end{aligned}\]</span> Substituting (<a href="#eq:yz_vs_eis"
data-reference-type="ref"
data-reference="eq:yz_vs_eis">[eq:yz_vs_eis]</a>) into (<a
href="#eq:fml_rel_S_v2" data-reference-type="ref"
data-reference="eq:fml_rel_S_v2">[eq:fml_rel_S_v2]</a>) we obtain <span
class="math display">\[\left(\!
\begin{array}{cc}
    S_2&amp;S_3\\
    S_4&amp;S_1
\end{array}
\!\right)
\left(\!
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\parallel}\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\perp}
\end{array}
\!\right)
=
i
\left(\!
\begin{array}{cc}
    -f_{11}&amp;-f_{12}\\
    f_{21}&amp;f_{22}
\end{array}
\!\right)
\left(\!
\begin{array}{cc}
    a&amp;b\\
    c&amp;d
\end{array}
\!\right)
\left(\!
\begin{array}{cc}
    \cos\phi_s&amp; \sin\phi_s\\
    \sin\phi_s&amp; -\cos\phi_s
\end{array}
\!\right)
\left(\!
\begin{array}{c}
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\parallel}\\
    {\bf E}_i(0)\cdot{\hat{\bf e}}_{i\perp}
\end{array}
\!\right)
\label{eq:fml_rel_S_v3}\]</span></p>
<p>Eq. (<a href="#eq:fml_rel_S_v3" data-reference-type="ref"
data-reference="eq:fml_rel_S_v3">[eq:fml_rel_S_v3]</a>) must be true for
all <span class="math inline">\({\bf E}_i(0)\)</span>; hence we obtain
an expression for the complex scattering amplitude matrix in terms of
the <span class="math inline">\(f_{ml}\)</span>: <span
class="math display">\[\left(
\begin{array}{cc}
    S_2&amp;S_3\\
    S_4&amp;S_1
\end{array}
\right)
=
i
\left(
\begin{array}{cc}
    -f_{11}&amp;-f_{12}\\
    f_{21}&amp;f_{22}
\end{array}
\right)
\left(
\begin{array}{cc}
    a&amp;  b\\
    c&amp;  d
\end{array}
\right)
\left(
\begin{array}{cc}
    \cos\phi_s&amp;\sin\phi_s\\
    \sin\phi_s&amp;-\cos\phi_s
\end{array}
\right)~~~.
\label{eq:fml_rel_S_v4}\]</span> This provides the 4 equations used in
subroutine <span><code>GETMUELLER</code></span> to compute the
scattering amplitude matrix elements: <span
class="math display">\[\begin{aligned}
S_1 &amp;=&amp; -i\left[
    f_{21}(b\cos\phi_s-a\sin\phi_s)
    +f_{22}(d\cos\phi_s-c\sin\phi_s)
    \right]~~~,\label{eq:S_1_relto_f21andf22}\\
S_2 &amp;=&amp; -i\left[
    f_{11}(a\cos\phi_s+b\sin\phi_s)
    +f_{12}(c\cos\phi_s+d\sin\phi_s)
    \right]~~~,\\
S_3 &amp;=&amp; i\left[
    f_{11}(b\cos\phi_s-a\sin\phi_s)
    +f_{12}(d\cos\phi_s-c\sin\phi_s)
    \right]~~~,\\
S_4 &amp;=&amp; i\left[
    f_{21}(a\cos\phi_s+b\sin\phi_s)
    +f_{22}(c\cos\phi_s+d\sin\phi_s)
    \right] ~~~.
\end{aligned}\]</span></p>
<h2 id="stokes-parameters"><span id="sec:Stokes"
label="sec:Stokes"></span> Stokes Parameters</h2>
<p>It is both convenient and customary to characterize both incident and
scattered radiation by 4 “Stokes parameters” – the elements of the
“Stokes vector”. There are different conventions in the literature; we
adhere to the definitions of the Stokes vector (<span
class="math inline">\(I\)</span>,<span
class="math inline">\(Q\)</span>,<span
class="math inline">\(U\)</span>,<span class="math inline">\(V\)</span>)
adopted in the excellent treatise by <span class="citation"
data-cites="Bohren+Huffman_1983"></span>, to which the reader is
referred for further detail. Here are some examples of Stokes vectors
<span class="math inline">\((I,Q,U,V)=(1,Q/I,U/I,V/I)I\)</span>:</p>
<ul>
<li><p><span class="math inline">\((1,0,0,0)I\)</span> : unpolarized
light (with intensity <span class="math inline">\(I\)</span>);</p></li>
<li><p><span class="math inline">\((1,1,0,0)I\)</span> : 100% linearly
polarized with <span class="math inline">\({\bf E}\)</span> parallel to
the scattering plane;</p></li>
<li><p><span class="math inline">\((1,-1,0,0)I\)</span> : 100% linearly
polarized with <span class="math inline">\({\bf E}\)</span>
perpendicular to the scattering plane;</p></li>
<li><p><span class="math inline">\((1,0,1,0)I\)</span> : 100% linearly
polarized with <span class="math inline">\({\bf E}\)</span> at +45<span
class="math inline">\(^\circ\)</span> relative to the scattering
plane;</p></li>
<li><p><span class="math inline">\((1,0,-1,0)I\)</span> : 100% linearly
polarized with <span class="math inline">\({\bf E}\)</span> at -45<span
class="math inline">\(^\circ\)</span> relative to the scattering
plane;</p></li>
<li><p><span class="math inline">\((1,0,0,1)I\)</span> : 100% right
circular polarization (<span><em>i.e.,</em></span> negative
helicity);</p></li>
<li><p><span class="math inline">\((1,0,0,-1)I\)</span> : 100% left
circular polarization (<span><em>i.e.,</em></span> positive
helicity).</p></li>
</ul>
<h2
id="relation-between-stokes-parameters-of-incident-and-scattered-radiation-the-mueller-matrix">Relation
Between Stokes Parameters of Incident and Scattered Radiation: The
Mueller Matrix</h2>
<p>It is convenient to describe the scattering properties of a finite
target in terms of the <span class="math inline">\(4\times4\)</span>
Mueller matrix <span class="math inline">\(S_{ij}\)</span> relating the
Stokes parameters <span class="math inline">\((I_i,Q_i,U_i,V_i)\)</span>
and <span class="math inline">\((I_s,Q_s,U_s,V_s)\)</span> of the
incident and scattered radiation: <span class="math display">\[\left(
\begin{array}{c}
    I_s\\
    Q_s\\
    U_s\\
    V_s
\end{array}
\right)
=
{1\over k^2r^2}
\left(
\begin{array}{cccc}
    S_{11}&amp;S_{12}&amp;S_{13}&amp;S_{14}\\
    S_{21}&amp;S_{22}&amp;S_{23}&amp;S_{24}\\
    S_{31}&amp;S_{32}&amp;S_{33}&amp;S_{34}\\
    S_{41}&amp;S_{42}&amp;S_{43}&amp;S_{44}
\end{array}
\right)
\left(
\begin{array}{c}
    I_i\\
    Q_i\\
    U_i\\
    V_i
\end{array}
\right)~~~.\]</span> Once the amplitude scattering matrix elements are
obtained, the Mueller matrix elements can be computed <span
class="citation" data-cites="Bohren+Huffman_1983"></span>: <span
class="math display">\[\begin{aligned}
S_{11}&amp;=&amp;\left(|S_1|^2+|S_2|^2+|S_3|^2+|S_4|^2\right)/2~~~,\nonumber\\
S_{12}&amp;=&amp;\left(|S_2|^2-|S_1|^2+|S_4|^2-|S_3|^2\right)/2~~~,\nonumber\\
S_{13}&amp;=&amp;{\rm Re}\left(S_2S_3^*+S_1S_4^*\right)~~~,\nonumber\\
S_{14}&amp;=&amp;{\rm Im}\left(S_2S_3^*-S_1S_4^*\right)~~~,\nonumber\\
S_{21}&amp;=&amp;\left(|S_2|^2-|S_1|^2+|S_3|^2-|S_4|^2\right)/2~~~,\nonumber\\
S_{22}&amp;=&amp;\left(|S_1|^2+|S_2|^2-|S_3|^2-|S_4|^2\right)/2~~~,\nonumber\\
S_{23}&amp;=&amp;{\rm Re}\left(S_2S_3^*-S_1S_4^*\right)~~~,\nonumber\\
S_{24}&amp;=&amp;{\rm Im}\left(S_2S_3^*+S_1S_4^*\right)~~~,\nonumber\\
S_{31}&amp;=&amp;{\rm Re}\left(S_2S_4^*+S_1S_3^*\right)~~~,\nonumber\\
S_{32}&amp;=&amp;{\rm Re}\left(S_2S_4^*-S_1S_3^*\right)~~~,\nonumber\\
S_{33}&amp;=&amp;{\rm Re}\left(S_1S_2^*+S_3S_4^*\right)~~~,\nonumber\\
S_{34}&amp;=&amp;{\rm Im}\left(S_2S_1^*+S_4S_3^*\right)~~~,\nonumber\\
S_{41}&amp;=&amp;{\rm Im}\left(S_4S_2^*+S_1S_3^*\right)~~~,\nonumber\\
S_{42}&amp;=&amp;{\rm Im}\left(S_4S_2^*-S_1S_3^*\right)~~~,\nonumber\\
S_{43}&amp;=&amp;{\rm Im}\left(S_1S_2^*-S_3S_4^*\right)~~~,\nonumber\\
S_{44}&amp;=&amp;{\rm Re}\left(S_1S_2^*-S_3S_4^*\right)~~~.
\end{aligned}\]</span> These matrix elements are computed in
<span><code>DDSCAT</code></span> and passed to subroutine
<span><code>WRITESCA</code></span> which handles output of scattering
properties. Although the Muller matrix has 16 elements, only 9 are
independent.</p>
<p>The user can select up to 9 distinct Muller matrix elements to be
printed out in the output files
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.sca</code></span>
and
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>ori.avg</code></span>;
this choice is made by providing a list of indices in
<span><code>ddscat.par</code></span> (see Appendix <a
href="#app:ddscat.par" data-reference-type="ref"
data-reference="app:ddscat.par">[app:ddscat.par]</a>).</p>
<p>If the user does not provide a list of elements,
<span><code>WRITESCA</code></span> will provide a “default” set of 6
selected elements: <span class="math inline">\(S_{11}\)</span>, <span
class="math inline">\(S_{21}\)</span>, <span
class="math inline">\(S_{31}\)</span>, <span
class="math inline">\(S_{41}\)</span> (these 4 elements describe the
intensity and polarization state for scattering of unpolarized incident
radiation), <span class="math inline">\(S_{12}\)</span>, and <span
class="math inline">\(S_{13}\)</span>.</p>
<p>In addition, <span><code>WRITESCA</code></span> writes out the linear
polarization <span class="math inline">\(P\)</span> of the scattered
light for incident unpolarized light <span class="citation"
data-cites="Bohren+Huffman_1983"></span>: <span class="math display">\[P
= \frac{(S_{21}^2+S_{31}^2)^{1/2}}{S_{11}} ~~~.\]</span></p>
<h2 id="polarization-properties-of-the-scattered-radiation">Polarization
Properties of the Scattered Radiation</h2>
<p>The scattered radiation is fully characterized by its Stokes vector
<span class="math inline">\((I_s,Q_s,U_s,V_s)\)</span>. As discussed in
<span class="citation" data-cites="Bohren+Huffman_1983"></span> (eq.
2.87), one can determine the linear polarization of the Stokes vector by
operating on it by the Mueller matrix of an ideal linear polarizer:
<span class="math display">\[{\bf S}_{\rm pol} = \frac{1}{2}
\left(\begin{array}{cccc}
  1&amp;\cos2\xi&amp;\sin2\xi&amp;0\\
  \cos2\xi&amp;\cos^22\xi&amp;\cos2\xi\sin2\xi&amp;0\\
  \sin2\xi&amp;\sin2\xi\cos2\xi&amp;\sin^22\xi&amp;0\\
  0&amp;0&amp;0&amp;0\\
\end{array}\right)\]</span> where <span
class="math inline">\(\xi\)</span> is the angle between the unit vector
<span class="math inline">\(\hat{\theta}_s\)</span> parallel to the
scattering plane (“SP”) and the “transmission” axis of the linear
polarizer. Therefore the intensity of light polarized parallel to the
scattering plane is obtained by taking <span
class="math inline">\(\xi=0\)</span> and operating on <span
class="math inline">\((I_s,Q_s,U_s,V_s)\)</span> to obtain <span
class="math display">\[\begin{aligned}
I({\bf E}_s\parallel {\rm SP})&amp;=&amp;\frac{1}{2}(I_s + Q_s)\\
&amp;=&amp;\frac{1}{2k^2r^2}
\left[
(S_{11}+S_{21})I_i +
(S_{12}+S_{22})Q_i +
(S_{13}+S_{23})U_i +
(S_{14}+S_{24})V_i
\right]~.~~~~~
\end{aligned}\]</span> Similarly, the intensity of light polarized
perpendicular to the scattering plane is obtained by taking <span
class="math inline">\(\xi=\pi/2\)</span>: <span
class="math display">\[\begin{aligned}
I({\bf E}_s\perp {\rm SP}) &amp;=&amp; \frac{1}{2}(I_s - Q_s)\\
&amp;=&amp; \frac{1}{2k^2r^2}
\left[
(S_{11}-S_{21})I_i +
(S_{12}-S_{22})Q_i +
(S_{13}-S_{23})U_i +
(S_{14}-S_{24})V_i
\right]~.~~~~~
\end{aligned}\]</span></p>
<h2
id="relation-between-mueller-matrix-and-scattering-cross-sections">Relation
Between Mueller Matrix and Scattering Cross Sections</h2>
<p>Differential scattering cross sections can be obtained directly from
the Mueller matrix elements by noting that <span
class="math display">\[I_s = \frac{1}{r^2} \left(\frac{dC_{\rm
sca}}{d\Omega}\right)_{s,i} I_i
~~~.\]</span> Let SP be the “scattering plane”: the plane containing the
incident and scattered directions of propagation. Here we consider some
special cases:</p>
<ul>
<li><p>Incident light unpolarized: Stokes vector <span
class="math inline">\(s_i=I(1,0,0,0)\)</span>:</p>
<ul>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\parallel\)</span> SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} =
      \frac{1}{2k^2}\left( |S_2|^2 + |S_3|^2 \right)
      =
      \frac{1}{2k^2}\left( S_{11}+S_{21}\right)\]</span></p></li>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\perp\)</span> SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} =
      \frac{1}{2k^2}\left( |S_1|^2 + |S_4|^2 \right)
      =
      \frac{1}{2k^2}\left( S_{11}-S_{21}\right)\]</span></p></li>
<li><p>total intensity of scattered light: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} =
      \frac{1}{2k^2}\left( |S_1|^2 + |S_2|^2 + |S_3|^2 + |S_4|^2 \right)
      =
      \frac{1}{k^2} S_{11}\]</span></p></li>
</ul></li>
<li><p>Incident light polarized with <span class="math inline">\({\bf
E}_i\parallel\)</span> SP: Stokes vector <span
class="math inline">\(s_i=I(1,1,0,0)\)</span>:</p>
<ul>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\parallel\)</span> to SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{k^2}
|S_2|^2 =
      \frac{1}{2k^2}\left(S_{11}+S_{12}+S_{21}+S_{22}\right)\]</span></p></li>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\perp\)</span> to SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{k^2}
|S_4|^2 =
      \frac{1}{2k^2}\left(S_{11}+S_{12}-S_{21}-S_{22}\right)\]</span></p></li>
<li><p>total scattering cross section: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{k^2}
\left(|S_2|^2+|S_4|^2\right) =
      \frac{1}{k^2} \left(S_{11}+S_{12}\right)\]</span></p></li>
</ul></li>
<li><p>Incident light polarized with <span class="math inline">\({\bf
E}_i\perp\)</span> SP: Stokes vector <span
class="math inline">\(s_i=I(1,-1,0,0)\)</span>:</p>
<ul>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\parallel\)</span> to SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{k^2}
|S_3|^2 =
      \frac{1}{2k^2}\left(S_{11}-S_{12}+S_{21}-S_{22}\right)\]</span></p></li>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\perp\)</span> SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{k^2}
|S_1|^2 =
      \frac{1}{2k^2}\left(S_{11}-S_{12}-S_{21}+S_{22}\right)\]</span></p></li>
<li><p>total scattering cross section: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{k^2}
\left(|S_1|^2+|S_3|^2\right) =
      \frac{1}{k^2}\left(S_{11}-S_{12}\right)\]</span></p></li>
</ul></li>
<li><p>Incident light linearly polarized at angle <span
class="math inline">\(\gamma\)</span> to SP: Stokes vector <span
class="math inline">\(s_i = I(1,\cos2\gamma,\sin2\gamma,0)\)</span>:</p>
<ul>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\parallel\)</span> to SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} =
\frac{1}{2k^2}\left[
    (S_{11}+S_{21}) +
    (S_{12}+S_{22})\cos2\gamma +
    (S_{13}+S_{23})\sin2\gamma\right]\]</span></p></li>
<li><p>cross section for scattering with polarization <span
class="math inline">\({\bf E}_s\perp\)</span> SP: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} = \frac{1}{2k^2}
        \left[
    (S_{11}-S_{21}) +
    (S_{12}-S_{22})\cos2\gamma +
    (S_{13}-S_{23})\sin2\gamma
    \right]\]</span></p></li>
<li><p>total scattering cross section: <span
class="math display">\[\frac{dC_{\rm sca}}{d\Omega} =
\frac{1}{k^2}\left[
      S_{11} + S_{12}\cos2\gamma +
S_{13}\sin2\gamma\right]\]</span></p></li>
</ul></li>
</ul>
<h2 id="one-incident-polarization-state-only-iorth1">One Incident
Polarization State Only (<span><code>IORTH=1</code></span>)</h2>
<p>In some cases it may be desirable to limit the calculations to a
single incident polarization state – for example, when each solution is
very time-consuming, and the target is known to have some symmetry so
that solving for a single incident polarization state may be sufficient
for the required purpose. In this case, set
<span><code>IORTH=1</code></span> in
<span><code>ddscat.par</code></span>.</p>
<p>When <span><code>IORTH=1</code></span>, only <span
class="math inline">\(f_{11}\)</span> and <span
class="math inline">\(f_{21}\)</span> are available; hence,
<span><strong>DDSCAT</strong></span> cannot automatically generate the
Mueller matrix elements. In this case, the output routine
<span><code>WRITESCA</code></span> writes out the quantities <span
class="math inline">\(|f_{11}|^2\)</span>, <span
class="math inline">\(|f_{21}|^2\)</span>, <span
class="math inline">\({\rm Re}(f_{11}f_{21}^*)\)</span>, and <span
class="math inline">\({\rm Im}(f_{11}f_{21}^*)\)</span> for each of the
scattering directions.</p>
<p>The differential scattering cross section for scattering with
polarization <span class="math inline">\({\bf E}_s \parallel\)</span>
and <span class="math inline">\(\perp\)</span> to the scattering plane
are <span class="math display">\[\begin{aligned}
\left(\frac{dC_{\rm sca}}{d\Omega}\right)_{s,\parallel} &amp;=&amp;
\frac{1}{k^2}|f_{11}|^2
\\
\left(\frac{dC_{\rm sca}}{d\Omega}\right)_{s,\perp} &amp;=&amp;
\frac{1}{k^2}|f_{21}|^2
\end{aligned}\]</span></p>
<p>Note, however, that if <span><code>IPHI</code></span> is greater than
1, <span><strong>DDSCAT</strong></span> will automatically set
<span><code>IORTH=2</code></span> even if
<span><code>ddscat.par</code></span> specified
<span><code>IORTH=1</code></span>: this is because when more than one
value of the target orientation angle <span
class="math inline">\(\Phi\)</span> is required, there is no additional
“cost” to solve the scattering problem for the second incident
polarization state, since when solutions are available for two
orthogonal states for some particular target orientation, the solution
may be obtained for another target orientation differing only in the
value of <span class="math inline">\(\Phi\)</span> by appropriate linear
combinations of these solutions. Hence we may as well solve the
“complete” scattering problem so that we can compute the complete
Mueller matrix.</p>
<h1
id="scattering-by-periodic-targets-generalized-mueller-matrix">Scattering
by Periodic Targets: Generalized Mueller Matrix <span
id="sec:generalized mueller matrix"
label="sec:generalized mueller matrix"></span></h1>
<p>The Mueller scattering matrix <span
class="math inline">\(S_{ij}(\theta)\)</span> described above was
originally defined <span class="citation"
data-cites="Bohren+Huffman_1983"></span> to describe scattering of
incident plane waves by finite targets, such as aerosol particles or
dust grains.</p>
<p><span class="citation" data-cites="Draine+Flatau_2008a"></span> have
extended the Mueller scattering matrix formalism to also apply to
targets that are periodic and infinite in one or two dimensions (e.g.,
an infinite chain of particles, or a two-dimensional array of
particles).</p>
<h2
id="mueller-matrix-s_ij1d-for-targets-periodic-in-one-direction">Mueller
Matrix <span class="math inline">\(S_{ij}^{(1d)}\)</span> for Targets
Periodic in One Direction</h2>
<p>The dimensionless <span class="math inline">\(4\times4\)</span>
matrix <span class="math inline">\(S_{ij}^{(1d)}(M,\zeta)\)</span>
describes the scattering properties of targets that are periodic in one
dimension. In the radiation zone, for incident Stokes vector <span
class="math inline">\(I_{\rm in}\)</span>, the scattered Stokes vector
in direction <span class="math inline">\((M,\zeta)\)</span> (see §<a
href="#sec:scattering_directions:1d" data-reference-type="ref"
data-reference="sec:scattering_directions:1d">[sec:scattering_directions:1d]</a>)
is <span class="citation" data-cites="Draine+Flatau_2008a"></span> <span
class="math display">\[I_{{\rm sca},i}(M,\zeta) =
\frac{1}{k_0R}\sum_{j=1}^4 S_{ij}^{(1d)}(M,\zeta) \, I_{{\rm in},j}
~~~,~~~\]</span> where <span class="math inline">\(R\)</span> is the
distance from the target repetition axis.</p>
<p><span><strong>DDSCAT 7.3</strong></span> reports the scattering
matrix elements <span class="math inline">\(S_{ij}^{(nd)}\)</span> in
the output files
<span><code>w</code></span><span><em>aaa</em></span><span><code>r</code></span><span><em>bbb</em></span><span><code>k</code></span><span><em>ccc</em></span><span><code>.sca</code></span>.</p>
<h2
id="mueller-matrix-s_ij2dmn-for-targets-periodic-in-two-directions"><span
id="subsec:S^{(2d)}" label="subsec:S^{(2d)}"></span> Mueller Matrix
<span class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> for Targets
Periodic in Two Directions</h2>
<p>For targets that are periodic in two directions, the scattering
intensities are described by the dimensionless <span
class="math inline">\(4\times4\)</span> matrix <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span>. In the radiation
zone, for incident Stokes vector <span class="math inline">\(I_{{\rm
in}}\)</span>, the scattered Stokes vector in scattering order <span
class="math inline">\((M,N)\)</span> is <span class="citation"
data-cites="Draine+Flatau_2008a"></span> <span
class="math display">\[I_{{\rm sca},i}(M,N) =
\sum_{j=1}^4 S_{ij}^{(2d)}(M,N) \, I_{{\rm in},j}
~~~,~~~\]</span> where integers <span
class="math inline">\((M,N)\)</span> define the scattering order (see
§<a href="#sec:scattering_directions:2d" data-reference-type="ref"
data-reference="sec:scattering_directions:2d">[sec:scattering_directions:2d]</a>).
For given <span class="math inline">\((M,N)\)</span> there are actually
two possible scattering directions – corresponding to transmission and
reflection (see §<a href="#sec:scattering_directions:2d"
data-reference-type="ref"
data-reference="sec:scattering_directions:2d">[sec:scattering_directions:2d]</a>),
and for each there is a value of <span
class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span>, which we will denote
<span class="math inline">\(S_{ij}^{(2d)}(M,N,{\rm tran})\)</span> and
<span class="math inline">\(S_{ij}^{(2d)}(M,N,{\rm refl})\)</span>.</p>
<p>For targets with 2-d periodicity, the scattering matrix elements
<span class="math inline">\(S_{ij}^{(2d)}(M,N)\)</span> are directly
related to the usual transmission coefficient and reflection coefficient
<span class="citation" data-cites="Draine+Flatau_2008a"></span>. For
unpolarized incident radiation, the reflection coefficient <span
class="math inline">\(R\)</span>, transmission coefficient <span
class="math inline">\(T\)</span>, and absorption coefficient <span
class="math inline">\(A\)</span> are just <span
class="math display">\[\begin{aligned}
T &amp;=&amp; \sum_{M,N} S_{11}^{(2d)}(M,N,{\rm tran})
\\
R &amp;=&amp; \sum_{M,N} S_{11}^{(2d)}(M,N,{\rm refl})
\\
A &amp;=&amp; 1 - T - R
~~~.
\end{aligned}\]</span></p>
<h1 id="composite-targets-with-anisotropic-constituents">Composite
Targets with Anisotropic Constituents <span
id="sec:composite anisotropic targets"
label="sec:composite anisotropic targets"></span></h1>
<p>Section <a href="#sec:target_generation" data-reference-type="ref"
data-reference="sec:target_generation">[sec:target_generation]</a>
includes targets composed of anisotropic materials (ANIELLIPS,
ANIRCTNGL, ANI_ELL_2, ANI_ELL_3). However, in each of these cases it is
assumed that the dielectric tensor of the target material is diagonal in
the “Target Frame”. For targets consisting of a single material (in a
single domain), it is obviously possible to choose the “Target Frame” to
coincide with a frame in which the dielectric tensor is diagonal.</p>
<p>However, for inhomogeneous targets containing anisotropic materials
as, e.g., inclusions, the optical axes of the constituent material may
be oriented differently in different parts of the target. In this case,
it is obviously not possible to choose a single reference frame such
that the dielectric tensor is diagonalized for all of the target
material.</p>
<p>To extend DDSCAT to cover this case, we must allow for off-diagonal
elements of the dielectric tensor, and therefore of the dipole
polarizabilities. It will be assumed that the dielectric tensor <span
class="math inline">\(\epsilon\)</span> is symmetric (this excludes
magnetooptical materials – check this).</p>
<p>Let the material at a given location in the grain have a dielectric
tensor with complex eigenvalues <span
class="math inline">\(\epsilon^{(j)}\)</span>, <span
class="math inline">\(j=1-3\)</span>. These are the diagonal elements of
the dielectric tensor in a frame where it is diagonalized (i.e., the
frame coinciding with the principal axes of the dielectric tensor). Let
this frame in which the dielectric tensor is diagonalized have unit
vectors <span class="math inline">\(\hat{\bf e}_j\)</span> corresponding
to the principal axes of the dielectric tensor. We need to describe the
orientation of the “Dielectric Frame” (DF) – defined by the “dielectric
axes” <span class="math inline">\(\hat{\bf e}_j\)</span> – relative to
the Target Frame. It is convenient to do so with rotation angles
analogous to the rotation angles <span
class="math inline">\(\Theta\)</span>, <span
class="math inline">\(\Phi\)</span>, and <span
class="math inline">\(\beta\)</span> used to describe the orientation of
the Target Frame in the Lab Frame: Suppose that we start with unit
vectors <span class="math inline">\(\hat{\bf e}_j\)</span> aligned with
the target frame <span class="math inline">\(\hat{\bf x}_j\)</span>.</p>
<ol>
<li><p>Rotate the DF through an angle <span
class="math inline">\(\theta_{\rm DF}\)</span> around axis <span
class="math inline">\(\hat{\bf y}_{\rm TF}\)</span>, so that <span
class="math inline">\(\theta_{\rm DF}\)</span> is now the angle between
<span class="math inline">\(\hat{\bf e}_1\)</span> and <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>.</p></li>
<li><p>Now rotate the DF through an angle <span
class="math inline">\(\phi_{\rm DF}\)</span> around axis <span
class="math inline">\(\hat{\bf x}_{\rm TF}\)</span>, in such a way that
<span class="math inline">\(\hat{\bf e}_2\)</span> remains in the <span
class="math inline">\(\hat{\bf x}_{\rm TF}-\hat{\bf e}_1\)</span>
plane.</p></li>
<li><p>Finally, rotate the DF through an angle <span
class="math inline">\(\beta_{\rm DF}\)</span> around axis <span
class="math inline">\(\hat{\bf e}_1\)</span>.</p></li>
</ol>
<p>The unit vectors <span class="math inline">\(\hat{\bf e}_i\)</span>
are related to the TF basis vectors <span class="math inline">\(\hat{\bf
x}_{\rm TF}\)</span>, <span class="math inline">\(\hat{\bf y}_{\rm
TF}\)</span>, <span class="math inline">\(\hat{\bf z}_{\rm TF}\)</span>
by: <span class="math display">\[\begin{aligned}
{\hat{\bf e}}_1 &amp;=&amp;   \hat{\bf x}_{\rm TF}\cos\theta_{\rm DF}
+ \hat{\bf y}_{\rm TF}\sin\theta_{\rm DF}\cos\phi_{\rm DF}
+ \hat{\bf z}_{\rm TF}\sin\theta_{\rm DF}\sin\phi_{\rm DF}
    \\
{\hat{\bf e}}_2 &amp;=&amp; - \hat{\bf x}_{\rm TF}\sin\theta_{\rm
DF}\cos\beta_{\rm DF}
+ \hat{\bf y}_{\rm TF}[\cos\theta_{\rm DF}\cos\beta_{\rm
DF}\cos\phi_{\rm DF}-
\sin\beta_{\rm DF}\sin\phi_{\rm DF}] \nonumber\\
&amp;&amp;+ \hat{\bf z}_{\rm TF}[\cos\theta_{\rm DF}\cos\beta_{\rm
DF}\sin\phi_{\rm DF}+
\sin\beta_{\rm DF}\cos\phi_{\rm DF}]
    \\
{\hat{\bf e}}_3 &amp;=&amp;   \hat{\bf x}_{\rm TF}\sin\theta_{\rm
DF}\sin\beta_{\rm DF}
- \hat{\bf y}_{\rm TF}[\cos\theta_{\rm DF}\sin\beta_{\rm
DF}\cos\phi_{\rm DF}+
\cos\beta_{\rm DF}\sin\phi_{\rm DF}] \nonumber\\
  &amp;&amp;         - \hat{\bf z}_{\rm TF}[\cos\theta_{\rm
DF}\sin\beta_{\rm DF}
\sin\phi_{\rm DF}-\cos\beta_{\rm DF}\cos\phi_{\rm DF}]
\end{aligned}\]</span> or, equivalently: <span
class="math display">\[\begin{aligned}
\hat{\bf x}_{\rm TF}&amp;=&amp;   {\hat{\bf e}}_1 \cos\theta_{\rm DF}
           - {\hat{\bf e}}_2 \sin\theta_{\rm DF}\cos\beta_{\rm DF}
           + {\hat{\bf e}}_3 \sin\theta_{\rm DF}\sin\beta_{\rm DF}\\
\hat{\bf y}_{\rm TF}&amp;=&amp;   {\hat{\bf e}}_1 \sin\theta_{\rm
DF}\cos\phi_{\rm DF}
           + {\hat{\bf e}}_2 [\cos\theta_{\rm DF}\cos\beta_{\rm
DF}\cos\phi_{\rm DF}-\sin\beta_{\rm DF}\sin\phi_{\rm DF}]
\nonumber\\
&amp;&amp;           - {\hat{\bf e}}_3 [\cos\theta_{\rm
DF}\sin\beta_{\rm DF}\cos\phi_{\rm DF}+\cos\beta_{\rm DF}\sin\phi_{\rm
DF}]
\\
\hat{\bf z}_{\rm TF}&amp;=&amp;   {\hat{\bf e}}_1 \sin\theta_{\rm
DF}\sin\phi_{\rm DF}
           + {\hat{\bf e}}_2 [\cos\theta_{\rm DF}\cos\beta_{\rm
DF}\sin\phi_{\rm DF}+\sin\beta_{\rm DF}\cos\phi_{\rm DF}]
\nonumber\\
&amp;&amp;           - {\hat{\bf e}}_3 [\cos\theta_{\rm
DF}\sin\beta_{\rm DF}\sin\phi_{\rm DF}-\cos\beta_{\rm DF}\cos\phi_{\rm
DF}]
\end{aligned}\]</span> Define the rotation matrix <span
class="math inline">\(R_{ij}\equiv \hat{\bf x}_i\cdot\hat{\bf
e}_j\)</span>: <span> <span class="math display">\[R_{ij}=\]</span>
<span class="math display">\[\left(
\begin{array}{ccc}
\cos\theta_{\rm DF}&amp;
\sin\theta_{\rm DF}\cos\phi_{\rm DF}&amp;
\sin\theta_{\rm DF}\sin\phi_{\rm DF}\\
\!\!\!\!\!\!-\!\sin\theta_{\rm DF}\cos\beta_{\rm DF}\! &amp;
\cos\theta_{\rm DF}\cos\beta_{\rm DF}\cos\phi_{\rm DF}\!-\!
\sin\beta_{\rm DF}\sin\phi_{\rm DF}&amp;
\cos\theta_{\rm DF}\cos\beta_{\rm DF}\sin\phi_{\rm DF}\!+\!
\sin\beta_{\rm DF}\cos\phi_{\rm DF}\!\!\!\!
\\
\sin\theta_{\rm DF}\sin\beta_{\rm DF}&amp;
\!\!\!-\!\cos\theta_{\rm DF}\sin\beta_{\rm DF}\cos\phi_{\rm DF}\!-\!
\cos\beta_{\rm DF}\sin\phi_{\rm DF}\!\! &amp;
\!-\!\!\cos\theta_{\rm DF}\sin\beta_{\rm DF}\sin\phi_{\rm DF}\!+\!
\cos\beta_{\rm DF}\cos\phi_{\rm DF}\!\!\!\!\!
\end{array}
\right)\]</span> and its inverse <span
class="math display">\[(R^{-1})_{ij} =\]</span> <span
class="math display">\[\left(
\begin{array}{ccc}
\cos\theta_{\rm DF}&amp;
-\sin\theta_{\rm DF}\cos\beta_{\rm DF}&amp;
\sin\theta_{\rm DF}\sin\beta_{\rm DF}
\\
\!\!\!\sin\theta_{\rm DF}\cos\phi_{\rm DF}\!\! &amp;
\!\!\cos\theta_{\rm DF}\cos\beta_{\rm DF}\cos\phi_{\rm DF}\!-\!
\sin\beta_{\rm DF}\sin\phi_{\rm DF}&amp;
-\cos\theta_{\rm DF}\sin\beta_{\rm DF}\cos\phi_{\rm DF}\!-\!
\cos\beta_{\rm DF}\sin\phi_{\rm DF}\!\!\!\!
\\
\!\!\!\sin\theta_{\rm DF}\sin\phi_{\rm DF}&amp;
\!\!\cos\theta_{\rm DF}\cos\beta_{\rm DF}\sin\phi_{\rm DF}\!+\!
\sin\beta_{\rm DF}\cos\phi_{\rm DF}\!\! &amp;
-\cos\theta_{\rm DF}\sin\beta_{\rm DF}\sin\phi_{\rm DF}\!+\!
\cos\beta_{\rm DF}\cos\phi_{\rm DF}\!\!\!\!
\end{array}
\right)\]</span> </span> The dielectric tensor <span
class="math inline">\({\boldsymbol{\alpha}}\)</span> is diagonal in the
DF. If we calculate the dipole polarizabilility tensor in the DF it will
also be diagonal, with elements <span
class="math display">\[{\boldsymbol{\alpha}}^{\rm DF}=
\left(
\begin{array}{ccc}
\alpha_{11}^{\rm DF}&amp; 0 &amp; 0 \\
0 &amp; \alpha_{22}^{\rm DF}&amp; 0 \\
0 &amp; 0 &amp; \alpha_{33}^{\rm DF}
\end{array}
\right)\]</span> The polarizability tensor in the TF is given by <span
class="math display">\[\label{eq:alpha^TF from alpha^DF}
(\alpha^{\rm TF})_{im} =
R_{ij} (\alpha^{\rm DF})_{jk} (R^{-1})_{km}\]</span></p>
<p>Thus, we can describe a general anisotropic material if we provide,
for each lattice site, the three diagonal elements <span
class="math inline">\(\epsilon_{jj}^{\rm DF}\)</span> of the dielectric
tensor in the DF, and the three rotation angles <span
class="math inline">\(\theta_{\rm DF}\)</span>, <span
class="math inline">\(\beta_{\rm DF}\)</span>, and <span
class="math inline">\(\phi_{\rm DF}\)</span>. We first use the LDR
prescription and the elements to obtain the three diagonal elements
<span class="math inline">\(\alpha_{jj}^{\rm DF}\)</span> of the
polarizability tensor in the DF. We then calculate the polarizability
tensor <span class="math inline">\(\alpha^{\rm TF}\)</span> using
eq. (<a href="#eq:alpha^TF from alpha^DF" data-reference-type="ref"
data-reference="eq:alpha^TF from alpha^DF">[eq:alpha^TF from
alpha^DF]</a>).</p>
<h1
id="near-field-calculations-bf-e-and-bf-b-within-or-near-the-target">Near-Field
Calculations: <span class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> Within or Near the Target <span
id="sec:nearfield" label="sec:nearfield"></span> <span
id="sec:micro_vs_macro" label="sec:micro_vs_macro"></span> </h1>
<p><span><strong>DDSCAT 7.3</strong></span> includes options for
calculating the electric field <span class="math inline">\({\bf
E}\)</span> and magnetic field <span class="math inline">\({\bf
B}\)</span> within or near the target.</p>
<ul>
<li><p><span><code>NRFLD</code></span>=0 : no near-field
calculations.</p></li>
<li><p><span><code>NRFLD</code></span>=1 : calculate <span
class="math inline">\({\bf E}\)</span> in and near the target.</p></li>
<li><p><span><code>NRFLD</code></span>=2 : calculate both <span
class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> in and near the target.</p></li>
</ul>
<p>The near-field calculation of <span class="math inline">\({\bf
E}\)</span> by <span><strong>DDSCAT 7.3</strong></span> returns the
<span><em>macroscopic</em></span> electric field <span
class="math inline">\({\bf E}_{\rm macro}\)</span>, as opposed to the
microscopic electric field <span class="math inline">\({\bf E}_{\rm
micro}\)</span>. The distinction between <span
class="math inline">\({\bf E}_{\rm micro}\)</span> and <span
class="math inline">\({\bf E}_{\rm macro}\)</span> is discussed in
textbooks on electromagnetism <span class="citation"
data-cites="Jackson_1975"></span>.</p>
<p>In brief, <span class="math inline">\({\bf E}_{\rm micro}\)</span> is
the electric field seen by an "atom" in a solid, or a "point dipole" in
the DDA. This includes the contributions to the electric field by nearby
atoms in the solid, or nearby point dipoles in the DDA. The polarization
of the material is <span class="math inline">\({\bf P}=n\alpha{\bf
E}_{\rm micro}\)</span>, where <span
class="math inline">\(\alpha\)</span> is the molecular polarizability,
and <span class="math inline">\(n\)</span> is the atomic density of
molecules.</p>
<p>The macroscopic field is the field such that <span
class="math inline">\({\bf D} = \epsilon {\bf E}_{\rm macro}\)</span>.
Since <span class="math inline">\({\bf D}={\bf E}_{\rm macro} + 4\pi{\bf
P}\)</span>, this implies <span class="math inline">\({\bf
P}=(1/4\pi)(\epsilon-1){\bf E}_{\rm macro}\)</span>.</p>
<p>The Clausium-Mossotti relation gives <span
class="math display">\[\frac{4\pi n\alpha}{3} =
\frac{\epsilon-1}{\epsilon+2}
~~~.\]</span> Thus <span
class="math display">\[\label{eq:macro_vs_micro}
{\bf E}_{\rm macro} = \left(\frac{3}{\epsilon+2}\right) {\bf E}_{\rm
micro} ~~~.\]</span> In vacuum, <span class="math inline">\({\bf E}_{\rm
macro}={\bf E}_{\rm micro}\)</span>.</p>
<p>Because <span><strong>DDSCAT 7.3</strong></span> is for nonmagnetic
materials (i.e., magnetic permeability <span class="math inline">\(\mu =
1\)</span>), the macroscopic and microscopic magnetic fields are the
same: <span class="math inline">\({\bf B}={\bf B}_{\rm macro}={\bf
B}_{\rm micro}\)</span>.</p>
<h2 id="running-ddscat-7.3-with-nrfld-1">Running <span><strong>DDSCAT
7.3</strong></span> with NRFLD = 1</h2>
<p>For some scientific applications (e.g., surface-enhanced Raman
scattering) one wishes to calculate the electric field <span
class="math inline">\({\bf E}\)</span> near the the target surface. It
may also be of interest to calculate the electromagnetic field at
positions within the target volume. <span><strong>DDSCAT
7.3</strong></span> includes the capability for fast calculations of
<span class="math inline">\({\bf E}\)</span> in and near the target,
using methods described by <span class="citation"
data-cites="Flatau+Draine_2012"></span>.</p>
<p>When <span><strong>DDSCAT</strong></span> is run with
<span><code>NRFLD</code></span>=1,
<span><strong>DDSCAT</strong></span> will be run twice. The first run,
using a “minimal” computational volume just enclosing the physical
target (or target unit cell when used for periodic targets), creates
stored files<br />
<br />
for <span><em>n</em></span>=1 and (if <span><code>IORTH=2</code></span>)
<span><em>n</em></span>=2. These files contain the stored solution for
the polarization field <span class="math inline">\({\bf P}_j\)</span>
for lattice points within the minimal computational volume.</p>
<p><span><strong>DDSCAT 7.3</strong></span> then takes the stored
solution <span class="math inline">\({\bf P}_j\)</span> and proceeds to
calculate <span class="math inline">\({\bf E}\)</span> at a lattice of
points in an “extended” rectangular volume that can be specified to be
larger than the original “minimal” computational volume. The calculation
is done rapidly using FFT methods, as described by <span
class="citation" data-cites="Flatau+Draine_2012"></span>. The result is
then stored in output files<br />
<br />
for <span><em>n</em></span>=1 and (if <span><code>IORTH=2</code></span>)
<span><em>n</em></span>=2.</p>
<h2 id="running-ddscat-7.3-with-nrfld-2">Running <span><strong>DDSCAT
7.3</strong></span> with NRFLD = 2</h2>
<p>When <span><code>NRFLD</code></span>=2, <span><strong>DDSCAT
7.3</strong></span> will calculate both <span class="math inline">\({\bf
E}_{\rm macro}\)</span> and <span class="math inline">\({\bf B}\)</span>
within the user-specified volume containing the target or target unit
cell. The results will be stored in binary output files<br />
<br />
<br />
for <span><em>n</em></span>=1 and (if <span><code>IORTH=2</code></span>)
<span><em>n</em></span>=2.</p>
<h2 id="the-binary-files-wxxxryyykzzz.en">The Binary Files
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.E</code></span><span><em>n</em></span></h2>
<p>For each of the points <span
class="math inline">\(j=1,...,N_{xyz}\)</span> in the extended volume
where <span class="math inline">\({\bf E}\)</span> was to be calculated,
the binary file
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.E</code></span><span><em>n</em></span>
contains:</p>
<ul>
<li><p>The composition identifer <span class="math inline">\(I_{{\rm
comp},j}\)</span> at each lattice site.
<span><code>ICOMP(K,IX,IY,IZ)</code></span>= composition identifier for
directions <span><code>K=1-3</code></span> at locations
<span><code>IX,IY,IZ</code></span>. Vacuum sites have
<span><code>ICOMP=0</code></span>.</p></li>
<li><p>The polarization <span class="math inline">\({\bf P}_j\)</span>.
<span class="math inline">\({\bf P}_j\)</span> will be zero at all
points outside the target (the ambient medium, taken to be
vacuum).</p></li>
<li><p>The (macroscopic) field <span class="math inline">\({\bf E}_{{\rm
sca},j}\)</span> at each point <span class="math inline">\(j\)</span>
produced by the polarization of the target (not including the dipole at
<span class="math inline">\(j\)</span>). (The total field at <span
class="math inline">\(j\)</span> is just <span
class="math inline">\({\bf E}_j={\bf E}_{{\rm inc},j}+{\bf E}_{{\rm
sca},j}\)</span>).</p></li>
<li><p>The (macroscopic) incident field <span class="math inline">\({\bf
E}_{{\rm inc},j}\)</span> at each point <span
class="math inline">\(j\)</span>.</p></li>
<li><p>The diagonal elements of the polarizability tensor <span
class="math inline">\({\boldsymbol{\alpha}}_j\)</span> at each point. An
exact solution would satisfy <span class="math inline">\({\bf
P}_j={\boldsymbol{\alpha}}_j({\bf E}_{{\rm inc},j}+{\bf E}_{{\rm
sca},j})\)</span>. Thus the stored <span class="math inline">\({\bf
P}\)</span>, <span class="math inline">\({\boldsymbol{\alpha}}\)</span>,
<span class="math inline">\({\bf E}_{\rm inc}\)</span>, and <span
class="math inline">\({\bf E}_{\rm sca}\)</span> allow the accuracy of
the numerical solution to be verified.</p></li>
<li><p>The composition identifer <span class="math inline">\(I_{{\rm
comp},j}\)</span> at each lattice site. (The vacuum sites have <span
class="math inline">\(I_{{\rm comp},j}=0\)</span>).</p></li>
<li><p>The complex dielectric function <span
class="math inline">\(\epsilon_j\)</span> for compositions <span
class="math inline">\(j=1\)</span>, ...
,<span><code>NCOMP</code></span>.</p></li>
</ul>
<p>The
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.E</code></span><span><em>n</em></span>
files can be quite large. For example, the files
<span><code>w000r000k000.E1</code></span> and
<span><code>w000r000k000.E2</code></span> created in the sample
calculation in
<span><code>examples_exp/ELLIPSOID_NEARFIELD</code></span> (see §<a
href="#sec:ELLIPSOID_NEARFIELD" data-reference-type="ref"
data-reference="sec:ELLIPSOID_NEARFIELD">[sec:ELLIPSOID_NEARFIELD]</a>)
are each 90 MBbytes. Some of the stored data is easily recomputed (e.g.,
<span class="math inline">\({\bf E}_{\rm inc}\)</span> and <span
class="math inline">\({\boldsymbol{\alpha}}\)</span>) or in principle
redundant (<span class="math inline">\({\bf P}_j\)</span> could in
principle be obtained from <span
class="math inline">\({\boldsymbol{\alpha}}\)</span>, <span
class="math inline">\({\bf E}_{\rm inc}\)</span>, and <span
class="math inline">\({\bf E}_{\rm sca}\)</span>) but it is convenient
to have them at hand.</p>
<h2 id="the-binary-files-wxxxryyykzzz.ebn">The Binary Files
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.EB</code></span><span><em>n</em></span></h2>
<p>For each of the points <span
class="math inline">\(j=1,...,N_{xyz}\)</span> in the extended volume
where <span class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> were to be calculated, the binary
file
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.EB</code></span><span><em>n</em></span>
contains:</p>
<ul>
<li><p>The composition identifer <span class="math inline">\(I_{{\rm
comp},j}\)</span> at each lattice site.
<span><code>ICOMP(K,IX,IY,IZ)</code></span>= composition identifier for
directions <span><code>K=1-3</code></span> at locations
<span><code>IX,IY,IZ</code></span>. Vacuum sites have
<span><code>ICOMP=0</code></span>.</p></li>
<li><p>The polarization <span class="math inline">\({\bf P}_j\)</span>.
<span class="math inline">\({\bf P}_j\)</span> will be zero at all
points outside the target (the ambient medium, taken to be
vacuum).</p></li>
<li><p>The (macroscopic) field <span class="math inline">\({\bf E}_{{\rm
sca},j}\)</span> at each point <span class="math inline">\(j\)</span>
produced by the polarization of the target (not including the dipole at
<span class="math inline">\(j\)</span>). (The total field at <span
class="math inline">\(j\)</span> is just <span
class="math inline">\({\bf E}_j={\bf E}_{{\rm inc},j}+{\bf E}_{{\rm
sca},j}\)</span>).</p></li>
<li><p>The (macroscopic) incident field <span class="math inline">\({\bf
E}_{{\rm inc},j}\)</span> at each point <span
class="math inline">\(j\)</span>.</p></li>
<li><p>The diagonal elements of the polarizability tensor <span
class="math inline">\({\boldsymbol{\alpha}}_j\)</span> at each point. An
exact solution would satisfy <span class="math inline">\({\bf
P}_j={\boldsymbol{\alpha}}_j({\bf E}_{{\rm inc},j}+{\bf E}_{{\rm
sca},j})\)</span>. Thus the stored <span class="math inline">\({\bf
P}\)</span>, <span class="math inline">\({\boldsymbol{\alpha}}\)</span>,
<span class="math inline">\({\bf E}_{\rm inc}\)</span>, and <span
class="math inline">\({\bf E}_{\rm sca}\)</span> allow the accuracy of
the numerical solution to be verified.</p></li>
<li><p>The magnetic field <span class="math inline">\({\bf B}_{{\rm
sca},j}\)</span> at each point <span class="math inline">\(j\)</span>
produced by the oscillating polarizations of th target (not including
the dipole at <span class="math inline">\(j\)</span>). (The total
magnetic field at <span class="math inline">\(j\)</span> is just <span
class="math inline">\({\bf B}_j={\bf B}_{{\rm inc},j}+{\bf B}_{{\rm
sca},j}\)</span>).</p></li>
<li><p>The magnetic field <span class="math inline">\({\bf B}_{{\rm
inc},j}\)</span> of the incident wave at each point <span
class="math inline">\(j\)</span>.</p></li>
</ul>
<p>The
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.E</code></span><span><em>n</em></span>
files can be quite large. For example, the files
<span><code>w000r000k000.EB1</code></span> and
<span><code>w000r000k000.EB2</code></span> created in the sample
calculation in
<span><code>examples_exp/ELLIPSOID_NEARFLD_B</code></span> (see §<a
href="#sec:ELLIPSOID_NEARFIELD" data-reference-type="ref"
data-reference="sec:ELLIPSOID_NEARFIELD">[sec:ELLIPSOID_NEARFIELD]</a>)
are each 133 MBbytes. Some of the stored data is easily recomputed
(e.g., <span class="math inline">\({\bf E}_{\rm inc}\)</span> and <span
class="math inline">\({\boldsymbol{\alpha}}\)</span>) or in principle
redundant (<span class="math inline">\({\bf P}_j\)</span> could in
principle be obtained from <span
class="math inline">\({\boldsymbol{\alpha}}\)</span>, <span
class="math inline">\({\bf E}_{\rm inc}\)</span>, and <span
class="math inline">\({\bf E}_{\rm sca}\)</span>) but it is convenient
to have them at hand.</p>
<h1 id="post-processing-of-near-field-calculations">Post-Processing of
Near-Field Calculations <span id="sec:postprocessing"
label="sec:postprocessing"></span></h1>
<p><span><strong>DDSCAT 7.3</strong></span> is designed to obtain
solutions to Maxwell’s equations for arbitrary targets illuminated by an
external source of monochromatic radiation. Selected information (cross
sections for absorption and scattering, and far-field scattering
properties) are automatically calculated by <span><strong>DDSCAT
7.3</strong></span>. However, if near-field calculations have been
requested (by specifying <span><code>NRFLD=1</code></span> or
<span><code>2</code></span> in <span><code>ddscat.par</code></span> –
see §<a href="#sec:nearfield" data-reference-type="ref"
data-reference="sec:nearfield">[sec:nearfield]</a>), the complete
nearfield solutions will be stored on disk to allow subsequent
post-processing for visualization, etc.</p>
<p>To facilitate such post-processing, we provide a Fortran-90 code
<span><code>DDPOSTPROCESS.f90</code></span> that can be used to extract
<span class="math inline">\({\bf E}\)</span> (and <span
class="math inline">\({\bf B}\)</span> if magnetic field calculations
were requested by specifying <span><code>NRFLD=2</code></span>).
<span><code>DDPOSTPROCESS.f90</code></span> also outputs some data
suitable for visualization by VTK (see §<a href="#sec:VTK"
data-reference-type="ref" data-reference="sec:VTK">[sec:VTK]</a>). More
importantly, <span><code>DDPOSTPROCESS.f90</code></span> is easily
modifiable by the user, e.g., to output data in formats compatible with
other tools that the user may be accustomed to using, such as
MATLAB<sup></sup>.<a href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a></p>
<h2 id="the-program-ddpostprocess">The Program ddpostprocess <span
id="sec:ddpostprocess" label="sec:ddpostprocess"></span></h2>
<p>A separate program, <span><code>DDPOSTPROCESS.f90</code></span>, is
provided to conveniently read the stored<br />
<br />
files. To create the <span><code>ddpostprocess</code></span> executable,
position yourself in the <span><code>/src</code></span> directory and
type<br />
<br />
which will compile <span><code>DDPOSTPROCESS.f90</code></span> and
create an executable <span><code>ddpostprocess</code></span>.</p>
<p>The program <span><code>ddpostprocess</code></span> is constructed
to:</p>
<ol>
<li><p>Read a user-specified binary file (of the form
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.E</code></span><span><em>n</em></span>,
or
<span><code>w</code></span><span><em>xxx</em></span><span><code>r</code></span><span><em>yyy</em></span><span><code>k</code></span><span><em>zzz</em></span><span><code>.EB</code></span><span><em>n</em></span>)
. The filename is specified in a parameter file
<span><code>ddpostprocess.par</code></span> . The
<span><code>ddpostprocess</code></span> executable will automatically
determine whether the input file contains only <span
class="math inline">\({\bf P}\)</span> and <span
class="math inline">\({\bf E}\)</span> (i.e., was produced by
<span><strong>DDSCAT 7.3</strong></span> with
<span><code>NRFLD</code></span>=1) or if it also contains <span
class="math inline">\({\bf B}\)</span> (i.e., was produced by
<span><strong>DDSCAT 7.3</strong></span> with
<span><code>NRFLD</code></span>=2).</p></li>
<li><p>Read in control parameter <span><code>ILINE</code></span> (0 or
1) determining whether to calculate and write out <span
class="math inline">\({\bf E}\)</span> (and <span
class="math inline">\({\bf B}\)</span>, if available) at points along a
user-specified line.</p></li>
<li><p>Read in control parameter <span><code>IVTR</code></span> (0 or 1)
determining whether to create files for subsequent visualization using
VTK-based software.</p></li>
<li><p>If <span><code>ILINE=1</code></span></p>
<ul>
<li><p>Read in seven parameters defining points along a line: <span
class="math inline">\(x_A,y_A,z_A,x_B,y_B,z_B\)</span> and <span
class="math inline">\(N_{AB}\)</span>. <span
class="math inline">\(x_A,y_A,z_A,x_B,y_B,z_B\)</span> are coordinates
in the target frame (TF), given in physical units.</p></li>
<li><p>Obtain the complex <span class="math inline">\({\bf E}\)</span>
field (and complex <span class="math inline">\({\bf B}\)</span> if
available) at <span class="math inline">\(N_{AB}\)</span>
uniformly-spaced points along the line connecting points <span
class="math inline">\((x_A,y_A,z_A)\)</span> and <span
class="math inline">\((x_B,y_B,z_B)\)</span>.</p></li>
<li><p>repeat for as many lines specifying <span
class="math inline">\(x_A,y_A,z_A,x_B,y_B,z_B\)</span> and <span
class="math inline">\(N_{AB}\)</span> as are present in the parameter
file <span><code>ddpostprocess.par</code></span>.</p></li>
</ul></li>
</ol>
<p>The program <span><code>ddpostprocess</code></span> writes output to
an ascii output file <span><code>ddpostprocess.out</code></span>. The
first 17 lines include information about the calculation (e.g., <span
class="math inline">\({a}_{\rm eff}\)</span>, <span
class="math inline">\(d\)</span>, number of dipoles in target, <span
class="math inline">\(\lambda\)</span>, <span class="math inline">\({\bf
E}_{\rm inc}\)</span>, <span class="math inline">\({\bf B}_{\rm
inc}\)</span>, incident Poynting vector) and column headings. Beginning
with line 18, <span><code>ddpostprocess.out</code></span> gives physical
coordinates <span class="math inline">\(x_{\rm TF}\)</span>, <span
class="math inline">\(y_{\rm TF}\)</span>, <span
class="math inline">\(z_{\rm TF}\)</span> (in the “Target Frame”), and
the real and imaginary parts of the <span
class="math inline">\(x\)</span>, <span
class="math inline">\(y\)</span>, and <span
class="math inline">\(z\)</span> components of the electric field <span
class="math inline">\({\bf E}={\bf E}_{\rm inc}+{\bf E}_{\rm
sca}\)</span> at <span class="math inline">\(N_{AB}\)</span> points
running from <span class="math inline">\((x_A,y_A,z_A)\)</span> to <span
class="math inline">\((x_B,y_B,z_B)\)</span>.</p>
<p>We have carried out nearfield calculations for the problem of an Au
sphere with radius <span class="math inline">\(a=0.39789{\mu{\rm
m}}\)</span> (<span class="math inline">\(D=0.7958{\mu{\rm m}}\)</span>)
illuminated by a plane wave with <span
class="math inline">\(\lambda=0.5{\mu{\rm m}}\)</span> The Au target has
refractive index <span class="math inline">\(m=0.96+1.01i\)</span>. The
nearfield calculation of <span class="math inline">\({\bf E}\)</span> is
for a volume extending <span class="math inline">\(0.5D\)</span> beyond
the spherical target in the +x,-x,+y,-y,+z,-z directions. This is the
example problem in
<span><strong>examples_exp/ELLIPSOID_NEARFIELD</strong></span>, where
you can find the <span><code>ddscat.par</code></span> file.</p>
<p>The <span><code>ddpostprocess.par</code></span> file in
<span><strong>examples_exp/ELLIPSOID_NEARFIELD</strong></span> consists
of:</p>
<pre><code>&#39;w000r000k000.E1&#39;            = name of file with E stored
&#39;VTRoutput&#39;                  = prefix for name of VTR output files
1   = IVTR (set to 1 to create VTR output)
1   = ILINE (set to 1 to evaluate E along a line)
-0.59684 0.0 0.0 0.59684 0.0 0.0 501  = XA,YA,ZA, XB,YB,ZB (phys units), NAB</code></pre>
<p>This calls for 501 equally-spaced points along a line passing through
the center of the sphere, running from <span
class="math inline">\((x_{\rm TF},y_{\rm TF},z_{\rm
TF})=(-.59684,0,0)\)</span> to <span
class="math inline">\((+0.59684,0,0)\)</span>.</p>
<p>For the <span class="math inline">\((x,0,0)\)</span> track running
through the center of the sphere the output
<span><code>ddpostprocess.out</code></span> file will look like (for
brevity, here we show only every 10th line of output along the
track...):</p>
<pre><code>3.9789E-01 = a_eff (radius of equal-volume sphere)
1.6408E-02 = d = dipole spacing
     59728 = N = number of dipoles in target or TUC
      96      96      96 = NX,NY,NZ = extent of computational volume
5.0000E-01 = wavelength in vacuo
   1.00000 = refractive index of ambient medium
   0.20619   0.00000   0.00000 = k_{inc,TF} * d
   0.00000   0.00000 = Re(E_inc,x) Im(E_inc,x) at x_TF=0,y_TF=0,z_TF=0
   1.00000   0.00000 = Re(E_inc,y) Im(E_inc,y) &quot;
   0.00000   0.00000 = Re(E_inc,z) Im(E_inc,z) &quot;
   0.00000   0.00000 = Re(B_inc,x) Im(B_inc,x) &quot;
   0.00000   0.00000 = Re(B_inc,y) Im(B_inc,y) &quot;
   1.00000   0.00000 = Re(B_inc,z) Im(B_inc,z) &quot;
   1.00000   0.00000   0.00000 = 2*(4pi/c)*&lt;S_inc&gt; where &lt;S_inc&gt;=time-averaged incident Poynting vector
[Poynting vector S = (Sx,Sy,Sz) =  (c/4pi)*Re(E)xRe(B) ]
   1.00000 = 2*(4pi/c)*|&lt;S_inc&gt;|
   x_TF       y_TF       z_TF      Re(E_x)   Im(E_x)   Re(E_y)   Im(E_y)   Re(E_z)   Im(E_z)
-5.968E-01  0.000E+00  0.000E+00  -0.00000  -0.00000   0.30023  -0.70908  -0.00000   0.00000
-5.734E-01  0.000E+00  0.000E+00  -0.00000  -0.00000   0.62277  -0.54872   0.00000   0.00000
-5.500E-01  0.000E+00  0.000E+00   0.00000  -0.00000   0.90488  -0.34299  -0.00000   0.00000
-5.266E-01  0.000E+00  0.000E+00  -0.00000  -0.00000   1.11247  -0.10490   0.00000   0.00000
-5.032E-01  0.000E+00  0.000E+00  -0.00000  -0.00000   1.24200   0.13835   0.00000   0.00000
-4.798E-01  0.000E+00  0.000E+00  -0.00000   0.00000   1.27287   0.36285  -0.00000   0.00000
-4.564E-01  0.000E+00  0.000E+00  -0.00000  -0.00000   1.20527   0.54763  -0.00000   0.00000
-4.330E-01  0.000E+00  0.000E+00  -0.00000  -0.00000   1.04366   0.67745  -0.00000   0.00000
-4.096E-01  0.000E+00  0.000E+00   0.00000  -0.00000   0.79740   0.73725   0.00000   0.00000
-3.862E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.16350   0.73080  -0.00000   0.00000
-3.628E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.27552   0.50952  -0.00000  -0.00000
-3.394E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.30770   0.30251   0.00000  -0.00000
-3.160E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.29075   0.14597  -0.00000  -0.00000
-2.926E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.24434   0.03789   0.00000  -0.00000
-2.692E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.18603  -0.03123   0.00000  -0.00000
-2.458E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.12775  -0.06575   0.00000  -0.00000
-2.224E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.07632  -0.07883   0.00000  -0.00000
-1.989E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.03688  -0.07503   0.00000   0.00000
-1.755E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.00836  -0.06318   0.00000  -0.00000
-1.521E-01  0.000E+00  0.000E+00   0.00000   0.00000   0.00933  -0.04767  -0.00000   0.00000
-1.287E-01  0.000E+00  0.000E+00   0.00000   0.00000   0.01830  -0.03206  -0.00000  -0.00000
-1.053E-01  0.000E+00  0.000E+00   0.00000   0.00000   0.02123  -0.01840  -0.00000  -0.00000
-8.192E-02  0.000E+00  0.000E+00   0.00000   0.00000   0.01968  -0.00804   0.00000   0.00000
-5.851E-02  0.000E+00  0.000E+00  -0.00000   0.00000   0.01607  -0.00067  -0.00000   0.00000
-3.511E-02  0.000E+00  0.000E+00  -0.00000  -0.00000   0.01157   0.00347  -0.00000   0.00000
-1.170E-02  0.000E+00  0.000E+00  -0.00000  -0.00000   0.00725   0.00537  -0.00000   0.00000
 1.170E-02  0.000E+00  0.000E+00  -0.00000  -0.00000   0.00370   0.00556   0.00000  -0.00000
 3.511E-02  0.000E+00  0.000E+00   0.00000  -0.00000   0.00118   0.00473  -0.00000  -0.00000
 5.851E-02  0.000E+00  0.000E+00  -0.00000   0.00000  -0.00037   0.00350  -0.00000   0.00000
 8.192E-02  0.000E+00  0.000E+00  -0.00000   0.00000  -0.00099   0.00233  -0.00000  -0.00000
 1.053E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.00109   0.00151   0.00000  -0.00000
 1.287E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.00092   0.00137   0.00000   0.00000
 1.521E-01  0.000E+00  0.000E+00  -0.00000   0.00000  -0.00083   0.00198   0.00000  -0.00000
 1.755E-01  0.000E+00  0.000E+00  -0.00000   0.00000  -0.00119   0.00355   0.00000  -0.00000
 1.989E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.00231   0.00627   0.00000  -0.00000
 2.224E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.00435   0.01031   0.00000  -0.00000
 2.458E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.00764   0.01644   0.00000   0.00000
 2.692E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.01199   0.02493   0.00000   0.00000
 2.926E-01  0.000E+00  0.000E+00  -0.00000  -0.00000  -0.01729   0.03739   0.00000   0.00000
 3.160E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.02279   0.05492  -0.00000   0.00000
 3.394E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.02689   0.07987   0.00000   0.00000
 3.628E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.02611   0.11547   0.00000   0.00000
 3.862E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.01723   0.15689   0.00000   0.00000
 4.096E-01  0.000E+00  0.000E+00   0.00000  -0.00000   0.08404   0.15656   0.00000   0.00000
 4.330E-01  0.000E+00  0.000E+00   0.00000   0.00000   0.00918   0.16548   0.00000   0.00000
 4.564E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.06139   0.16754  -0.00000   0.00000
 4.798E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.12922   0.15953  -0.00000  -0.00000
 5.032E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.19302   0.13802  -0.00000   0.00000
 5.266E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.25016   0.10058  -0.00000   0.00000
 5.500E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.29827   0.04870  -0.00000  -0.00000
 5.734E-01  0.000E+00  0.000E+00   0.00000  -0.00000  -0.33092  -0.01905  -0.00000   0.00000
 5.968E-01  0.000E+00  0.000E+00   0.00000   0.00000  -0.34716  -0.09712  -0.00000   0.00000</code></pre>
<p>In the example given, the incident wave is propagating in the <span
class="math inline">\(+x\)</span> direction. The first layer of dipoles
in the rectangular target is at <span
class="math inline">\(x/d=-31.5\)</span>, and the last layer is at <span
class="math inline">\(x/d=-0.5\)</span>. The “surface” of the target is
at <span class="math inline">\(x/d=-32\)</span> (<span
class="math inline">\(x=-0.50{\mu{\rm m}}\)</span>) and <span
class="math inline">\(x/d=0\)</span> (<span
class="math inline">\(x=0\)</span>).</p>
<p>Figure <a href="#fig:E_ellipsoid_nf" data-reference-type="ref"
data-reference="fig:E_ellipsoid_nf">12</a> shows how <span
class="math inline">\(|E|^2\)</span> varies along a line passing through
the center of the Au sphere. As expected, the wave is strongly
suppressed in the interior of the Au sphere.</p>
<div class="center">
<figure>
<img src="f_ellipsoid_nf.png" id="fig:E_ellipsoid_nf"
style="width:8.3cm"
alt="Solid line: |E|^2 on track passing through center of Au sphere for the sample problem in examples_exp/ELLIPSOID_NEARFIELD, calculated using target option ELLIPSOID. Note how weak the {\bf E} field is inside the Au. Dashed line: |E|^2 on track passing near the corner of the slab. Incident radiation is propagating in the +x direction. " />
<figcaption aria-hidden="true">Solid line: <span
class="math inline">\(|E|^2\)</span> on track passing through center of
Au sphere for the sample problem in examples_exp/ELLIPSOID_NEARFIELD,
calculated using target option <span><code>ELLIPSOID</code></span>. Note
how weak the <span class="math inline">\({\bf E}\)</span> field is
inside the Au. Dashed line: <span class="math inline">\(|E|^2\)</span>
on track passing near the corner of the slab. Incident radiation is
propagating in the <span class="math inline">\(+x\)</span> direction.
</figcaption>
</figure>
</div>
<h2 id="modifying-ddpostprocess.f90">Modifying DDPOSTPROCESS.f90</h2>
<p><span><code>DDPOSTPROCESS.f90</code></span> is written to call
subroutine <span><code>readnf.f90</code></span>, which reads <span
class="math inline">\({\bf P}_j\)</span>, <span
class="math inline">\({\bf E}_{{\rm inc},j}\)</span>, <span
class="math inline">\({\bf E}_{{\rm sca},j}\)</span> from the stored
file written by <span><strong>DDSCAT 7.3</strong></span> subroutine
NEARFIELD (see <span><code>nearfield.f90</code></span>), as well as
<span class="math inline">\({\bf B}_{{\rm inc},j}\)</span> and <span
class="math inline">\({\bf B}_{{\rm sca},j}\)</span> if the magnetic
field has also been computed.</p>
<p><span><code>DDPOSTPROCESS.f90</code></span> includes some calls to
VTK routines to prepare data for VTK visualization. It is written in
standard Fortran 90, and can be readily modified to do additional
calculations with <span class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> returned by output data in other
formats.</p>
<h1 id="displaying-target-shapes">Displaying Target Shapes</h1>
<h2 id="vtrconvert">VTRCONVERT</h2>
<p>It is often desirable to be able to display the target shape. We are
providing a program VTRCONVERT.f90 which allows to convert DDSCAT shape
format to VTK format. VTK is used world-wide in many advanced
visualization applications such as: ParaView, VisIt, 3DSlicer, or
MayaVi2.</p>
<p>Every time <span><strong>DDSCAT 7.3</strong></span> is run, it will
create a "target.out" file. To obtain a target.out file without running
<span><strong>DDSCAT 7.3</strong></span>  the user can run
<span><strong>calltarget</strong></span> to create a "target.out" file.
For example</p>
<p>calltarget &lt; sphere40x40x40.shp</p>
<p>where file “sphere40x40x40.shp” is</p>
<p>ELLIPSOID<br />
40 40<br />
0 0</p>
<p>will create an ASCII file target.out which is a list of the occupied
lattice sites. The format of target.out is the same as the format of the
“shape.dat” files read by <span><strong>DDSCAT</strong></span> if option
FROM_FILE is used in ddscat.par (when you run the
<span><strong>DDSCAT</strong></span> code). The DDSCAT format is very
simple but is not compatible with modern graphics programs such as
"ParaView" or "Mayavi2". Therefore we have created a program
<span><strong>VTRCONVERT</strong></span> to convert between DDSCAT
format and VTK format.</p>
<p>The VTRCONVERT.f90 reads target shape data “target.out” and converts
it to VTR format. The calling sequence is</p>
<p>VTRCONVERT target.out output</p>
<p>where target.out is the name of the DDSCAT shape file created by
“calltarget”. The code writes two output files: “output_1.vtr” and
“output.pvd”. These files can be directly read in by “ParaView” or
“Mayavi2”.</p>
<p>If you are familar with PERL you can execute a script “shapes.pl”. It
will create several shape files.</p>
<h2 id="what-is-vtk"><span id="sec:VTK" label="sec:VTK"></span> What is
VTK?</h2>
<p>The Visualization Toolkit (VTK) is an open-source, freely available
software system for 3D computer graphics and visualization. VTK is used
world-wide in many advanced visualization applications such as:
ParaView, VisIt, 3DSlicer, or MayaVi2. See for example</p>
<p>http://en.wikipedia.org/wiki/ParaView</p>
<p>http://en.wikipedia.org/wiki/MayaVi</p>
<p>Our converter code VTRCONVERT.f90 is written in FORTRAN90 and relies
on the public domain software module vtr.f90 written by Jalel Chergui –
see</p>
<p>http://www.limsi.fr/Individu/chergui/pv/PVD.htm</p>
<p>vtr.f90 defines 5 subroutines which enable writing ASCII data in XML
VTK format. The code allows the user to write a 3D rectilinear mesh
defined by x, y and z components.</p>
<h2 id="how-to-plot-shapes-once-you-have-vtrpvd-files.">How to plot
shapes once you have VTR/PVD files.</h2>
<p>Go to http://paraview.org/paraview/resources/software.html and
download the ParaView executable to your system (ParaView is available
for Windows, Linux, and MacOS)</p>
<p>To plot a contour of a surface:</p>
<ol>
<li><p>In the toolbar, go to File/Open and select the file, e.g.,
shapes/cylinder80x40.pvd (note that in ParaView one needs to open
<span>*</span>.pvd file)</p></li>
<li><p>Under Object Inspector/Properties click apply</p></li>
</ol>
<p>To add spheres indicating dipole positions</p>
<ol>
<li><p>In the toolbar, go to Filters/Common/Contour</p></li>
<li><p>under Object Inspector/Properties click apply</p></li>
<li><p>In the toolbar, go to Filters/Common/Glyph</p></li>
<li><p>Under Object Inspector/Properties one needs to change several
settings</p></li>
<li><p>Glyph Type - change to sphere</p></li>
<li><p>Then</p>
<ol>
<li><p>change Radius to 0.1 (make radius of a dipole smaller) as an
initial choice.</p></li>
<li><p>change Maximum Number of Points to 5000 (or perhaps more
depending on shape, but the points you have the longer it takes to
plot)</p></li>
<li><p>toggle Mask Points to off</p></li>
<li><p>toggle Random Mode to off (plot dipoles in their
positions)</p></li>
</ol></li>
<li><p>Click Apply in object inspector<br />
The initial choice of 0.1 for the radius in step 6 may not produce
"touching" spheres – you can return to step 6 and iterate until you like
the appearanace</p></li>
<li><p>To rotate the figure, left-click on it and "drag" left-right
and/or up-down to rotate around the vertical and/or horizontal
axes.</p></li>
<li><p>To add arrow showing target axes <span class="math inline">\({\bf
a}_1\)</span></p>
<ol>
<li><p>In the toolbar, go to File/Open/a1a2<span
class="math inline">\(\_\)</span>1.pvd<br />
This file has just one point (at position (0,0,0)) and two vectors a1(3)
and a2(3) which are "target axes".</p></li>
<li><p>Under Object Inspector/Properties click "Apply".</p></li>
<li><p>In the Toolbar, go to Filters/Common/Glyph</p></li>
<li><p>Under Object Inspector/Properties</p>
<ol>
<li><p>"Vectors" will show "a1"</p></li>
<li><p>change Glyph Type to "arrow"</p></li>
<li><p>change "Glyph Type" to "arrow"</p></li>
<li><p>change "Tip Radius" to 0.03 (improves appearance; suit
yourself)</p></li>
<li><p>change "Tip Length" to 0.1 (improves appearance...)</p></li>
<li><p>change "Shaft Radius" to 0.01 (improves appearance...)</p></li>
<li><p>click "edit" next to "Set Scale Factor"</p></li>
<li><p>change "Scale Factor" to some value like "40"</p></li>
<li><p>toggle "Mask Points" to off</p></li>
<li><p>toggle "Random Mode" to off</p></li>
<li><p>click "Apply"</p></li>
</ol></li>
</ol></li>
<li><p>To add arrow showing target axis <span class="math inline">\({\bf
a}_2\)</span></p>
<ol>
<li><p>In the toolbar, go to File/Open/a1a2<span
class="math inline">\(\_\)</span>1.pvd</p></li>
<li><p>Under Object Inspector/Properties click "Apply".</p></li>
<li><p>In the Toolbar, go to Filters/Common/Glyph</p></li>
<li><p>Under Object Inspector/Properties</p>
<ol>
<li><p>"Vectors" will show "a1" – change this to "a2"</p></li>
<li><p>change "Glyph Type" to "arrow"</p></li>
<li><p>change "Tip Radius" to 0.03 (improves appearance...)</p></li>
<li><p>change "Tip Length" to 0.1 (improves appearance...)</p></li>
<li><p>change "Shaft Radius" to 0.01 (improves appearance...)</p></li>
<li><p>click "edit" next to "Set Scale Factor"</p></li>
<li><p>change "Scale Factor" to some value like "40"</p></li>
<li><p>toggle "Mask Points" to off</p></li>
<li><p>toggle "Random Mode" to off</p></li>
<li><p>click "Apply"</p></li>
</ol></li>
</ol></li>
<li><p>To save the image: in the toolbar, go to File/Save Screenshot</p>
<ol>
<li><p>select desired resolution (default may be acceptable) and click
Ok.</p></li>
<li><p>enter the desired filename</p></li>
<li><p>select the file type (options are .jpg, .png, .pdf, .tif, .ppm,
.bmp)</p></li>
<li><p>click OK</p></li>
</ol></li>
</ol>
<p>If you wish to add additional features to images, please consult the
ParaView documentation.</p>
<div class="center">
<figure>
<img src="ELLIPSOID.jpg" style="width:8cm"
alt=" Visualization with ParaView of the dipole realization of a sphere, produced following above instructions, using files in directory examples_exp/ELLIPSOID." />
<figcaption aria-hidden="true"> Visualization with ParaView of the
dipole realization of a sphere, produced following above instructions,
using files in directory examples_exp/ELLIPSOID.</figcaption>
</figure>
</div>
<h1 id="visualization-of-the-electric-field">Visualization of the
Electric Field <span id="sec:visualization of E"
label="sec:visualization of E"></span> </h1>
<p>The following instructions assume the user has the MayaVi2 graphics
package installed. If you don’t have it yet, go to<br />
http://code.enthought.com/projects/mayavi/mayavi/installation.html<br />
for installation options.</p>
<ol>
<li><p>First run example ELLIPSOID_NEARFIELD. This will produce
output_1.vtr file.</p></li>
<li><p>Start Mayavi2</p></li>
<li><p>File/load data/open file output</p></li>
<li><p>Point to examples_exp/ELLIPSID_NEARFIELD/VTRoutput_1.vtr</p></li>
<li><p>colors and legends/add module/outline</p></li>
<li><p>outline/right click/add module/contour grid plane</p></li>
<li><p>In Mayavi2 object editor you can position slider between (0,95).
Choose value in the middle. Set "filled contours" to on. Increase number
of contours to 64.</p></li>
<li><p>One can add more "contour grid planes" to illustrate the results
in different cross sections.</p></li>
</ol>
<div class="center">
<figure>
<img src="ellipsoid_nearfield.png" style="width:12cm"
alt=" |{\bf E}|/|{\bf E}_0| on two planes, one passing through the center and one passing near the a=0.398{\mu{\rm m}} Au sphere calculated in examples_exp/ELLIPSOID_NEARFIELD. The incident wave, with \lambda=0.5{\mu{\rm m}}, is propagating with {\bf k}_0\parallel\hat{\bf x}_{\rm TF}. and {\bf E}_0\parallel\hat{\bf y}_{\rm TF}. The axes are labelled in {\mu{\rm m}}. This is the same problem as the results shown in Figure 12. This figure was generated by MayaVi2." />
<figcaption aria-hidden="true"> <span class="math inline">\(|{\bf
E}|/|{\bf E}_0|\)</span> on two planes, one passing through the center
and one passing near the <span class="math inline">\(a=0.398{\mu{\rm
m}}\)</span> Au sphere calculated in examples_exp/ELLIPSOID_NEARFIELD.
The incident wave, with <span class="math inline">\(\lambda=0.5{\mu{\rm
m}}\)</span>, is propagating with <span class="math inline">\({\bf
k}_0\parallel\hat{\bf x}_{\rm TF}\)</span>. and <span
class="math inline">\({\bf E}_0\parallel\hat{\bf y}_{\rm TF}\)</span>.
The axes are labelled in <span class="math inline">\({\mu{\rm
m}}\)</span>. This is the same problem as the results shown in Figure <a
href="#fig:E_ellipsoid_nf" data-reference-type="ref"
data-reference="fig:E_ellipsoid_nf">12</a>. This figure was generated by
MayaVi2.</figcaption>
</figure>
</div>
<h1 id="finale">Finale</h1>
<p>This User Guide is somewhat inelegant, but we hope that it will prove
useful. The structure of the <span><code>ddscat.par</code></span> file
is intended to be simple and suggestive so that, after reading the above
notes once, the user may not have to refer to them again.</p>
<p>Known bugs in <span><strong>DDSCAT</strong></span> will be posted at
the <span><strong>DDSCAT</strong></span> web site,<br />
<span><code>http://code.google.com/p/ddscat/wiki/ReleaseNotes</code></span><br />
and the latest version of <span><strong>DDSCAT</strong></span> can be
found at<br />
<span><code>http://code.google.com/p/ddscat/</code></span></p>
<p>Users are encouraged to provide B. T. Draine
(<span><code>draine@astro.princeton.edu</code></span>) with their email
address; email notification of bug fixes, and any new releases of
<span><strong>DDSCAT</strong></span>, will be made known to those who
do.</p>
<p>P. J. Flatau maintains the “SCATTERLIB - Light Scattering Codes
Library" at<br />
<span><code>http://code.google.com/p/scatterlib</code></span> .<br />
Emphasis is on providing source codes (mostly FORTRAN). However, other
information related to scattering on spherical and non-spherical
particles is collected: an extensive list of references to light
scattering methods, refractive index, etc. This URL page contains
section on the discrete dipole approximation.</p>
<p>Concrete suggestions for improving
<span><strong>DDSCAT</strong></span> (and this User Guide) are
welcomed.</p>
<p>Users of <span><strong>DDSCAT</strong></span> should cite appropriate
papers describing DDA theory and its implementation. The following
papers may be relevant (pdfs are included in the /doc directory)</p>
<ul>
<li><p><span class="citation" data-cites="Draine_1988"></span>: basic
theory of the DDA, including radiative reaction, and application to
anisotropic materials;</p></li>
<li><p><span class="citation"
data-cites="Goodman+Draine+Flatau_1990"></span>: introduction of FFT
methods to greatly accelerate DDA calcualations</p></li>
<li><p><span class="citation" data-cites="Draine+Flatau_1994"></span>:
review of the DDA, including demonstrations of accuracy and
convergence;</p></li>
<li><p><span class="citation" data-cites="Draine+Flatau_2008a"></span>:
extension of the DDA to periodic structures, and generalization of the
Mueller scattering matrix to describe scattering by 1-d and 2-d periodic
structures.</p></li>
<li><p><span class="citation" data-cites="Flatau+Draine_2012"></span>:
implementation of efficient near-field calculations using FFTs.</p></li>
<li><p>This UserGuide.</p></li>
</ul>
<h1 id="acknowledgments">Acknowledgments</h1>
<ul>
<li><p>The routine <span><code>ESELF</code></span> making use of the FFT
was originally written by Jeremy Goodman, Princeton University
Observatory.</p></li>
<li><p>The FFT routine <span><code>FOURX</code></span>, used in the
comparison of different FFT routines, is based on a FFT routine written
by Norman Brenner <span class="citation"
data-cites="Brenner_1969"></span>.</p></li>
<li><p>The <span><code>GPFAPACK</code></span> package was written by
Clive Temperton <span class="citation"
data-cites="Temperton_1992"></span>, and generously made available by
him for use with <span><code>DDSCAT</code></span>.</p></li>
<li><p>Much of the work involved in modifying
<span><code>DDSCAT</code></span> to use <span><code>MPI</code></span>
was done by Matthew Collinge, Princeton University.</p></li>
<li><p>The conjugate gradient routine <span><code>ZBCG2</code></span>
was written by M.A. Botchev<br />
(<span><code>http://www.math.utwente.nl/</code><span
class="math inline">\(\sim\)</span><code>botchev/</code></span>), based
on earlier work by D.R. Fokkema (Dept. of Mathematics, Utrecht
University).</p></li>
<li><p>Art Lazanoff (NASA Ames Research Center) did most of the coding
necessary to use OpenMP and to use the <span><code>DFTI</code></span>
library routine from the Intel<sup></sup> Math Kernel Library, as well
as considerable testing of the new code.</p></li>
<li><p>The conjugate gradient routine
<span><code>qpbicg.f90</code></span> was written by P.C. Chaumet and A.
Rahmani <span class="citation"
data-cites="Chaumet+Rahmani_2009"></span>.</p></li>
<li><p>The conjugate gradient routine
<span><code>qmrpim2.f90</code></span> is based on f77 code written by
P.C. Chaumet and A. Rahmani.</p></li>
<li><p><span><code>vtr.f90</code></span> was written by Jalel Chergui
(LIMSI-CNRS).</p></li>
<li><p>Ian Wong helped write subroutine BSELF and helped implement the
filtered couple dipole option.</p></li>
</ul>
<p>We are deeply indebted to all of these authors for making their work
and code available.</p>
<p>We wish also to acknowledge bug reports and suggestions from
<span><strong>DDSCAT</strong></span> users, including Rodrigo Alcaraz de
la Osa, V. Choliy, Michel Devel, Souraya Goumri-Said, Bo Hu, Bala
Krishna Juluri, Stefan Kniefl, Henrietta Lemke, Georges Levi, Shuzhou
Li, Wang Lin, Paul Mulvaney, Timo Nousianen, Stuart Prescott, Honoh
Suzuki, Sanaz Vahidinia, Bernhard Wasserman, Mike Wolff, and Hui
Zhang.</p>
<p>Development of <span><strong>DDSCAT</strong></span> was supported in
part by National Science Foundation grants AST-8341412, AST-8612013,
AST-9017082, AST-9319283, AST-9616429, AST-9988126, AST-0406883, and
AST-1008570 to BTD, in part by support from the Office of Naval Research
Young Investigator Program to PJF, in part by DuPont Corporate
Educational Assistance to PJF, and in part by the United Kingdom Defence
Research Agency.</p>
<h1 id="references">References</h1>
<div class="thebibliography">
<p>Bohren, C. F. &amp; Huffman, D. R., 1983. <em>Absorption and
Scattering of Light by Small Particles</em>. New York: Wiley.</p>
<p><span>Brenner</span>, N. M., 1969. “<span>Fast Fourier transform of
externally stored data</span>”. <em>IEEE Trans. Audio and
Electroacoustics</em>, 17, 128–132.</p>
<p><span>Chaumet</span>, P. C. &amp; <span>Rahmani</span>, A., 2009.
“<span>Efficient iterative solution of the discrete dipole approximation
for magnetodielectric scatterers</span>”. <em>Optics Letters</em>, 34,
917–919.</p>
<p><span>Collinge</span>, M. J. &amp; <span>Draine</span>, B. T., 2004.
“<span>Discrete dipole approximation with polarizabilities that account
for both finite wavelength and target geometry</span>”.
<em>J. Opt. Soc. Am.</em>, 21, 2023–2028.</p>
<p><span>Draine</span>, B. T., 1988. “<span>The Discrete-Dipole
Approximation and its Application to Interstellar Graphite
Grains</span>”. <em>Astrophys. J.</em>, 333, 848–872.</p>
<p>—, 2000. “<span>The Discrete Dipole Approximation for Light
Scattering by Irregular Targets</span>”. In M. I. Mishchenko, J. W.
Hovenier, &amp; L. D. Travis, eds., “Light Scattering by Nonspherical
Particles: Theory, Measurements, and Applications”, pp. 131–145. San
Diego: Academic Press.</p>
<p>—, 2003. “<span>Scattering by Interstellar Dust Grains. I. Optical
and Ultraviolet</span>”. <em>Astrophys. J.</em>, 598, 1017–1025.</p>
<p><span>Draine</span>, B. T. &amp; <span>Flatau</span>, P. J., 1994.
“<span>Discrete-dipole approximation for scattering
calculations</span>”. <em>J. Opt. Soc. Am.</em>, 11, 1491–1499.</p>
<p>—, 2008. “<span>Discrete dipole approximation for periodic targets:
I. Theory and tests</span>”. <em>J. Opt. Soc. Am.</em>, 25,
2693–2703.</p>
<p><span>Draine</span>, B. T. &amp; <span>Goodman</span>, J., 1993.
“<span>Beyond Clausius-Mossotti - Wave Propagation on a Polarizable
Point Lattice and the Discrete Dipole Approximation</span>”.
<em>Astrophys. J.</em>, 405, 685–697.</p>
<p><span>Draine</span>, B. T. &amp; <span>Weingartner</span>, J. C.,
1996. “<span>Radiative Torques on Interstellar Grains. I. Superthermal
Spin-up</span>”. <em>Astrophys. J.</em>, 470, 551–565.</p>
<p><span>Flatau</span>, P. J., 1997. “<span>Improvements in the
discrete-dipole approximation method of computing scattering and
absorption</span>”. <em>Optics Letters</em>, 22, 1205–1207.</p>
<p><span>Flatau</span>, P. J. &amp; <span>Draine</span>, B. T., 2012.
“<span>Fast near-field calculations in the discrete dipole approximation
for regular rectilinear grids</span>”. <em>Optics Express</em>, 20,
1247–1252.</p>
<p><span>Gay-Balmaz</span>, P. &amp; <span>Martin</span>, O. J. F.,
2002. “<span>A library for computing the filtered and non-filtered 3D
Green’s tensor associated with infinite homogeneous space and
surfaces</span>”. <em>Comp. Phys. Comm.</em>, 144, 111–120.</p>
<p><span>Goodman</span>, J. J., <span>Draine</span>, B. T., &amp;
<span>Flatau</span>, P. J., 1990. “<span>Application of fast-Fourier
transform techniques to the discrete dipole approximation</span>”.
<em>Optics Letters</em>, 16, 1198–1200.</p>
<p><span>Gutkowicz-Krusin</span>, D. &amp; <span>Draine</span>, B. T.,
2004. “<span>Propagation of Electromagnetic Waves on a Rectangular
Lattice of Polarizable Points</span>”. <em>ArXiv e-prints</em>,
http://arXiv.org/abs/astro-ph/0403082.</p>
<p><span>Jackson</span>, J. D., 1975. <em>Classical electrodynamics, 2nd
ed.</em> New York: Wiley.</p>
<p><span>Petravic</span>, M. &amp; <span>Kuo-Petravic</span>, G., 1979.
“<span>An ILUCG Algorithm Which Minimizes in the Euclidean Norm</span>”.
<em>Journal of Computational Physics</em>, 32, 263–269.</p>
<p><span>Piller</span>, N. B. &amp; <span>Martin</span>, O. J. F., 1998.
“<span>Increasing the performance of the coupled-dipole approximation: a
spectral approach</span>”. <em>IEEE Transactions on Antennas and
Propagation</em>, 46, 1126–1137.</p>
<p><span>Purcell</span>, E. M. &amp; <span>Pennypacker</span>, C. R.,
1973. “<span>Scattering and Absorption of Light by Nonspherical
Dielectric Grains</span>”. <em>Astrophys. J.</em>, 186, 705–714.</p>
<p><span>Shen</span>, Y., <span>Draine</span>, B. T., &amp;
<span>Johnson</span>, E. T., 2008. “<span>Modeling Porous Dust Grains
with Ballistic Aggregates I. Methods and Basic Results</span>”.
<em>Astrophys. J.</em>, 689, 260–275.</p>
<p><span>Sleijpen</span>, G. L. G. &amp; <span>Fokkema</span>, D. R.,
1993. “BiCGSTAB(L) for linear matrices involving unsymmetric matrices
with complex spectrum”. <em>ETNA</em>, 1, 11–32.</p>
<p><span>Sleijpen</span>, G. L. G. &amp; <span>van der Vorst</span>,
H. A., 1995. “Maintaining convergence properties of BiCGstab methods in
finite precision arithmetic”. <em>Numerical Algorithms</em>, 10,
203–223.</p>
<p>—, 1996. “Reliable updated residuals in hybrid Bi-CG methods”.
<em>Computing</em>, 56, 141–163.</p>
<p><span>Tang</span>, J., <span>Shen</span>, Y., <span>Zheng</span>, Y.,
&amp; <span>Qiu</span>, D., 2004. “<span>An efficient and flexible
computational model for solving the mild slope equation</span>”.
<em>Coastal Engineering</em>, 51, 143 – 154.</p>
<p><span>Temperton</span>, C., 1992. “<span>A Generalized Prime Factor
FFT Algorithm for any <span
class="math inline">\(N=2^p3^q5^r\)</span></span>”. <em>SIAM
J. Sci. Stat. Comput.</em>, 13, 676–686.</p>
<p><span>Van der Vorst</span>, H. A., 1992. “<span>BI-CGSTAB: A Fast and
Smoothly Converging Variant of Bi-CG for the Solution of Nonsymmetric
Linear Systems</span>”. <em>SIAM J. Sci. Stat. Comput.</em>, 13,
631–644.</p>
<p><span>Yurkin</span>, M. A., <span>Min</span>, M., &amp;
<span>Hoekstra</span>, A. G., 2010. “<span>Application of the discrete
dipole approximation to very large refractive indices: Filtered coupled
dipoles revived</span>”. <em>Phys. Rev. E</em>, 82, 036703.</p>
<p>Zhang, S.-L., 1997. “GPBi-CG: Generalized Product-type Methods Based
on Bi-CG for Solving Nonsymmetric Linear Systems”. <em>SIAM Journal on
Scientific Computing</em>, 18, 537–551. URL
<code>http://link.aip.org/link/?SCE/18/537/1</code>.</p>
</div>
<h1 id="appendix">Appendix</h1>
<div class="appendix">
<h1 id="understanding-and-modifying-ddscat.par">Understanding and
Modifying <span><code>ddscat.par</code></span><span id="app:ddscat.par"
label="app:ddscat.par"></span></h1>
<p>In order to use DDSCAT to perform the specific calculations of
interest to you, it will be necessary to modify the
<span><code>ddscat.par</code></span> file. Here we list the sample
<span><code>ddscat.par</code></span> file for the example problem in
<span><code>examples_exp/RCTGLPRSM</code></span>, followed by a
discussion of how to modify this file as needed. Note that all numerical
input data in DDSCAT is read with free-format
<span><code>READ(IDEV,*)...</code></span> statements. Therefore you do
not need to worry about the precise format in which integer or floating
point numbers are entered on a line. The crucial thing is that lines in
<span><code>ddscat.par</code></span> containing numerical data have the
correct number of data entries, with any informational comments
appearing <span><em>after</em></span> the numerical data on a given
line.</p>
<pre><code>&#39; ========= Parameter file for v7.3 ===================&#39; 
&#39;**** Preliminaries ****&#39;
&#39;NOTORQ&#39; = CMDTRQ*6 (NOTORQ, DOTORQ) -- either do or skip torque calculations
&#39;PBCGS2&#39; = CMDSOL*6 (PBCGS2, PBCGST, GPBICG, PETRKP, QMRCCG) -- CCG method
&#39;GPFAFT&#39; = CMDFFT*6 (GPFAFT, FFTMKL) -- FFT method
&#39;GKDLDR&#39; = CALPHA*6 (GKDLDR, LATTDR, FLTRCD) -- DDA method
&#39;NOTBIN&#39; = CBINFLAG (NOTBIN, ORIBIN, ALLBIN) -- specify binary output
&#39;**** Initial Memory Allocation ****&#39;
100 100 100 = dimensioning allowance for target generation
&#39;**** Target Geometry and Composition ****&#39;
&#39;RCTGLPRSM&#39; = CSHAPE*9 shape directive
16 32 32  = shape parameters 1 - 3
1         = NCOMP = number of dielectric materials
&#39;../diel/Au_evap&#39; = file with refractive index 1
&#39;**** Additional Nearfield calculation? ****&#39;
0 = NRFLD (=0 to skip nearfield calc., =1 to calculate nearfield E)
0.0 0.0 0.0 0.0 0.0 0.0 (fract. extens. of calc. vol. in -x,+x,-y,+y,-z,+z)
&#39;**** Error Tolerance ****&#39;
1.00e-5 = TOL = MAX ALLOWED (NORM OF |G&gt;=AC|E&gt;-ACA|X&gt;)/(NORM OF AC|E&gt;)
&#39;**** maximum number of iterations allowed ****&#39;
300     = MXITER
&#39;**** Interaction cutoff parameter for PBC calculations ****&#39;
1.00e-2 = GAMMA (1e-2 is normal, 3e-3 for greater accuracy)
&#39;**** Angular resolution for calculation of &lt;cos&gt;, etc. ****&#39;
0.5 = ETASCA (number of angles is proportional to [(3+x)/ETASCA]^2 )
&#39;**** Vacuum wavelengths (micron) ****&#39;
0.5000 0.5000 1 &#39;LIN&#39; = wavelengths (first,last,how many,how=LIN,INV,LOG)
&#39;**** Refractive index of ambient medium&#39;
1.000 = NAMBIENT
&#39;**** Effective Radii (micron) **** &#39;
0.246186 0.246186 1 &#39;LIN&#39; = aeff (first,last,how many,how=LIN,INV,LOG)
&#39;**** Define Incident Polarizations ****&#39;
(0,0) (1.,0.) (0.,0.) = Polarization state e01 (k along x axis)
2 = IORTH  (=1 to do only pol. state e01; =2 to also do orth. pol. state)
&#39;**** Specify which output files to write ****&#39;
1 = IWRKSC (=0 to suppress, =1 to write &quot;.sca&quot; file for each target orient.
&#39;**** Prescribe Target Rotations ****&#39;
0.    0.   1  = BETAMI, BETAMX, NBETA  (beta=rotation around a1)
0.    0.   1  = THETMI, THETMX, NTHETA (theta=angle between a1 and k)
0.    0.   1  = PHIMIN, PHIMAX, NPHI (phi=rotation angle of a1 around k)
&#39;**** Specify first IWAV, IRAD, IORI (normally 0 0 0) ****&#39;
0   0   0    = first IWAV, first IRAD, first IORI (0 0 0 to begin fresh)
&#39;**** Select Elements of S_ij Matrix to Print ****&#39;
6   = NSMELTS = number of elements of S_ij to print (not more than 9)
11 12 21 22 31 41   = indices ij of elements to print
&#39;**** Specify Scattered Directions ****&#39;
&#39;LFRAME&#39; = CMDFRM (LFRAME, TFRAME for Lab Frame or Target Frame)
2 = NPLANES = number of scattering planes
0.   0. 180.  5 = phi, thetan_min, thetan_max, dtheta (in deg) for plane 1
90.  0. 180.  5 = phi, thetan_min, thetan_max, dtheta (in deg) for plane 2</code></pre>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Lines</td>
<td style="text-align: left;">Comments</td>
</tr>
<tr class="even">
<td style="text-align: left;">1-2</td>
<td style="text-align: left;">comment lines</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;"><span><code>NOTORQ</code></span> if torque
calculation is not required;</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>DOTORQ</code></span> if torque
calculation is required.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;"><span><code>PBCGS2</code></span> is
recommended; other options are <span><code>PBCGST</code></span>,
<span><code>GPBICG</code></span>, <span><code>PETRKP</code></span>, and
<span><code>QMRCCG</code></span> (see §<a
href="#sec:choice_of_algorithm" data-reference-type="ref"
data-reference="sec:choice_of_algorithm">[sec:choice_of_algorithm]</a>).</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;"><span><code>GPFAFT</code></span> is
supplied as default, but <span><code>FFTMKL</code></span> is recommended
if <span><code>DDSCAT</code></span> has been compiled with</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">the Intel<sup></sup> Math Kernel Library
(see §§<a href="#sec:MKL" data-reference-type="ref"
data-reference="sec:MKL">[sec:MKL]</a>, ).</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;"><span><code>GKDLDR</code></span> is
recommended as the DDA method if the refractive index <span
class="math inline">\(m\)</span> is not too large, but</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>FLTRCD</code></span> may be
better if <span class="math inline">\(|m|\)</span> is large. (see
§)</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;"><span><code>NOTBIN</code></span> for no
unformatted binary output.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>ORIBIN</code></span> for
unformatted binary dump of orientational averages only;</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>ALLBIN</code></span> for full
unformatted binary dump (§<a href="#subsec:binary"
data-reference-type="ref"
data-reference="subsec:binary">[subsec:binary]</a>);</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: left;">initial memory allocation NX,NY,NZ. These
must be large enough to accomodate the target that</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">will be generated.</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: left;">specify choice of target shape (see §<a
href="#sec:target_generation" data-reference-type="ref"
data-reference="sec:target_generation">[sec:target_generation]</a> for
description of options <span><code>RCTGLPRSM</code></span>,
<span><code>ELLIPSOID</code></span>,</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>TETRAHDRN</code></span>,
...)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">12</td>
<td style="text-align: left;">shape parameters <span>SHPAR1</span>,
<span>SHPAR2</span>, <span>SHPAR3</span>, ... (see §<a
href="#sec:target_generation" data-reference-type="ref"
data-reference="sec:target_generation">[sec:target_generation]</a>).</td>
</tr>
<tr class="even">
<td style="text-align: left;">13</td>
<td style="text-align: left;">number of different dielectric constant
tables (see §<a href="#sec:dielectric_func" data-reference-type="ref"
data-reference="sec:dielectric_func">[sec:dielectric_func]</a>).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">14</td>
<td style="text-align: left;">name(s) of dielectric constant table(s)
(one per line).</td>
</tr>
<tr class="even">
<td style="text-align: left;">15</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">16</td>
<td style="text-align: left;"><span><code>NRFLD</code></span> = 0, 1, 2
to skip, do nearfield calculation of <span class="math inline">\({\bf
E}\)</span>, do nearfield calculation of both <span
class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">17</td>
<td style="text-align: left;">6 non-negative numbers <span
class="math inline">\(r_1,...,r_6\)</span> specifying fractional
extension of comptutational volume</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">(in <span class="math inline">\(-\hat{\bf
x}_{\rm TF},+\hat{\bf x}_{\rm TF},-\hat{\bf y}_{\rm TF},+\hat{\bf
y}_{\rm TF},-\hat{\bf z}_{\rm TF},+\hat{\bf z}_{\rm TF}\)</span>
direction (see §<a href="#sec:nearfield calc" data-reference-type="ref"
data-reference="sec:nearfield calc">[sec:nearfield calc]</a>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">18</td>
<td style="text-align: left;">commment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">20</td>
<td style="text-align: left;"><span><code>TOL</code></span> = error
tolerance <span class="math inline">\(h\)</span>: maximum allowed value
of <span class="math inline">\(|A^\dagger E-A^\dagger AP|/|A^\dagger
E|\)</span> [see eq.(<a href="#eq:err_tol" data-reference-type="ref"
data-reference="eq:err_tol">[eq:err_tol]</a>)].</td>
</tr>
<tr class="even">
<td style="text-align: left;">21</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">22</td>
<td style="text-align: left;"><span><code>MXITER</code></span><span
class="math inline">\(=\)</span> maximum number of conjugate-gradient
iterations allowed</td>
</tr>
<tr class="even">
<td style="text-align: left;">23</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">24</td>
<td style="text-align: left;"><span><code>GAMMA</code></span><span
class="math inline">\(=\)</span> interaction cutoff parameter <span
class="math inline">\(\gamma\)</span> (see Draine &amp; Flatau
2009)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">the value of <span
class="math inline">\(\gamma\)</span> does not affect calculations for
isolated targets</td>
</tr>
<tr class="odd">
<td style="text-align: left;">25</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">26</td>
<td style="text-align: left;"><span><code>ETASCA</code></span> –
parameter <span class="math inline">\(\eta\)</span> controlling angular
averages (§<a href="#sec:averaging_scattering" data-reference-type="ref"
data-reference="sec:averaging_scattering">[sec:averaging_scattering]</a>).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">27</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">28</td>
<td style="text-align: left;"><span
class="math inline">\(\lambda\)</span> – vacuum wavlenghts: first, last,
how many, how chosen.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">29</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">30</td>
<td style="text-align: left;"><span><code>NAMBIENT</code></span><span
class="math inline">\(=\)</span> (real) refractive index of ambient
medium.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">31</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">32</td>
<td style="text-align: left;"><span class="math inline">\(a_{\rm
eff}\)</span> – first, last, how many, how chosen.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">33</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">34</td>
<td style="text-align: left;">specify x,y,z components of (complex)
incident polarization <span class="math inline">\({\hat{\bf
e}}_{01}\)</span> (§<a href="#sec:incident_polarization"
data-reference-type="ref"
data-reference="sec:incident_polarization">[sec:incident_polarization]</a>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">35</td>
<td style="text-align: left;"><span><code>IORTH</code></span> = 2 to do
both polarization states (normal);</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>IORTH</code></span> = 1 to do
only one incident polarization.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">36</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">37</td>
<td style="text-align: left;"><span><code>IWRKSC</code></span> = 0 to
suppress writing of “.sca” files;</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><span><code>IWRKSC</code></span> = 1 to
enable writing of “.sca” files.</td>
</tr>
<tr class="even">
<td style="text-align: left;">38</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">39</td>
<td style="text-align: left;"><span class="math inline">\(\beta\)</span>
(see §<a href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>) –
first, last, how many .</td>
</tr>
<tr class="even">
<td style="text-align: left;">40</td>
<td style="text-align: left;"><span
class="math inline">\(\Theta\)</span> (see §<a
href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>) –
first, last, how many.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">41</td>
<td style="text-align: left;"><span class="math inline">\(\Phi\)</span>
(see §<a href="#sec:target_orientation" data-reference-type="ref"
data-reference="sec:target_orientation">[sec:target_orientation]</a>) –
first, last, how many.</td>
</tr>
<tr class="even">
<td style="text-align: left;">42</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">43</td>
<td
style="text-align: left;"><span><code>IWAV0 IRAD0 IORI0</code></span> –
starting values of integers <span><code>IWAV IRAD IORI</code></span>
(normally <span><code>0 0 0</code></span>).</td>
</tr>
<tr class="even">
<td style="text-align: left;">44</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="odd">
<td style="text-align: left;">45</td>
<td style="text-align: left;"><span class="math inline">\(N_{S}\)</span>
= number of scattering matrix elements (must be <span
class="math inline">\(\leq9\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">46</td>
<td style="text-align: left;">indices <span
class="math inline">\(ij\)</span> of <span
class="math inline">\(N_S\)</span> elements of the scattering matrix
<span class="math inline">\(S_{ij}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">47</td>
<td style="text-align: left;">comment line</td>
</tr>
<tr class="even">
<td style="text-align: left;">48</td>
<td style="text-align: left;">specify whether scattered directions are
to be specified by <span><code>CMDFRM=’LFRAME’</code></span> or
<span><code>’TFRAME’</code></span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">49</td>
<td style="text-align: left;"><span><code>NPLANES</code></span><span
class="math inline">\(=\)</span> number of scattering planes to
follow</td>
</tr>
<tr class="even">
<td style="text-align: left;">50</td>
<td style="text-align: left;"><span
class="math inline">\(\phi_s\)</span> for first scattering plane, <span
class="math inline">\(\theta_{s,min}\)</span>, <span
class="math inline">\(\theta_{s,max}\)</span>, how many <span
class="math inline">\(\theta_s\)</span> values;</td>
</tr>
<tr class="odd">
<td style="text-align: left;">51,...</td>
<td style="text-align: left;"><span
class="math inline">\(\phi_s\)</span> for 2nd,... scattering plane,
...</td>
</tr>
</tbody>
</table>
<h1
id="wxxxryyy.avg-files"><span><code>w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>.avg</code></span>
Files<span id="app:w000r000ori.avg"
label="app:w000r000ori.avg"></span></h1>
<p>The file <span><code>w000r000ori.avg</code></span> contains the
results for the first wavelength (<span><code>w000</code></span>) and
first target radius (<span><code>r000</code></span>) averaged over
orientations (<span><code>.avg</code></span>). The
<span><code>w000r000ori.avg</code></span> file generated by the sample
calculation in <span><code>examples_exp/RCTGLPRSM</code></span> should
look like the following:</p>
<pre><code> DDSCAT --- DDSCAT 7.3.0 [12.12.29]   
 TARGET --- Rectangular prism; NX,NY,NZ=  16  32  32                          
 GKDLDR --- DDA method
 PBCGS2 --- CCG method
 RCTGLPRSM --- shape 
   16384     = NAT0 = number of dipoles
  0.06346821 = d/aeff for this target [d=dipole spacing]
    0.015625 = d (physical units)
  AEFF=      0.246186 = effective radius (physical units)
  WAVE=      0.500000 = wavelength (in vacuo, physical units)
K*AEFF=      3.093665 = 2*pi*aeff/lambda
NAMBIENT=    1.000000 = refractive index of ambient medium
n= ( 0.9656 ,  1.8628),  eps.= ( -2.5374 ,  3.5975)  |m|kd=  0.4120 for subs. 1
   TOL= 1.000E-05 = error tolerance for CCG method
( 1.00000  0.00000  0.00000 ) = target axis A1 in Target Frame
( 0.00000  1.00000  0.00000 ) = target axis A2 in Target Frame
  NAVG=   962 = (theta,phi) values used in comp. of Qsca,g
( 0.19635  0.00000  0.00000 ) = k vector (latt. units) in Lab Frame
( 0.00000, 0.00000 )( 1.00000, 0.00000 )( 0.00000, 0.00000 )=inc.pol.vec. 1 in LF
( 0.00000, 0.00000 )( 0.00000, 0.00000 )( 1.00000, 0.00000 )=inc.pol.vec. 2 in LF
   0.000   0.000 = beta_min, beta_max ;  NBETA = 1
   0.000   0.000 = theta_min, theta_max; NTHETA= 1
   0.000   0.000 = phi_min, phi_max   ;   NPHI = 1

 0.5000 = ETASCA = param. controlling # of scatt. dirs used to calculate &lt;cos&gt; etc.
 Results averaged over    1 target orientations
                   and    2 incident polarizations
          Qext       Qabs       Qsca      g(1)=&lt;cos&gt;  &lt;cos^2&gt;     Qbk       Qpha
 JO=1:  3.6134E+00  1.4308E+00  2.1827E+00  4.1463E-01 7.5169E-01 6.1831E-01 -1.2614E-01
 JO=2:  3.6135E+00 1.4308E+00 2.1827E+00  4.1463E-01 7.5169E-01 6.1831E-01 -1.2614E-01
 mean:  3.6134E+00  1.4308E+00  2.1827E+00  4.1463E-01 7.5169E-01 6.1831E-01 -1.2614E-01
 Qpol= -6.4373E-06                                                  dQpha= -4.9174E-07
         Qsca*g(1)   Qsca*g(2)   Qsca*g(3)   iter  mxiter  Nsca
 JO=1:  9.0502E-01 -3.2556E-09 -1.8964E-06     18    300    962
 JO=2:  9.0502E-01 -7.7139E-08  1.4648E-07     18    300    962
 mean:  9.0502E-01 -4.0197E-08 -8.7497E-07
            Mueller matrix elements for selected scattering directions in Lab Frame   
 theta    phi    Pol.    S_11        S_12        S_21       S_22       S_31       S_41
  0.00   0.00  0.00000  7.5115E+01 -1.2970E-04 -1.297E-04  7.512E+01  6.785E-05 -2.220E-06
  5.00   0.00  0.00768  7.2167E+01 -5.5400E-01 -5.540E-01  7.217E+01  6.960E-05  6.113E-06
 10.00   0.00  0.03116  6.3968E+01 -1.9932E+00 -1.993E+00  6.397E+01  6.634E-05  1.229E-05
 15.00   0.00  0.07180  5.2244E+01 -3.7512E+00 -3.751E+00  5.224E+01  5.818E-05  1.351E-05
 20.00   0.00  0.13160  3.9245E+01 -5.1645E+00 -5.165E+00  3.924E+01  4.661E-05  1.559E-05
 25.00   0.00  0.21215  2.7088E+01 -5.7468E+00 -5.747E+00  2.709E+01  3.576E-05  1.251E-05
 30.00   0.00  0.31112  1.7234E+01 -5.3617E+00 -5.362E+00  1.723E+01  2.802E-05  9.135E-06
 35.00   0.00  0.41156  1.0271E+01 -4.2270E+00 -4.227E+00  1.027E+01  1.873E-05  6.317E-06
 40.00   0.00  0.46174  6.0117E+00 -2.7759E+00 -2.776E+00  6.012E+00  1.343E-05  1.892E-06
 45.00   0.00  0.38394  3.7970E+00 -1.4578E+00 -1.458E+00  3.797E+00  9.607E-06 -1.182E-06
 50.00   0.00  0.20310  2.8383E+00 -5.7645E-01 -5.765E-01  2.838E+00  7.253E-06 -1.685E-06
 55.00   0.00  0.08917  2.4759E+00 -2.2077E-01 -2.208E-01  2.476E+00  6.675E-06 -2.270E-06
 60.00   0.00  0.12808  2.2936E+00 -2.9377E-01 -2.938E-01  2.294E+00  6.400E-06 -1.932E-06
 65.00   0.00  0.28428  2.1074E+00 -5.9909E-01 -5.991E-01  2.107E+00  5.960E-06 -1.838E-06
 70.00   0.00  0.49621  1.8862E+00 -9.3596E-01 -9.360E-01  1.886E+00  5.212E-06 -1.174E-06
 75.00   0.00  0.70066  1.6630E+00 -1.1652E+00 -1.165E+00  1.663E+00  4.518E-06 -7.433E-07
 80.00   0.00  0.83815  1.4710E+00 -1.2329E+00 -1.233E+00  1.471E+00  3.404E-06 -2.239E-07
 85.00   0.00  0.87905  1.3178E+00 -1.1584E+00 -1.158E+00  1.318E+00  2.064E-06 -6.282E-07
 90.00   0.00  0.84390  1.1878E+00 -1.0024E+00 -1.002E+00  1.188E+00  1.096E-06 -6.092E-07
 95.00   0.00  0.78583  1.0596E+00 -8.3269E-01 -8.327E-01  1.060E+00  6.710E-07 -4.426E-07
100.00   0.00  0.75672  9.2363E-01 -6.9893E-01 -6.989E-01  9.236E-01  1.610E-07 -4.866E-08
105.00   0.00  0.78540  7.9128E-01 -6.2148E-01 -6.215E-01  7.913E-01  2.381E-07  2.968E-07
110.00   0.00  0.85741  6.9404E-01 -5.9507E-01 -5.951E-01  6.940E-01  8.433E-07  8.885E-07
115.00   0.00  0.89355  6.7418E-01 -6.0241E-01 -6.024E-01  6.742E-01  1.297E-06  1.225E-06
120.00   0.00  0.81395  7.7422E-01 -6.3018E-01 -6.302E-01  7.742E-01  1.748E-06  1.515E-06
125.00   0.00  0.65813  1.0320E+00 -6.7920E-01 -6.792E-01  1.032E+00  2.553E-06  1.802E-06
130.00   0.00  0.51335  1.4856E+00 -7.6264E-01 -7.626E-01  1.486E+00  3.536E-06  2.497E-06
135.00   0.00  0.40829  2.1850E+00 -8.9213E-01 -8.921E-01  2.185E+00  4.473E-06  3.066E-06
140.00   0.00  0.33090  3.2004E+00 -1.0590E+00 -1.059E+00  3.200E+00  6.583E-06  4.014E-06
145.00   0.00  0.26514  4.6139E+00 -1.2233E+00 -1.223E+00  4.614E+00  9.927E-06  4.933E-06
150.00   0.00  0.20350  6.4859E+00 -1.3199E+00 -1.320E+00  6.486E+00  1.326E-05  6.138E-06
155.00   0.00  0.14593  8.8035E+00 -1.2847E+00 -1.285E+00  8.804E+00  1.727E-05  7.720E-06
160.00   0.00  0.09522  1.1432E+01 -1.0886E+00 -1.089E+00  1.143E+01  1.989E-05  7.600E-06
165.00   0.00  0.05409  1.4098E+01 -7.6253E-01 -7.625E-01  1.410E+01  2.215E-05  7.833E-06
170.00   0.00  0.02413  1.6425E+01 -3.9641E-01 -3.964E-01  1.642E+01  2.194E-05  7.723E-06
175.00   0.00  0.00604  1.8022E+01 -1.0884E-01 -1.088E-01  1.802E+01  2.147E-05  6.818E-06
180.00   0.00  0.00000  1.8591E+01 -1.5259E-05 -1.526E-05  1.859E+01  1.746E-05  5.261E-06
  0.00  90.00  0.00000  7.5115E+01  1.2970E-04  1.297E-04  7.512E+01 -6.792E-05 -2.304E-06
  5.00  90.00  0.00767  7.2167E+01 -5.5382E-01 -5.538E-01  7.217E+01 -7.026E-05  1.632E-06
 10.00  90.00  0.03116  6.3968E+01 -1.9931E+00 -1.993E+00  6.397E+01 -6.760E-05  6.943E-06
 15.00  90.00  0.07180  5.2244E+01 -3.7513E+00 -3.751E+00  5.224E+01 -6.176E-05  1.252E-05
 20.00  90.00  0.13160  3.9245E+01 -5.1645E+00 -5.164E+00  3.924E+01 -5.102E-05  1.746E-05
 25.00  90.00  0.21216  2.7088E+01 -5.7468E+00 -5.747E+00  2.709E+01 -3.823E-05  2.014E-05
 30.00  90.00  0.31112  1.7234E+01 -5.3617E+00 -5.362E+00  1.723E+01 -2.451E-05  2.102E-05
 35.00  90.00  0.41156  1.0271E+01 -4.2270E+00 -4.227E+00  1.027E+01 -1.188E-05  1.911E-05
 40.00  90.00  0.46174  6.0117E+00 -2.7758E+00 -2.776E+00  6.012E+00 -1.197E-06  1.526E-05
 45.00  90.00  0.38394  3.7970E+00 -1.4578E+00 -1.458E+00  3.797E+00  6.698E-06  1.039E-05
 50.00  90.00  0.20309  2.8383E+00 -5.7643E-01 -5.764E-01  2.838E+00  1.136E-05  5.124E-06
 55.00  90.00  0.08916  2.4759E+00 -2.2076E-01 -2.208E-01  2.476E+00  1.306E-05  6.010E-07
 60.00  90.00  0.12807  2.2936E+00 -2.9375E-01 -2.937E-01  2.294E+00  1.260E-05 -2.887E-06
 65.00  90.00  0.28427  2.1074E+00 -5.9906E-01 -5.991E-01  2.107E+00  1.042E-05 -4.946E-06
 70.00  90.00  0.49620  1.8862E+00 -9.3594E-01 -9.359E-01  1.886E+00  7.425E-06 -5.874E-06
 75.00  90.00  0.70066  1.6630E+00 -1.1652E+00 -1.165E+00  1.663E+00  4.307E-06 -5.601E-06
 80.00  90.00  0.83814  1.4710E+00 -1.2329E+00 -1.233E+00  1.471E+00  1.319E-06 -4.684E-06
 85.00  90.00  0.87905  1.3178E+00 -1.1584E+00 -1.158E+00  1.318E+00 -1.179E-06 -3.851E-06
 90.00  90.00  0.84389  1.1878E+00 -1.0023E+00 -1.002E+00  1.188E+00 -2.932E-06 -2.944E-06
 95.00  90.00  0.78583  1.0596E+00 -8.3267E-01 -8.327E-01  1.060E+00 -3.904E-06 -2.553E-06
100.00  90.00  0.75672  9.2362E-01 -6.9892E-01 -6.989E-01  9.236E-01 -3.952E-06 -2.432E-06
105.00  90.00  0.78540  7.9127E-01 -6.2146E-01 -6.215E-01  7.913E-01 -3.187E-06 -2.802E-06
110.00  90.00  0.85741  6.9402E-01 -5.9506E-01 -5.951E-01  6.940E-01 -1.639E-06 -3.211E-06
115.00  90.00  0.89354  6.7417E-01 -6.0240E-01 -6.024E-01  6.742E-01  4.964E-07 -3.506E-06
120.00  90.00  0.81394  7.7422E-01 -6.3017E-01 -6.302E-01  7.742E-01  3.042E-06 -3.363E-06
125.00  90.00  0.65811  1.0320E+00 -6.7919E-01 -6.792E-01  1.032E+00  5.488E-06 -2.384E-06
130.00  90.00  0.51334  1.4856E+00 -7.6263E-01 -7.626E-01  1.486E+00  7.604E-06 -5.760E-07
135.00  90.00  0.40828  2.1850E+00 -8.9210E-01 -8.921E-01  2.185E+00  8.701E-06  1.924E-06
140.00  90.00  0.33089  3.2005E+00 -1.0590E+00 -1.059E+00  3.200E+00  8.507E-06  5.022E-06
145.00  90.00  0.26513  4.6139E+00 -1.2233E+00 -1.223E+00  4.614E+00  6.576E-06  8.175E-06
150.00  90.00  0.20349  6.4859E+00 -1.3198E+00 -1.320E+00  6.486E+00  3.323E-06  1.081E-05
155.00  90.00  0.14593  8.8035E+00 -1.2847E+00 -1.285E+00  8.804E+00 -1.197E-06  1.261E-05
160.00  90.00  0.09522  1.1432E+01 -1.0885E+00 -1.089E+00  1.143E+01 -6.047E-06  1.320E-05
165.00  90.00  0.05409  1.4098E+01 -7.6252E-01 -7.625E-01  1.410E+01 -1.070E-05  1.235E-05
170.00  90.00  0.02413  1.6425E+01 -3.9637E-01 -3.964E-01  1.642E+01 -1.452E-05  1.062E-05
175.00  90.00  0.00604  1.8022E+01 -1.0885E-01 -1.089E-01  1.802E+01 -1.681E-05  8.054E-06
180.00  90.00  0.00000  1.8591E+01  1.5259E-05  1.526E-05  1.859E+01 -1.742E-05  5.249E-06</code></pre>
<h1 id="wxxxryyykzzz.sca-files">
w<span><em>xxx</em></span>r<span><em>yyy</em></span>k<span><em>zzz</em></span>.sca
Files <span id="app:w000r000k000.sca"
label="app:w000r000k000.sca"></span></h1>
<p>The <span><code>w000r000k000.sca</code></span> file contains the
results for the first wavelength (<span><code>w000</code></span>), first
target radius (<span><code>r000</code></span>), and first orientation
(<span><code>k000</code></span>). The
<span><code>w000r000k000.sca</code></span> file created by the sample
calculation in <span><code>examples_exp/RCTGLPRSM</code></span> should
look like the following:</p>
<pre><code> DDSCAT --- DDSCAT 7.3.0 [12.12.29]   
 TARGET --- Rectangular prism; NX,NY,NZ=  16  32  32                          
 GKDLDR --- DDA method
 PBCGS2 --- CCG method
 RCTGLPRSM --- shape 
   16384     = NAT0 = number of dipoles
  0.06346821 = d/aeff for this target [d=dipole spacing]
    0.015625 = d (physical units)
----- physical extent of target volume in Target Frame ------
     -0.250000      0.000000 = xmin,xmax (physical units)
     -0.250000      0.250000 = ymin,ymax (physical units)
     -0.250000      0.250000 = zmin,zmax (physical units)
  AEFF=      0.246186 = effective radius (physical units)
  WAVE=      0.500000 = wavelength (in vacuo, physical units)
K*AEFF=      3.093665 = 2*pi*aeff/lambda
NAMBIENT=    1.000000 = refractive index of ambient medium
n= ( 0.9656 ,  1.8628),  eps.= ( -2.5374 ,  3.5975)  |m|kd=  0.4120 for subs. 1
   TOL= 1.000E-05 = error tolerance for CCG method
( 1.00000  0.00000  0.00000 ) = target axis A1 in Target Frame
( 0.00000  1.00000  0.00000 ) = target axis A2 in Target Frame
  NAVG=   962 = (theta,phi) values used in comp. of Qsca,g
( 0.19635  0.00000  0.00000 ) = k vector (latt. units) in TF
( 0.00000, 0.00000 )( 1.00000, 0.00000 )( 0.00000, 0.00000 )=inc.pol.vec. 1 in TF
( 0.00000, 0.00000 )( 0.00000, 0.00000 )( 1.00000, 0.00000 )=inc.pol.vec. 2 in TF
( 1.00000  0.00000  0.00000 ) = target axis A1 in Lab Frame
( 0.00000  1.00000  0.00000 ) = target axis A2 in Lab Frame
( 0.19635  0.00000  0.00000 ) = k vector (latt. units) in Lab Frame
( 0.00000, 0.00000 )( 1.00000, 0.00000 )( 0.00000, 0.00000 )=inc.pol.vec. 1 in LF
( 0.00000, 0.00000 )( 0.00000, 0.00000 )( 1.00000, 0.00000 )=inc.pol.vec. 2 in LF
 BETA =  0.000 = rotation of target around A1
 THETA=  0.000 = angle between A1 and k
  PHI =  0.000 = rotation of A1 around k
 0.5000 = ETASCA = param. controlling # of scatt. dirs used to calculate &lt;cos&gt; etc.
          Qext       Qabs       Qsca      g(1)=&lt;cos&gt;  &lt;cos^2&gt;     Qbk       Qpha
 JO=1:  3.6134E+00  1.4308E+00  2.1827E+00  4.1463E-01 7.5169E-01 6.1831E-01 -1.2614E-01
 JO=2:  3.6135E+00  1.4308E+00  2.1827E+00  4.1463E-01 7.5169E-01 6.1831E-01 -1.2614E-01
 mean:  3.6134E+00  1.4308E+00  2.1827E+00  4.1463E-01 7.5169E-01 6.1831E-01 -1.2614E-01
 Qpol= -6.4373E-06                                                  dQpha= -4.9174E-07
         Qsca*g(1)   Qsca*g(2)   Qsca*g(3)   iter  mxiter  Nsca
 JO=1:  9.0502E-01 -3.2556E-09 -1.8964E-06     18    300    962
 JO=2:  9.0502E-01 -7.7139E-08  1.4648E-07     18    300    962
 mean:  9.0502E-01 -4.0197E-08 -8.7497E-07
            Mueller matrix elements for selected scattering directions in Lab Frame   
 theta    phi    Pol.    S_11        S_12        S_21       S_22       S_31       S_41
  0.00   0.00  0.00000  7.5115E+01 -1.2970E-04 -1.297E-04  7.512E+01  6.785E-05 -2.220E-06
  5.00   0.00  0.00768  7.2167E+01 -5.5400E-01 -5.540E-01  7.217E+01  6.960E-05  6.113E-06
 10.00   0.00  0.03116  6.3968E+01 -1.9932E+00 -1.993E+00  6.397E+01  6.634E-05  1.229E-05
 15.00   0.00  0.07180  5.2244E+01 -3.7512E+00 -3.751E+00  5.224E+01  5.818E-05  1.351E-05
 20.00   0.00  0.13160  3.9245E+01 -5.1645E+00 -5.165E+00  3.924E+01  4.661E-05  1.559E-05
 25.00   0.00  0.21215  2.7088E+01 -5.7468E+00 -5.747E+00  2.709E+01  3.576E-05  1.251E-05
 30.00   0.00  0.31112  1.7234E+01 -5.3617E+00 -5.362E+00  1.723E+01  2.802E-05  9.135E-06
 35.00   0.00  0.41156  1.0271E+01 -4.2270E+00 -4.227E+00  1.027E+01  1.873E-05  6.317E-06
 40.00   0.00  0.46174  6.0117E+00 -2.7759E+00 -2.776E+00  6.012E+00  1.343E-05  1.892E-06
 45.00   0.00  0.38394  3.7970E+00 -1.4578E+00 -1.458E+00  3.797E+00  9.607E-06 -1.182E-06
 50.00   0.00  0.20310  2.8383E+00 -5.7645E-01 -5.765E-01  2.838E+00  7.253E-06 -1.685E-06
 55.00   0.00  0.08917  2.4759E+00 -2.2077E-01 -2.208E-01  2.476E+00  6.675E-06 -2.270E-06
 60.00   0.00  0.12808  2.2936E+00 -2.9377E-01 -2.938E-01  2.294E+00  6.400E-06 -1.932E-06
 65.00   0.00  0.28428  2.1074E+00 -5.9909E-01 -5.991E-01  2.107E+00  5.960E-06 -1.838E-06
 70.00   0.00  0.49621  1.8862E+00 -9.3596E-01 -9.360E-01  1.886E+00  5.212E-06 -1.174E-06
 75.00   0.00  0.70066  1.6630E+00 -1.1652E+00 -1.165E+00  1.663E+00  4.518E-06 -7.433E-07
 80.00   0.00  0.83815  1.4710E+00 -1.2329E+00 -1.233E+00  1.471E+00  3.404E-06 -2.239E-07
 85.00   0.00  0.87905  1.3178E+00 -1.1584E+00 -1.158E+00  1.318E+00  2.064E-06 -6.282E-07
 90.00   0.00  0.84390  1.1878E+00 -1.0024E+00 -1.002E+00  1.188E+00  1.096E-06 -6.092E-07
 95.00   0.00  0.78583  1.0596E+00 -8.3269E-01 -8.327E-01  1.060E+00  6.710E-07 -4.426E-07
100.00   0.00  0.75672  9.2363E-01 -6.9893E-01 -6.989E-01  9.236E-01  1.610E-07 -4.866E-08
105.00   0.00  0.78540  7.9128E-01 -6.2148E-01 -6.215E-01  7.913E-01  2.381E-07  2.968E-07
110.00   0.00  0.85741  6.9404E-01 -5.9507E-01 -5.951E-01  6.940E-01  8.433E-07  8.885E-07
115.00   0.00  0.89355  6.7418E-01 -6.0241E-01 -6.024E-01  6.742E-01  1.297E-06  1.225E-06
120.00   0.00  0.81395  7.7422E-01 -6.3018E-01 -6.302E-01  7.742E-01  1.748E-06  1.515E-06
125.00   0.00  0.65813  1.0320E+00 -6.7920E-01 -6.792E-01  1.032E+00  2.553E-06  1.802E-06
130.00   0.00  0.51335  1.4856E+00 -7.6264E-01 -7.626E-01  1.486E+00  3.536E-06  2.497E-06
135.00   0.00  0.40829  2.1850E+00 -8.9213E-01 -8.921E-01  2.185E+00  4.473E-06  3.066E-06
140.00   0.00  0.33090  3.2004E+00 -1.0590E+00 -1.059E+00  3.200E+00  6.583E-06  4.014E-06
145.00   0.00  0.26514  4.6139E+00 -1.2233E+00 -1.223E+00  4.614E+00  9.927E-06  4.933E-06
150.00   0.00  0.20350  6.4859E+00 -1.3199E+00 -1.320E+00  6.486E+00  1.326E-05  6.138E-06
155.00   0.00  0.14593  8.8035E+00 -1.2847E+00 -1.285E+00  8.804E+00  1.727E-05  7.720E-06
160.00   0.00  0.09522  1.1432E+01 -1.0886E+00 -1.089E+00  1.143E+01  1.989E-05  7.600E-06
165.00   0.00  0.05409  1.4098E+01 -7.6253E-01 -7.625E-01  1.410E+01  2.215E-05  7.833E-06
170.00   0.00  0.02413  1.6425E+01 -3.9641E-01 -3.964E-01  1.642E+01  2.194E-05  7.723E-06
175.00   0.00  0.00604  1.8022E+01 -1.0884E-01 -1.088E-01  1.802E+01  2.147E-05  6.818E-06
180.00   0.00  0.00000  1.8591E+01 -1.5259E-05 -1.526E-05  1.859E+01  1.746E-05  5.261E-06
  0.00  90.00  0.00000  7.5115E+01  1.2970E-04  1.297E-04  7.512E+01 -6.792E-05 -2.304E-06
  5.00  90.00  0.00767  7.2167E+01 -5.5382E-01 -5.538E-01  7.217E+01 -7.026E-05  1.632E-06
 10.00  90.00  0.03116  6.3968E+01 -1.9931E+00 -1.993E+00  6.397E+01 -6.760E-05  6.943E-06
 15.00  90.00  0.07180  5.2244E+01 -3.7513E+00 -3.751E+00  5.224E+01 -6.176E-05  1.252E-05
 20.00  90.00  0.13160  3.9245E+01 -5.1645E+00 -5.164E+00  3.924E+01 -5.102E-05  1.746E-05
 25.00  90.00  0.21216  2.7088E+01 -5.7468E+00 -5.747E+00  2.709E+01 -3.823E-05  2.014E-05
 30.00  90.00  0.31112  1.7234E+01 -5.3617E+00 -5.362E+00  1.723E+01 -2.451E-05  2.102E-05
 35.00  90.00  0.41156  1.0271E+01 -4.2270E+00 -4.227E+00  1.027E+01 -1.188E-05  1.911E-05
 40.00  90.00  0.46174  6.0117E+00 -2.7758E+00 -2.776E+00  6.012E+00 -1.197E-06  1.526E-05
 45.00  90.00  0.38394  3.7970E+00 -1.4578E+00 -1.458E+00  3.797E+00  6.698E-06  1.039E-05
 50.00  90.00  0.20309  2.8383E+00 -5.7643E-01 -5.764E-01  2.838E+00  1.136E-05  5.124E-06
 55.00  90.00  0.08916  2.4759E+00 -2.2076E-01 -2.208E-01  2.476E+00  1.306E-05  6.010E-07
 60.00  90.00  0.12807  2.2936E+00 -2.9375E-01 -2.937E-01  2.294E+00  1.260E-05 -2.887E-06
 65.00  90.00  0.28427  2.1074E+00 -5.9906E-01 -5.991E-01  2.107E+00  1.042E-05 -4.946E-06
 70.00  90.00  0.49620  1.8862E+00 -9.3594E-01 -9.359E-01  1.886E+00  7.425E-06 -5.874E-06
 75.00  90.00  0.70066  1.6630E+00 -1.1652E+00 -1.165E+00  1.663E+00  4.307E-06 -5.601E-06
 80.00  90.00  0.83814  1.4710E+00 -1.2329E+00 -1.233E+00  1.471E+00  1.319E-06 -4.684E-06
 85.00  90.00  0.87905  1.3178E+00 -1.1584E+00 -1.158E+00  1.318E+00 -1.179E-06 -3.851E-06
 90.00  90.00  0.84389  1.1878E+00 -1.0023E+00 -1.002E+00  1.188E+00 -2.932E-06 -2.944E-06
 95.00  90.00  0.78583  1.0596E+00 -8.3267E-01 -8.327E-01  1.060E+00 -3.904E-06 -2.553E-06
100.00  90.00  0.75672  9.2362E-01 -6.9892E-01 -6.989E-01  9.236E-01 -3.952E-06 -2.432E-06
105.00  90.00  0.78540  7.9127E-01 -6.2146E-01 -6.215E-01  7.913E-01 -3.187E-06 -2.802E-06
110.00  90.00  0.85741  6.9402E-01 -5.9506E-01 -5.951E-01  6.940E-01 -1.639E-06 -3.211E-06
115.00  90.00  0.89354  6.7417E-01 -6.0240E-01 -6.024E-01  6.742E-01  4.964E-07 -3.506E-06
120.00  90.00  0.81394  7.7422E-01 -6.3017E-01 -6.302E-01  7.742E-01  3.042E-06 -3.363E-06
125.00  90.00  0.65811  1.0320E+00 -6.7919E-01 -6.792E-01  1.032E+00  5.488E-06 -2.384E-06
130.00  90.00  0.51334  1.4856E+00 -7.6263E-01 -7.626E-01  1.486E+00  7.604E-06 -5.760E-07
135.00  90.00  0.40828  2.1850E+00 -8.9210E-01 -8.921E-01  2.185E+00  8.701E-06  1.924E-06
140.00  90.00  0.33089  3.2005E+00 -1.0590E+00 -1.059E+00  3.200E+00  8.507E-06  5.022E-06
145.00  90.00  0.26513  4.6139E+00 -1.2233E+00 -1.223E+00  4.614E+00  6.576E-06  8.175E-06
150.00  90.00  0.20349  6.4859E+00 -1.3198E+00 -1.320E+00  6.486E+00  3.323E-06  1.081E-05
155.00  90.00  0.14593  8.8035E+00 -1.2847E+00 -1.285E+00  8.804E+00 -1.197E-06  1.261E-05
160.00  90.00  0.09522  1.1432E+01 -1.0885E+00 -1.089E+00  1.143E+01 -6.047E-06  1.320E-05
165.00  90.00  0.05409  1.4098E+01 -7.6252E-01 -7.625E-01  1.410E+01 -1.070E-05  1.235E-05
170.00  90.00  0.02413  1.6425E+01 -3.9637E-01 -3.964E-01  1.642E+01 -1.452E-05  1.062E-05
175.00  90.00  0.00604  1.8022E+01 -1.0885E-01 -1.089E-01  1.802E+01 -1.681E-05  8.054E-06
180.00  90.00  0.00000  1.8591E+01  1.5259E-05  1.526E-05  1.859E+01 -1.742E-05  5.249E-06</code></pre>
<h1
id="wxxxryyykzzz.poln-files"><span><code>w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>k</code><span><em><code>zzz</code></em></span><code>.pol</code><span><em><code>n</code></em></span></span>
Files <span id="app:w000r000k000.poln"
label="app:w000r000k000.poln"></span></h1>
<p>Binary files
<span><code>w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>k</code><span><em><code>zzz</code></em></span><code>.pol</code><span><em><code>n</code></em></span></span>
are written to disk only when nearfield calculations are done (parameter
<span><code>NRFLD</code></span>=1). The
<span><code>w000r000k000.pol1</code></span> file contains the
polarization solution for the first wavelength
(<span><code>w000</code></span>), first target radius
(<span><code>r000</code></span>), first orientation
(<span><code>k000</code></span>), and first incident polarization
(<span><code>pol1</code></span>). In order to limit the size of this
file, it has been written as an <span><em>unformatted</em></span> or
"binary" file. This preserves full machine precision for the data, is
quite compact, and can be read efficiently, but unfortunately the file
is <span><strong>not</strong></span> fully portable because different
computer architectures (e.g., Linux vs. MS Windows) have adopted
different standards for storage of “unformatted” data. However,
anticipating that many users will be computing within a single
architecture, the distribution version of
<span><strong>DDSCAT</strong></span> uses this format.</p>
<p>Additional warning: even on a single architecture, users should be
alert to the possibility that different compilers may follow different
conventions for reading/writing unformatted files.</p>
<p>The file contains the following information:</p>
<ul>
<li><p>The location of each dipole in the target frame.</p></li>
<li><p><span class="math inline">\((k_x,k_y,k_z)d\)</span>, where <span
class="math inline">\(\bf k\)</span> is the incident <span
class="math inline">\(k\)</span> vector.</p></li>
<li><p><span class="math inline">\((E_{0x},E_{0y},E_{0z})\)</span>, the
complex polarization vector of the incident wave.</p></li>
<li><p><span class="math inline">\(\alpha^{-1}d^3\)</span>, the inverse
of the symmmetric complex polarizability tensor for each of the dipoles
in the target.</p></li>
<li><p><span class="math inline">\((P_x,P_y,P_z)\)</span>, the complex
polarization vector for each of the dipoles.</p></li>
</ul>
<p>The interested user should consult the routine
<span><code>writepol.f</code></span> to see how this information has
been organized in the unformatted file.</p>
<h1
id="wxxxryyykzzz.en-files"><span>w<span><em>xxx</em></span>r<span><em>yyy</em></span>k<span><em>zzz</em></span>.E<span><em>n</em></span></span>
Files <span id="app:w000r000k000.En"
label="app:w000r000k000.En"></span></h1>
<p>Binary files
<span><code>w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>k</code><span><em><code>zzz</code></em></span><code>.E</code><span><em><code>n</code></em></span></span>
are written to disk only when nearfield calculations of <span
class="math inline">\({\bf E}\)</span> (but not <span
class="math inline">\({\bf B}\)</span>) are done (parameter
<span><code>NRFLD</code></span>=1). The
<span><code>w000r000k000.E1</code></span> file contains information
describing the problem and the solution at "grid points" throughout the
extended "computational volume" specified for the nearfield calculation
(see §<a href="#sec:nearfield" data-reference-type="ref"
data-reference="sec:nearfield">[sec:nearfield]</a>). These binary files
are very large, but have been written in a way to simplify subsequent
use for visualization using, e.g., the program
<span><code>DDPOSTPROCESS.f90</code></span> (see §<a
href="#sec:visualization of E" data-reference-type="ref"
data-reference="sec:visualization of E">[sec:visualization of E]</a>).
The interested user can examine subroutine
<span><code>nearfield.f90</code></span> that writes the file, or program
<span><code>DDPOSTPROCESS.f90</code></span> that reads the file, to see
how the information is organized.</p>
<p>A user who finds the file size to be a serious problem may wish to
modify the code in <span><code>nearfield.f90</code></span> to suppress
writing of some of the arrays (e.g., the diagonal elements of the
<span><strong>A</strong></span> matrix), retaining only the data of
specific interest (e.g., the <span class="math inline">\({\bf
E}\)</span> field). Of course, and modifications to
<span><code>WRITE</code></span> statements in
<span><code>nearfield.f90</code></span> will require corresponding
changes to <span><code>READ</code></span> statements in subroutine
<span><code>readnf.f90</code></span> that
<span><code>DDPOSTPROCESS.f90</code></span> calls to read from the
stored data files.</p>
<h1
id="wxxxryyykzzz.ebn-files"><span>w<span><em>xxx</em></span>r<span><em>yyy</em></span>k<span><em>zzz</em></span>.EB<span><em>n</em></span></span>
Files <span id="app:w000r000k000.En"
label="app:w000r000k000.En"></span></h1>
<p>Binary files
<span><code>w</code><span><em><code>xxx</code></em></span><code>r</code><span><em><code>yyy</code></em></span><code>k</code><span><em><code>zzz</code></em></span><code>.EB</code><span><em><code>n</code></em></span></span>
are written to disk only when nearfield calculations are done for both
<span class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> (parameter
<span><code>NRFLD</code></span>=2). The
<span><code>w000r000k000.EB1</code></span> file contains information
describing the problem and the solution at "grid points" throughout the
extended "computational volume" specified for the nearfield calculation
(see §<a href="#sec:nearfield" data-reference-type="ref"
data-reference="sec:nearfield">[sec:nearfield]</a>). These binary files
are very large, but have been written in a way to simplify subsequent
use for visualization using, e.g., the program
<span><code>DDPOSTPROCESS.f90</code></span> (see §<a
href="#sec:visualization of E" data-reference-type="ref"
data-reference="sec:visualization of E">[sec:visualization of E]</a>).
The interested user can examine subroutine
<span><code>nearfield.f90</code></span> that writes the file, or program
<span><code>DDPOSTPROCESS.f90</code></span> that reads the file, to see
how the information is organized.</p>
<p>A user who finds the file size to be a serious problem may wish to
modify the code in <span><code>nearfield.f90</code></span> to suppress
writing of some of the arrays (e.g., the diagonal elements of the
<span><strong>A</strong></span> matrix), retaining only the data of
specific interest (e.g., <span class="math inline">\({\bf B}_{{\rm
sca}}\)</span>). Of course, and modifications to
<span><code>WRITE</code></span> statements in
<span><code>nearfield.f90</code></span> will require corresponding
changes to <span><code>READ</code></span> statements in
<span><code>DDPOSTPROCESS.f90</code></span>.</p>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The release history of
<span><strong>DDSCAT</strong></span> is as follows:</p>
<ul>
<li><p><span><strong>DDSCAT 4b</strong></span>: Released 1993 March
12</p></li>
<li><p><span><strong>DDSCAT 4b1</strong></span>: Released 1993 July
9</p></li>
<li><p><span><strong>DDSCAT 4c</strong></span>: Although never
announced, <span><code>DDSCAT.4c</code></span> was made available to a
number of interested users beginning 1994 December 18</p></li>
<li><p><span><strong>DDSCAT 5a7</strong></span>: Released 1996</p></li>
<li><p><span><strong>DDSCAT 5a8</strong></span>: Released 1997 April
24</p></li>
<li><p><span><strong>DDSCAT 5a9</strong></span>: Released 1998 December
15</p></li>
<li><p><span><strong>DDSCAT 5a10</strong></span>: Released 2000 June
15</p></li>
<li><p><span><strong>DDSCAT 6.0</strong></span>: Released 2003 September
2</p></li>
<li><p><span><strong>DDSCAT 6.1</strong></span>: Released 2004 September
10</p></li>
<li><p><span><strong>DDSCAT 7.0</strong></span>: Released 2008 September
1</p></li>
<li><p><span><strong>DDSCAT 7.1</strong></span>: Released 2010 February
7</p></li>
<li><p><span><strong>DDSCAT 7.2</strong></span>: Released 2012 February
15</p></li>
<li><p><span><strong>DDSCAT 7.2.1</strong></span>: Released 2012 May
14</p></li>
<li><p><span><strong>DDSCAT 7.2.2</strong></span>: Released 2012 June
3</p></li>
<li><p><span><strong>DDSCAT 7.3.0</strong></span>: Released 2013 May
26</p></li>
</ul>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn2"><p>In the case of an infinite periodic target, <span
class="math inline">\(V\)</span> is the volume of solid material in one
“Target Unit Cell”.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><code>http://www.mpi-forum.org/</code><a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Intel<sup></sup> for some reason now refers to this as
“Intel<sup></sup> Visual Fortran Composer XE 2013”.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Had we specified 0 90 3 we would have obtained three
values of <span class="math inline">\(\Theta\)</span> between 0 and
<span class="math inline">\(90^\circ\)</span>, unformly-spaced in <span
class="math inline">\(\cos\theta\)</span>: <span
class="math inline">\(\Theta=0\)</span>, <span
class="math inline">\(60^\circ\)</span>, and <span
class="math inline">\(90^\circ\)</span>.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><code>http://www.openpbs.org</code><a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>As of this writing (2013.05), this information on batch
scheduling is several years old. It may have been superseded by new
practices since we last checked.<a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>The number of digits in <span><em>zzz</em></span> is
only as many as are needed to specify the total number of different
orientations considered. If the total number of orientations is <span
class="math inline">\(\leq10\)</span>, then <span><em>zzz</em></span>
will have only a single digit, if the number of orientations is between
11 and 100, <span><em>zzz</em></span> wll have two digits, etc.<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>A postscript copy of this report – file
<span><code>cg.ps</code></span> – is distributed with the
<span><strong>DDSCAT 7.3</strong></span> documentation.<a href="#fnref9"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>The Parallel Iterative Methods (PIM) by Rudnei Dias da
Cunha (<span><code> rdd@ukc.ac.uk</code></span>) and Tim Hopkins
(<span><code>trh@ukc.ac.uk</code></span>) is a collection of Fortran 77
routines designed to solve systems of linear equations on parallel and
scalar computers using a variety of iterative methods (available at ).
PIM offers a number of iterative methods, including</p>
<ul>
<li><p>the stabilised version of Bi-Conjugate-Gradients, BICGSTAB <span
class="citation" data-cites="van_der_Vorst_1992"></span>,</p></li>
<li><p>the restarted version of BICGSTAB, RBICGSTAB <span
class="citation" data-cites="Sleijpen+Fokkema_1993"></span></p></li>
</ul>
<p>The source code for these methods is distributed with
<span><code>DDSCAT</code></span> but only
<span><code>PBCGST</code></span> and <span><code>PETRKP</code></span>
can be called directly via <span><code> ddscat.par</code></span>. It is
possible to add other options by changing the code in
<span><code>getfml.f90</code></span> . <span class="citation"
data-cites="Flatau_1997"></span> has compared the convergence rates of a
number of different methods. A helpful introduction to conjugate
gradient methods is provided by the report “Conjugate Gradient Method
Without Agonizing Pain" by Jonathan R. Shewchuk, available as a
postscript file:
<span><code> ftp://REPORTS.ADM.CS.CMU.EDU/usr0/anon/1994/CMU-CS-94-125.ps</code></span>.<a
href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>The GPFA code contains a parameter
<span><code>LVR</code></span> which is set in
<span><code>data</code></span> statements in the routines
<span><code>gpfa2f</code></span>, <span><code>gpfa3f</code></span>, and
<span><code>gpfa5f</code></span>. <span><code>LVR</code></span> is
supposed to be optimized to correspond to the “length of a vector
register” on vector machines. As delivered, this parameter is set to 64,
which is supposed to be appropriate for Crays other than the C90. For
the C90, 128 is supposed to be preferable (and perhaps “preferable”
should be read as “necessary” – there is some basis for fearing that
results computed on a C90 with <span><code>LVR</code></span> other than
128 run the risk of being incorrect!) The value of
<span><code>LVR</code></span> is not critical for scalar machines, as
long as it is fairly large. We found little difference between
<span><code>LVR</code></span>=64 and 128 on a Sparc 10/51, on an
Ultrasparc 170, and on an Intel<sup></sup> Xeon cpu. You may wish to
experiment with different <span><code>LVR</code></span> values on your
computer architecture. To change <span><code>LVR</code></span>, you need
to edit <span><code>gpfa.f90</code></span> and change the three
<span><code>data</code></span> statements where
<span><code>LVR</code></span> is set.<a href="#fnref11"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p><span id="fn:235" label="fn:235"></span>2, 3, 4, 5, 6,
8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50,
54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144,
150, 160, 162, 180, 192, 200 216, 225, 240, 243, 250, 256, 270, 288,
300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512,
540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 800, 810, 864,
900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280,
1296, 1350, 1440, 1458, 1500, 1536, 1600, 1620, 1728, 1800, 1875, 1920,
1944, 2000, 2025, 2048, 2160, 2187, 2250, 2304, 2400, 2430, 2500, 2560,
2592, 2700, 2880, 2916, 3000, 3072, 3125, 3200, 3240, 3375, 3456, 3600,
3645, 3750, 3840, 3888, 4000, 4050, 4096 are the integers <span
class="math inline">\(\leq 4096\)</span> which are of the form <span
class="math inline">\(2^i3^j5^k\)</span>.<a href="#fnref12"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Non-Linux sites: The source code for
<span><code>CALLTARGET</code></span> is in the file
<span><code>CALLTARGET.f90</code></span>. You must compile and link
<span><code>CALLTARGET.f90</code></span>,
<span><code>ddcommon.f90</code></span>,
<span><code>dsyevj3.f90</code></span>,
<span><code>errmsg.f90</code></span>,
<span><code>gasdev.f90</code></span>,
<span><code>p_lm.f90</code></span>,
<span><code>prinaxis.f90</code></span>,
<span><code>ran3.f90</code></span>,
<span><code>reashp.f90</code></span>,
<span><code>sizer.f90</code></span>,
<span><code>tar2el.f90</code></span>,
<span><code>tar2sp.f90</code></span>,
<span><code>tar3el.f90</code></span>,
<span><code>taranirec.f90</code></span>,
<span><code>tarblocks.f90</code></span>,
<span><code>tarcel.f90</code></span>,
<span><code>tarcyl.f90</code></span>,
<span><code>tarcylcap.f90</code></span>,
<span><code>tarell.f90</code></span>,
<span><code>target.f90</code></span>,
<span><code>targspher.f90</code></span>,
<span><code>tarhex.f90</code></span>,
<span><code>tarnas.f90</code></span>,
<span><code>tarnsp.f90</code></span>,
<span><code>tarpbxn.f90</code></span>,
<span><code>tarprsm.f90</code></span>,
<span><code>tarrctblk3.f90</code></span>,
<span><code>tarrecrec.f90</code></span>,
<span><code>tarslblin.f90</code></span>,
<span><code>tartet.f90</code></span>, and
<span><code>wrimsg.f90</code></span>.<a href="#fnref13"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p><span class="citation" data-cites="Draine_1988"></span>
adopted the convention <span class="math inline">\(\hat{\bf
e}_{02}=\hat{\bf x}\times\hat{\bf e}_{01}^*\)</span>. The customary
definition of <span class="math inline">\(\hat{\bf e}_{i\perp}\)</span>
is <span class="math inline">\(\hat{\bf e}_{i\perp}\equiv\hat{\bf
e}_{i\parallel}\times\hat{\bf k}_0\)</span> <span class="citation"
data-cites="Bohren+Huffman_1983"></span>. Thus, if <span
class="math inline">\(\hat{\bf e}_{01}=\hat{\bf
e}_{i\parallel}\)</span>, then <span class="math inline">\(\hat{\bf
e}_{02}=-\hat{\bf e}_{i\perp}\)</span>.<a href="#fnref14"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>A frequent choice is <span
class="math inline">\(\hat{\bf e}_{01}=\hat{\bf y}_{\rm LF}\)</span>,
with <span class="math inline">\(\hat{\bf e}_{02}=\hat{\bf x}_{\rm
LF}\times\hat{\bf y}_{\rm LF}= \hat{\bf z}_{\rm LF}\)</span>.<a
href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>MATLAB<sup></sup> users may wish to check
<span><code>http://www.google.com/p/ddscat/</code></span> to see if a
MATLAB<sup></sup> version of ddpostprocess is available.<a
href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div>
            <div class="d-none d-xl-block col-xl-2 bd-toc">
               <ul class="section-nav">
                  <li class="toc-entry"><ul>
<li><a href="#introduction" id="toc-introduction">Introduction<span
id="intro" label="intro"></span></a></li>
<li><a href="#applicability-of-the-dda"
id="toc-applicability-of-the-dda">Applicability of the DDA<span
id="sec:applicability" label="sec:applicability"></span></a></li>
<li><a href="#ddscat-7.3" id="toc-ddscat-7.3">DDSCAT 7.3<span
id="sec:DDSCATvers" label="sec:DDSCATvers"></span></a></li>
<li><a href="#whats-new" id="toc-whats-new">What’s New?<span
id="sec:whats_new" label="sec:whats_new"></span></a></li>
<li><a href="#downloading-the-source-code-and-example-calculations"
id="toc-downloading-the-source-code-and-example-calculations">Downloading
the Source Code and Example Calculations <span id="sec:downloading"
label="sec:downloading"></span></a></li>
<li><a href="#compiling-and-linking-on-unixlinux-systems"
id="toc-compiling-and-linking-on-unixlinux-systems">Compiling and
Linking on Unix/Linux Systems<span id="sec:compiling"
label="sec:compiling"></span></a></li>
<li><a href="#information-for-windows-users"
id="toc-information-for-windows-users"><span id="sec:windows"
label="sec:windows"></span> Information for Windows Users</a></li>
<li><a href="#a-sample-calculation-rctglprsm"
id="toc-a-sample-calculation-rctglprsm">A Sample Calculation:
<span><code>RCTGLPRSM</code></span> <span id="sec:sample calculation"
label="sec:sample calculation"></span></a></li>
<li><a href="#the-parameter-file-ddscat.par"
id="toc-the-parameter-file-ddscat.par">The Parameter File
<span><code>ddscat.par</code></span> <span id="sec:parameter_file"
label="sec:parameter_file"></span></a></li>
<li><a href="#running-ddscat-7.3-using-the-sample-ddscat.par-file"
id="toc-running-ddscat-7.3-using-the-sample-ddscat.par-file">Running
<span><strong>DDSCAT 7.3</strong></span> Using the Sample
<span><code>ddscat.par</code></span> File</a></li>
<li><a href="#output-files" id="toc-output-files">Output Files</a></li>
<li><a href="#choice-of-iterative-algorithm"
id="toc-choice-of-iterative-algorithm">Choice of Iterative
Algorithm<span id="sec:choice_of_algorithm"
label="sec:choice_of_algorithm"></span></a></li>
<li><a href="#choice-of-fft-algorithm"
id="toc-choice-of-fft-algorithm">Choice of FFT Algorithm<span
id="sec:choice_of_fft" label="sec:choice_of_fft"></span></a></li>
<li><a href="#choice-of-dda-method" id="toc-choice-of-dda-method">Choice
of DDA Method<span id="sec:DDA_method"
label="sec:DDA_method"></span></a></li>
<li><a href="#dielectric-functions"
id="toc-dielectric-functions">Dielectric Functions<span
id="sec:dielectric_func" label="sec:dielectric_func"></span></a></li>
<li><a
href="#calculation-of-langlecosthetarangle-radiative-force-and-radiation-torque"
id="toc-calculation-of-langlecosthetarangle-radiative-force-and-radiation-torque">Calculation
of <span class="math inline">\(\langle\cos\theta\rangle\)</span>,
Radiative Force, and Radiation Torque <span
id="sec:force and torque calculation"
label="sec:force and torque calculation"></span></a></li>
<li><a href="#memory-requirements" id="toc-memory-requirements">Memory
Requirements <span id="sec:memory_requirements"
label="sec:memory_requirements"></span></a></li>
<li><a href="#target-geometry-the-target-frame"
id="toc-target-geometry-the-target-frame">Target Geometry: The Target
Frame <span id="sec:target geometry"
label="sec:target geometry"></span></a></li>
<li><a href="#target-orientation-1" id="toc-target-orientation-1">Target
Orientation <span id="sec:target_orientation"
label="sec:target_orientation"></span></a></li>
<li><a href="#orientational-averaging"
id="toc-orientational-averaging">Orientational Averaging<span
id="sec:orientational_averaging"
label="sec:orientational_averaging"></span></a></li>
<li><a href="#target-generation-isolated-finite-targets"
id="toc-target-generation-isolated-finite-targets">Target Generation:
Isolated Finite Targets <span id="sec:target_generation"
label="sec:target_generation"></span></a></li>
<li><a href="#target-generation-periodic-targets"
id="toc-target-generation-periodic-targets">Target Generation: Periodic
Targets <span id="sec:target_generation_PBC"
label="sec:target_generation_PBC"></span></a></li>
<li><a href="#scattering-directions"
id="toc-scattering-directions">Scattering Directions <span
id="sec:scattering_directions"
label="sec:scattering_directions"></span></a></li>
<li><a href="#incident-polarization-state"
id="toc-incident-polarization-state">Incident Polarization State<span
id="sec:incident_polarization"
label="sec:incident_polarization"></span></a></li>
<li><a
href="#averaging-over-scattering-directions-g1langlecostheta_srangle-etc."
id="toc-averaging-over-scattering-directions-g1langlecostheta_srangle-etc.">Averaging
over Scattering Directions: <span
class="math inline">\(g(1)=\langle\cos\theta_s\rangle\)</span>,
etc.<span id="sec:averaging_scattering"
label="sec:averaging_scattering"></span></a></li>
<li><a href="#scattering-by-finite-targets-the-mueller-matrix"
id="toc-scattering-by-finite-targets-the-mueller-matrix">Scattering by
Finite Targets: The Mueller Matrix <span id="sec:mueller_matrix"
label="sec:mueller_matrix"></span></a></li>
<li><a href="#scattering-by-periodic-targets-generalized-mueller-matrix"
id="toc-scattering-by-periodic-targets-generalized-mueller-matrix">Scattering
by Periodic Targets: Generalized Mueller Matrix <span
id="sec:generalized mueller matrix"
label="sec:generalized mueller matrix"></span></a></li>
<li><a href="#composite-targets-with-anisotropic-constituents"
id="toc-composite-targets-with-anisotropic-constituents">Composite
Targets with Anisotropic Constituents <span
id="sec:composite anisotropic targets"
label="sec:composite anisotropic targets"></span></a></li>
<li><a
href="#near-field-calculations-bf-e-and-bf-b-within-or-near-the-target"
id="toc-near-field-calculations-bf-e-and-bf-b-within-or-near-the-target">Near-Field
Calculations: <span class="math inline">\({\bf E}\)</span> and <span
class="math inline">\({\bf B}\)</span> Within or Near the Target <span
id="sec:nearfield" label="sec:nearfield"></span> <span
id="sec:micro_vs_macro" label="sec:micro_vs_macro"></span> </a></li>
<li><a href="#post-processing-of-near-field-calculations"
id="toc-post-processing-of-near-field-calculations">Post-Processing of
Near-Field Calculations <span id="sec:postprocessing"
label="sec:postprocessing"></span></a></li>
<li><a href="#displaying-target-shapes"
id="toc-displaying-target-shapes">Displaying Target Shapes</a></li>
<li><a href="#visualization-of-the-electric-field"
id="toc-visualization-of-the-electric-field">Visualization of the
Electric Field <span id="sec:visualization of E"
label="sec:visualization of E"></span> </a></li>
<li><a href="#finale" id="toc-finale">Finale</a></li>
<li><a href="#acknowledgments"
id="toc-acknowledgments">Acknowledgments</a></li>
<li><a href="#references" id="toc-references">References</a></li>
<li><a href="#appendix" id="toc-appendix">Appendix</a></li>
</ul></li>
               </ul>
            </div>
         </div>
               </div>
            <!-- Add comment hosting service here -->
            <!-- Footer -->
            <footer class="footer text-muted">
               <div align="center">
                  <!-- Update licences -->
                  Content is available under <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="noopener">CC BY-SA 3.0</a>
                  &nbsp;|&nbsp;
                  Sourcecode licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.en.html" target="_blank" rel="noopener">GPL-3.0</a>
                  <br />
                  <!-- Please keep the following line -->
                  Built with <a href="https://www.pandoc.org" target="_blank" rel="noopener">Pandoc</a> 
                  using <a href="https://github.com/ashki23/pandoc-bootstrap" target="_blank" rel="noopener">pandoc-bootstrap</a> theme
                  <br />
                  <!-- Update copyright -->
                  <!-- Copyright, Author Name -->
               </div>
            </footer>
            <!-- Add global site tag (gtag.js) and site analytics here -->
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
